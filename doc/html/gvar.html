<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>gvar - Gaussian Random Variables &mdash; lsqfit 6.0 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="lsqfit 6.0 documentation" href="index.html" />
    <link rel="next" title="gvar.dataset - Random Data Sets" href="gvar_dataset.html" />
    <link rel="prev" title="Case Study: Pendulum" href="case-pendulum.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body role="document">

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gvar_dataset.html" title="gvar.dataset - Random Data Sets"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="case-pendulum.html" title="Case Study: Pendulum"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">lsqfit 6.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="gvar-gaussian-random-variables">
<h1><a class="reference internal" href="#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code></a> - Gaussian Random Variables<a class="headerlink" href="#gvar-gaussian-random-variables" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-gvar"></span><div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This module provides tools for representing and manipulating Gaussian
random variables numerically. It can deal with individual variables or
arbitrarily large sets of variables, correlated or uncorrelated. It
also supports complicated (Python) functions of Gaussian
variables.</p>
<p>A Gaussian variable is a random variable that
represents a <em>typical</em> random number drawn from a particular Gaussian (or
normal) probability distribution; more precisely, it represents the entire
probability distribution. A given Gaussian variable <code class="docutils literal"><span class="pre">x</span></code> is therefore
completely characterized by its mean <code class="docutils literal"><span class="pre">x.mean</span></code> and standard deviation
<code class="docutils literal"><span class="pre">x.sdev</span></code>.</p>
<p>A mathematical function of a Gaussian variable can be defined as the
probability distribution of function values obtained by evaluating the
function for random numbers drawn from the original distribution. The
distribution of function values is itself approximately Gaussian provided the
standard deviation of the Gaussian variable is sufficiently small. Thus we can
define a function <code class="docutils literal"><span class="pre">f</span></code> of a Gaussian variable <code class="docutils literal"><span class="pre">x</span></code> to be a Gaussian variable
itself, with</p>
<div class="highlight-python"><div class="highlight"><pre>f(x).mean = f(x.mean)
f(x).sdev = x.sdev |f&#39;(x.mean)|,
</pre></div>
</div>
<p>which follows from linearizing the <code class="docutils literal"><span class="pre">x</span></code> dependence of <code class="docutils literal"><span class="pre">f(x)</span></code> about point
<code class="docutils literal"><span class="pre">x.mean</span></code>. (This obviously fails at an extremum of <code class="docutils literal"><span class="pre">f(x)</span></code>, where
<code class="docutils literal"><span class="pre">f'(x)=0</span></code>.)</p>
<p>The last formula, together with its multidimensional generalization, leads
to a full calculus for Gaussian random variables that assigns
Gaussian-variable values to arbitrary arithmetic expressions and functions
involving Gaussian variables.
A multidimensional collection <code class="docutils literal"><span class="pre">x[i]</span></code> of Gaussian variables is
characterized by the means <code class="docutils literal"><span class="pre">x[i].mean</span></code> for each variable, together with a
covariance matrix <code class="docutils literal"><span class="pre">cov[i,</span> <span class="pre">j]</span></code>. Diagonal elements of <code class="docutils literal"><span class="pre">cov</span></code> specify the
standard deviations of different variables: <code class="docutils literal"><span class="pre">x[i].sdev</span> <span class="pre">=</span> <span class="pre">cov[i,</span> <span class="pre">i]**0.5</span></code>.
Nonzero off-diagonal elements imply correlations between different
variables:</p>
<div class="highlight-python"><div class="highlight"><pre>cov[i, j] = &lt;x[i]*x[j]&gt;  -  &lt;x[i]&gt; * &lt;x[j]&gt;
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">&lt;y&gt;</span></code> denotes the expectation value or mean for a random variable
<code class="docutils literal"><span class="pre">y</span></code>.</p>
<p>Gaussian variables are represented in <a class="reference internal" href="#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code></a>
by objects of type <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>. <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are particularly useful
for error propagation because the errors
(i.e., standard deviations) associated with them
propagate through arbitrarily complex Python functions. This is true
of errors from individual <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s,
and also of the correlations between different
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. In the following sections we demonstrate how to create
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s and how to manipulate them to solve common problems in
error propagation. They are also very useful for creating
correlated Gaussian priors for Bayesian analyses.</p>
</div>
<div class="section" id="creating-gaussian-variables">
<span id="id1"></span><h2>Creating Gaussian Variables<a class="headerlink" href="#creating-gaussian-variables" title="Permalink to this headline">¶</a></h2>
<p>Objects of type <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> are of two types: 1) primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
that are created from means and covariances using
<a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>; and 2) derived <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s that result
from arithmetic expressions or functions involving <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
(primary or derived).
A single (primary) <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> is
created from its mean <code class="docutils literal"><span class="pre">xmean</span></code> and standard deviation
<code class="docutils literal"><span class="pre">xsdev</span></code> using:</p>
<div class="highlight-python"><div class="highlight"><pre>x = gvar.gvar(xmean, xsdev).
</pre></div>
</div>
<p>This function can also be used to convert strings like <code class="docutils literal"><span class="pre">&quot;-72.374(22)&quot;</span></code>
or <code class="docutils literal"><span class="pre">&quot;511.2</span> <span class="pre">+-</span> <span class="pre">0.3&quot;</span></code> into <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">3.1415</span><span class="p">,</span> <span class="mf">0.0002</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3.14150(20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="s">&quot;3.1415(2)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3.14150(20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="s">&quot;3.1415 +- 0.0002&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3.14150(20)</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">gvar.gvar(x)</span></code> is useful when you are unsure
whether <code class="docutils literal"><span class="pre">x</span></code> is a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> or a string representing a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>.</p>
<p><a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are usually more interesting when used to describe multidimensional
distributions, especially if there are correlations between different
variables. Such distributions are represented by collections of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in
one of two standard formats: 1) <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code>  arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (any
shape); or, more flexibly, 2) Python dictionaries whose values are <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or
arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. Most functions in <a class="reference internal" href="#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code></a> that handle multiple
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s work with either format, and if they return multidimensional results
do so in the same format as the inputs (that is, arrays or dictionaries). Any
dictionary is converted internally into a specialized (ordered) dictionary of
type <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a>, and dictionary-valued results are also <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a>s.</p>
<p>To create an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s with mean values specified by array
<code class="docutils literal"><span class="pre">xmean</span></code> and covariance matrix <code class="docutils literal"><span class="pre">xcov</span></code>, use</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">xmean</span><span class="p">,</span> <span class="n">xcov</span><span class="p">)</span>
</pre></div>
</div>
<p>where array <code class="docutils literal"><span class="pre">x</span></code> has the same shape as <code class="docutils literal"><span class="pre">xmean</span></code> (and <code class="docutils literal"><span class="pre">xcov.shape</span> <span class="pre">=</span>
<span class="pre">xmean.shape+xmean.shape</span></code>). Then each element <code class="docutils literal"><span class="pre">x[i]</span></code> of a one-dimensional
array, for example, is a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> where:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">xmean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>         <span class="c"># mean of x[i]</span>
<span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>  <span class="o">=</span> <span class="n">xmean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>         <span class="c"># same as x[i].mean</span>
<span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">xcov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mf">0.5</span>  <span class="c"># std deviation of x[i]</span>
<span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">var</span>  <span class="o">=</span> <span class="n">xcov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>       <span class="c"># variance of x[i]</span>
</pre></div>
</div>
<p>As an example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.</span><span class="p">],</span> <span class="p">[[</span><span class="mf">0.015625</span><span class="p">,</span> <span class="mf">0.24</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.24</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;x =&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s">&#39;   y =&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">x = 0.10(13)    y = 10.0(2.0)</span>
</pre></div>
</div>
<p>makes <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s with standard deviations <code class="docutils literal"><span class="pre">sigma_x=0.125</span></code> and
<code class="docutils literal"><span class="pre">sigma_y=2</span></code>, and a fairly strong statistical correlation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">evalcov</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]))</span>     <span class="c"># covariance matrix</span>
<span class="go">[[ 0.015625  0.24    ]</span>
<span class="go"> [ 0.24      4.      ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">evalcorr</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]))</span>    <span class="c"># correlation matrix</span>
<span class="go">[[ 1.    0.96]</span>
<span class="go"> [ 0.96  1.  ]]</span>
</pre></div>
</div>
<p>Here functions <a class="reference internal" href="#gvar.evalcov" title="gvar.evalcov"><code class="xref py py-func docutils literal"><span class="pre">gvar.evalcov()</span></code></a> and <a class="reference internal" href="#gvar.evalcorr" title="gvar.evalcorr"><code class="xref py py-func docutils literal"><span class="pre">gvar.evalcorr()</span></code></a> compute the
covariance and correlation matrices, respectively, of the list of
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in their arguments.</p>
<p><a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a> can also be used to convert strings or tuples stored in
arrays or dictionaries into <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">garray</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="s">&#39;2(1)&#39;</span><span class="p">,</span> <span class="s">&#39;10+-5&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">garray</span><span class="p">)</span>
<span class="go">[2.0(1.0) 10.0(5.0) 99.0(3.0) 0.0(2.0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdict</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s">&#39;2(1)&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;10+-5&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gdict</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 2.0(1.0),&#39;b&#39;: array([10.0(5.0), 99.0(3.0), 0.0(2.0)], dtype=object)}</span>
</pre></div>
</div>
<p>If the covariance matrix in <code class="docutils literal"><span class="pre">gvar.gvar</span></code> is diagonal, it can be replaced
by an array of standard deviations (square roots of diagonal entries in
<code class="docutils literal"><span class="pre">cov</span></code>). The example above without correlations, therefore, would be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;x =&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s">&#39;   y =&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">x = 0.10(12)    y = 10.0(2.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">evalcov</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]))</span>     <span class="c"># covariance matrix</span>
<span class="go">[[ 0.015625  0.      ]</span>
<span class="go"> [ 0.        4.      ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">evalcorr</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]))</span>    <span class="c"># correlation matrix</span>
<span class="go">[[ 1.  0.]</span>
<span class="go"> [ 0.  1.]]</span>
</pre></div>
</div>
</div>
<div class="section" id="gvar-arithmetic-and-functions">
<span id="id2"></span><h2><a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> Arithmetic and Functions<a class="headerlink" href="#gvar-arithmetic-and-functions" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s discussed in the previous section are all <em>primary</em> <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
since they were created by specifying their means and covariances
explicitly, using <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>. What makes <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s particularly
useful is that they can be used in
arithemtic expressions (and numeric pure-Python functions), just like
Python floats. Such expressions result in new, <em>derived</em> <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
whose means, standard deviations, and correlations
are determined from the covariance matrix of the
primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. The
automatic propagation of correlations
through arbitrarily complicated arithmetic is an especially useful
feature of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</p>
<p>As an example, again define</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span>
</pre></div>
</div>
<p>and set</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;f =&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="go">f = 10.1(2.0)</span>
</pre></div>
</div>
<p>Then <code class="docutils literal"><span class="pre">f</span></code> is a (derived) <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> whose variance <code class="docutils literal"><span class="pre">f.var</span></code> equals</p>
<div class="highlight-python"><div class="highlight"><pre>df/dx cov[0, 0] df/dx + 2 df/dx cov[0, 1] df/dy + ... = 2.0039**2
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">cov</span></code> is the original covariance matrix used to define <code class="docutils literal"><span class="pre">x</span></code> and
<code class="docutils literal"><span class="pre">y</span></code> (in <code class="docutils literal"><span class="pre">gvar.gvar</span></code>). Note that while <code class="docutils literal"><span class="pre">f</span></code> and <code class="docutils literal"><span class="pre">y</span></code> separately have
20% uncertainties in this example, the ratio <code class="docutils literal"><span class="pre">f/y</span></code> has much smaller
errors:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>
<span class="go">1.010(13)</span>
</pre></div>
</div>
<p>This happens, of course, because the errors in <code class="docutils literal"><span class="pre">f</span></code> and <code class="docutils literal"><span class="pre">y</span></code> are highly
correlated &#8212; the error in <code class="docutils literal"><span class="pre">f</span></code> comes mostly from <code class="docutils literal"><span class="pre">y</span></code>. <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
automatically track correlations even through complicated arithmetic
expressions and functions: for example, the following
more complicated ratio has a still
smaller error, because of stronger correlations between numerator and
denominator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">f</span><span class="p">)</span>
<span class="go">1.4072(87)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">evalcorr</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">y</span><span class="p">]))</span>
<span class="go">[[ 1.          0.99805258]</span>
<span class="go"> [ 0.99805258  1.        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">evalcorr</span><span class="p">([</span><span class="n">gvar</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">]))</span>
<span class="go">[[ 1.         0.9995188]</span>
<span class="go"> [ 0.9995188  1.       ]]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code></a> module defines versions of the standard Python mathematical
functions that work with <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> arguments. These include:
<code class="docutils literal"><span class="pre">exp,</span> <span class="pre">log,</span> <span class="pre">sqrt,</span> <span class="pre">sin,</span> <span class="pre">cos,</span> <span class="pre">tan,</span> <span class="pre">arcsin,</span> <span class="pre">arccos,</span> <span class="pre">arctan,</span> <span class="pre">arctan2,</span> <span class="pre">sinh,</span> <span class="pre">cosh,</span>
<span class="pre">tanh,</span> <span class="pre">arcsinh,</span> <span class="pre">arccosh,</span> <span class="pre">arctanh</span></code>. Numeric functions defined
entirely in Python (<em>i.e.</em>, pure-Python functions)
will likely also work with <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</p>
<p>Numeric functions implemented by modules using low-level languages like C
will <em>not</em> work with <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. Such functions must
be replaced by equivalent code written
directly in Python. In some cases it is possible to construct
a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>-capable function from low-level code for the function and its
derivative. For example, the following code defines a new version of the
standard Python error function that accepts either floats or <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
as its argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">gvar</span>

<span class="k">def</span> <span class="nf">erf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gvar</span><span class="o">.</span><span class="n">GVar</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
        <span class="n">dfdx</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dfdx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Here function <a class="reference internal" href="#gvar.gvar_function" title="gvar.gvar_function"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar_function()</span></code></a> creates the <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> for a function with
mean value <code class="docutils literal"><span class="pre">f</span></code> and derivative <code class="docutils literal"><span class="pre">dfdx</span></code> at point <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>Some sample numerical analysis codes, adapted for use with <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, are
described in <a class="reference internal" href="gvar_other.html#numerical-analysis-modules-in-gvar"><span>Numerical Analysis Modules in gvar</span></a>.</p>
<p>Arithmetic operators <code class="docutils literal"><span class="pre">+</span> <span class="pre">-</span> <span class="pre">*</span> <span class="pre">/</span> <span class="pre">**</span> <span class="pre">==</span> <span class="pre">!=</span> <span class="pre">&lt;&gt;</span> <span class="pre">+=</span> <span class="pre">-=</span> <span class="pre">*=</span> <span class="pre">/=</span></code> are all defined
for <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. Comparison operators are also supported: <code class="docutils literal"><span class="pre">==</span> <span class="pre">!=</span> <span class="pre">&gt;</span> <span class="pre">&gt;=</span> <span class="pre">&lt;</span> <span class="pre">&lt;=</span></code>.
They are applied to the mean values of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s: for example,
<code class="docutils literal"><span class="pre">gvar.gvar(1,1)</span> <span class="pre">==</span> <span class="pre">gvar.var(1,2)</span></code> is true, as is <code class="docutils literal"><span class="pre">gvar.gvar(1,1)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.
Logically <code class="docutils literal"><span class="pre">x&gt;y</span></code> for <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s should evaluate to a boolean-valued random
variable, but such variables are beyond the scope of this module.
Comparison operators that act only on the mean values make it easier to implement
pure-Python functions that work with either <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or <code class="xref py py-class docutils literal"><span class="pre">float</span></code>s
as arguments.</p>
<p><em>Implementation Notes:</em> Each <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> keeps track of three
pieces of information: 1) its mean value; 2) its derivatives with respect to
the primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (created by <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>);
and 3) the location of the covariance matrix for the primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.
The derivatives and covariance matrix allow one to compute the
standard deviation of the <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, as well as correlations between it and any
other function of the primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. The derivatives for
derived <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are computed automatically, using <em>automatic
differentiation</em>.</p>
<p>The derivative of a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> <code class="docutils literal"><span class="pre">f</span></code> with
respect to a primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> <code class="docutils literal"><span class="pre">x</span></code> is obtained from <code class="docutils literal"><span class="pre">f.deriv(x)</span></code>. A list
of derivatives with respect to all primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s is given by <code class="docutils literal"><span class="pre">f.der</span></code>,
where the order of derivatives is the same as the order in which the primary
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s were created.</p>
<p>A <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> can be constructed at a
very low level by supplying all the three
essential pieces of information &#8212; for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">fmean</span><span class="p">,</span> <span class="n">fder</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">fmean</span></code> is the mean, <code class="docutils literal"><span class="pre">fder</span></code> is an array where <code class="docutils literal"><span class="pre">fder[i]</span></code> is the
derivative of <code class="docutils literal"><span class="pre">f</span></code> with respect to the <code class="docutils literal"><span class="pre">i</span></code>-th primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>
(numbered in the order in which they were created using <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>),
and <code class="docutils literal"><span class="pre">cov</span></code> is the covariance matrix for the primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (easily
obtained from an existing <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> <code class="docutils literal"><span class="pre">x</span></code> using <code class="docutils literal"><span class="pre">x.cov</span></code>).</p>
</div>
<div class="section" id="error-budgets-from-gvars">
<h2>Error Budgets from <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s<a class="headerlink" href="#error-budgets-from-gvars" title="Permalink to this headline">¶</a></h2>
<p>It is sometimes useful to know how much of the uncertainty in a derived quantity
is due to a particular input uncertainty. Continuing the example above, for
example, we might want to know how much of <code class="docutils literal"><span class="pre">f</span></code>s standard deviation
is due to the standard deviation of <code class="docutils literal"><span class="pre">x</span></code> and how much comes from <code class="docutils literal"><span class="pre">y</span></code>.
This is easily computed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">partialsdev</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>        <span class="c"># uncertainty in f due to x</span>
<span class="go">0.125</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">partialsdev</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>        <span class="c"># uncertainty in f due to y</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">partialsdev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>     <span class="c"># uncertainty in f due to x and y</span>
<span class="go">2.00390244274</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">sdev</span><span class="p">)</span>                  <span class="c"># should be the same</span>
<span class="go">2.00390244274</span>
</pre></div>
</div>
<p>This shows, for example, that most (2.0) of the uncertainty in <code class="docutils literal"><span class="pre">f</span></code> (2.0039)
is from <code class="docutils literal"><span class="pre">y</span></code>.</p>
<p><a class="reference internal" href="#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code></a> provides a useful tool for compiling an &#8220;error budget&#8221; for
derived <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s relative to the primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s from which they
were constructed: continuing the example above,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">outputs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;f&#39;</span><span class="p">:</span><span class="n">f</span><span class="p">,</span> <span class="s">&#39;f/y&#39;</span><span class="p">:</span><span class="n">f</span><span class="o">/</span><span class="n">y</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">fmt_values</span><span class="p">(</span><span class="n">outputs</span><span class="p">))</span>
<span class="go">Values:</span>
<span class="go">                f/y: 1.010(13)</span>
<span class="go">                  f: 10.1(2.0)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">fmt_errorbudget</span><span class="p">(</span><span class="n">outputs</span><span class="o">=</span><span class="n">outputs</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">))</span>
<span class="go">Partial % Errors:</span>
<span class="go">                           f/y         f</span>
<span class="go">----------------------------------------</span>
<span class="go">                  y:      0.20     19.80</span>
<span class="go">                  x:      1.24      1.24</span>
<span class="go">----------------------------------------</span>
<span class="go">              total:      1.25     19.84</span>
</pre></div>
</div>
<p>This shows <code class="docutils literal"><span class="pre">y</span></code> is responsible for 19.80% of the 19.84% uncertainty in <code class="docutils literal"><span class="pre">f</span></code>,
but only 0.2% of the 1.25% uncertainty in <code class="docutils literal"><span class="pre">f/y</span></code>. The total uncertainty in each case
is obtained by adding the <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> contributions in quadrature.</p>
</div>
<div class="section" id="storing-gvars-for-later-use-bufferdicts">
<span id="storing-gvars-for-later-use"></span><h2>Storing <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s for Later Use; <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a>s<a class="headerlink" href="#storing-gvars-for-later-use-bufferdicts" title="Permalink to this headline">¶</a></h2>
<p>Storing <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in a file for later use is complicated by the need to
capture the covariances between different <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s as well as their
means. To pickle an array or dictionary <code class="docutils literal"><span class="pre">g</span></code> of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, for example,
we might use</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gtuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">evalcov</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">gtuple</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;outputfile.p&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>to extract the means and covariance matrix into a tuple which then
is saved in file <code class="docutils literal"><span class="pre">'output.p'</span></code> using Python&#8217;s standard <code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code>
module. To reassemble the <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s we use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;outputfile.p&#39;</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>where <code class="xref py py-func docutils literal"><span class="pre">pickle.load()</span></code> reads <code class="docutils literal"><span class="pre">gtuple</span></code> back in, and <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>
converts it back into a collection of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. The correlations between
different <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s  in the original array/dictionary <code class="docutils literal"><span class="pre">g</span></code> are preserved here,
but their correlations with other <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are lost. So it is important to
include all <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s of  interest in a single array or dictionary before
saving them.</p>
<p>This recipe works for <code class="docutils literal"><span class="pre">g</span></code>s that are: single <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
(any shape), or dictionaries whose values are <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s and/or arrays  of
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. For convenience, it is implemented in functions <a class="reference internal" href="#gvar.dump" title="gvar.dump"><code class="xref py py-func docutils literal"><span class="pre">gvar.dump()</span></code></a>,
<a class="reference internal" href="#gvar.dumps" title="gvar.dumps"><code class="xref py py-func docutils literal"><span class="pre">gvar.dumps()</span></code></a>, <a class="reference internal" href="#gvar.load" title="gvar.load"><code class="xref py py-func docutils literal"><span class="pre">gvar.load()</span></code></a>, and <a class="reference internal" href="#gvar.loads" title="gvar.loads"><code class="xref py py-func docutils literal"><span class="pre">gvar.loads()</span></code></a>.</p>
<p>Pickling is simplified if the <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s that need saving are all
in a <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> since these can be serialized and saved to a file
again using Python&#8217;s <code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code> module. So if <code class="docutils literal"><span class="pre">g</span></code> is a
<a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> containing <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (and/or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s),</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;outputfile.p&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>saves the contents of <code class="docutils literal"><span class="pre">g</span></code> to a file named <code class="docutils literal"><span class="pre">outputfile.p</span></code>.
The <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are retrieved using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;outputfile.p&#39;</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p><a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a>s also have methods that allow saving their contents
using Python&#8217;s <code class="xref py py-mod docutils literal"><span class="pre">json</span></code> module rather than <code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code>.</p>
</div>
<div class="section" id="random-number-generators">
<span id="gvar-random-number-generators"></span><h2>Random Number Generators<a class="headerlink" href="#random-number-generators" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s represent probability distributions. It is possible to use them
to generate random numbers from those distributions. For example, in</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">z</span><span class="p">())</span>
<span class="go">2.29895701465</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">z</span><span class="p">())</span>
<span class="go">3.00633184275</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">z</span><span class="p">())</span>
<span class="go">1.92649199321</span>
</pre></div>
</div>
<p>calls to <code class="docutils literal"><span class="pre">z()</span></code> generate random numbers from a Gaussian random number
generator with mean <code class="docutils literal"><span class="pre">z.mean=2.0</span></code> and standard deviation <code class="docutils literal"><span class="pre">z.sdev=0.5</span></code>.</p>
<p>To obtain random arrays from an array <code class="docutils literal"><span class="pre">g</span></code> of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
use <code class="docutils literal"><span class="pre">giter=gvar.raniter(g)</span></code> (see <a class="reference internal" href="#gvar.raniter" title="gvar.raniter"><code class="xref py py-func docutils literal"><span class="pre">gvar.raniter()</span></code></a>) to create a
random array generator <code class="docutils literal"><span class="pre">giter</span></code>. Each call to <code class="docutils literal"><span class="pre">next(giter)</span></code> generates
a new array of random numbers. The random number arrays have the same
shape as the array <code class="docutils literal"><span class="pre">g</span></code> of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s and have the distribution implied
by those random variables (including correlations). For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">da</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">da</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">giter</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">raniter</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">giter</span><span class="p">))</span>
<span class="go">[ 1.51874589  1.59987422]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">giter</span><span class="p">))</span>
<span class="go">[-1.39755111 -1.24780937]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">giter</span><span class="p">))</span>
<span class="go">[ 0.49840244  0.50643312]</span>
</pre></div>
</div>
<p>Note how the two random numbers separately vary over the region 1±1
(approximately), but the separation between the two is rarely more than
0±0.1. This is as expected given the strong correlation between <code class="docutils literal"><span class="pre">a</span></code>
and <code class="docutils literal"><span class="pre">a+da</span></code>.</p>
<p><code class="docutils literal"><span class="pre">gvar.raniter(g)</span></code> also works when <code class="docutils literal"><span class="pre">g</span></code> is a dictionary (or
<a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a>) whose entries <code class="docutils literal"><span class="pre">g[k]</span></code> are <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. In such cases the iterator returns a dictionary with the same
layout:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 0.0(1.0), &#39;b&#39;: [0(100), 10.0000(10)]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">giter</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">raniter</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">giter</span><span class="p">))</span>
<span class="go">{&#39;a&#39;: -0.88986130981173306, &#39;b&#39;: array([-67.02994213,   9.99973707])}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">giter</span><span class="p">))</span>
<span class="go">{&#39;a&#39;: 0.21289976681277872, &#39;b&#39;: array([ 29.9351328 ,  10.00008606])}</span>
</pre></div>
</div>
<p>One use for such random number generators is dealing with situations where
the standard deviations are too large to justify the linearization
assumed in defining functions of Gaussian variables. Consider, for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">0.5(2.5)</span>
</pre></div>
</div>
<p>The standard deviation for <code class="docutils literal"><span class="pre">cos(x)</span></code> is obviously wrong since <code class="docutils literal"><span class="pre">cos(x)</span></code>
can never be larger than one. To obtain the real mean and standard deviation,
we generate a large number of random numbers <code class="docutils literal"><span class="pre">xi</span></code> from <code class="docutils literal"><span class="pre">x</span></code>, compute
<code class="docutils literal"><span class="pre">cos(xi)</span></code> for each, and compute the mean and standard deviation for the
resulting distribution (or any other statistical quantity, particularly if
the resulting distribution is not Gaussian):</p>
<div class="highlight-python"><div class="highlight"><pre># estimate mean,sdev from 1000 random x&#39;s
&gt;&gt;&gt; ran_x = numpy.array([x() for in range(1000)])
&gt;&gt;&gt; ran_cos = numpy.cos(ran_x)
&gt;&gt;&gt; print(&#39;mean =&#39;, ran_cos.mean(), &#39;  std dev =&#39;, ran_cos.std())
mean = 0.0350548954142   std dev = 0.718647118869

# check by doing more (and different) random numbers
&gt;&gt;&gt; ran_x = numpy.array([x() for in range(100000)])
&gt;&gt;&gt; ran_cos = numpy.cos(ran_x)
&gt;&gt;&gt; print(&#39;mean =&#39;, ran_cos.mean(), &#39;  std dev =&#39;, ran_cos.std())
mean = 0.00806276057656   std dev = 0.706357174056
</pre></div>
</div>
<p>This procedure generalizes trivially for multidimensional analyses, using
arrays or dictionaries with <a class="reference internal" href="#gvar.raniter" title="gvar.raniter"><code class="xref py py-func docutils literal"><span class="pre">gvar.raniter()</span></code></a>.</p>
<p>Finally note that <em>bootstrap</em> copies of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are easily created. A
bootstrap copy of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> <code class="docutils literal"><span class="pre">x</span> <span class="pre">±</span> <span class="pre">dx</span></code> is another <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> with the same width but
where the mean value is replaced by a random number drawn from the original
distribution. Bootstrap copies of a data set, described by a collection of
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, can be used as new (fake) data sets having the same statistical
errors and correlations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.005</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[1.10(10) 0.80(10)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">evalcov</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>                  <span class="c"># print covariance matrix</span>
<span class="go">[[ 0.01   0.005]</span>
<span class="go"> [ 0.005  0.01 ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbs_iter</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">bootstrap_iter</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbs</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">gbs_iter</span><span class="p">)</span>                    <span class="c"># bootstrap copy of f</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gbs</span><span class="p">)</span>
<span class="go">[1.14(10) 0.90(10)]                         # different means</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">evalcov</span><span class="p">(</span><span class="n">gbs</span><span class="p">))</span>
<span class="go">[[ 0.01   0.005]                            # same covariance matrix</span>
<span class="go"> [ 0.005  0.01 ]]</span>
</pre></div>
</div>
<p>Such fake data sets are useful for analyzing non-Gaussian behavior, for
example, in nonlinear fits.</p>
</div>
<div class="section" id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<p>The most fundamental limitation of this module is that the calculus of
Gaussian variables that it assumes is only valid when standard deviations
are small (compared to the distances over which the functions of interest
change appreciably). One way of dealing with this limitation is described
above in the section on <a class="reference internal" href="#gvar-random-number-generators"><span>Random Number Generators</span></a>.</p>
<p>Another potential issue is roundoff error, which can become problematic if
there is a wide range of standard deviations among correlated modes. For
example, the following code works as expected:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">gvar</span> <span class="kn">import</span> <span class="n">gvar</span><span class="p">,</span> <span class="n">evalcov</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tiny</span> <span class="o">=</span> <span class="mf">1e-4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">gvar</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">da</span> <span class="o">=</span> <span class="n">gvar</span><span class="p">(</span><span class="n">tiny</span><span class="p">,</span> <span class="n">tiny</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">ada</span> <span class="o">=</span> <span class="n">gvar</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">da</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">],</span> <span class="n">evalcov</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">da</span><span class="p">]))</span> <span class="c"># = a,a+da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">ada</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>   <span class="c"># should be da again</span>
<span class="go">0.00010(10)</span>
</pre></div>
</div>
<p>Reducing <code class="docutils literal"><span class="pre">tiny</span></code>, however, leads to problems:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">gvar</span> <span class="kn">import</span> <span class="n">gvar</span><span class="p">,</span> <span class="n">evalcov</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tiny</span> <span class="o">=</span> <span class="mf">1e-8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">gvar</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">da</span> <span class="o">=</span> <span class="n">gvar</span><span class="p">(</span><span class="n">tiny</span><span class="p">,</span> <span class="n">tiny</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">ada</span> <span class="o">=</span> <span class="n">gvar</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">da</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">],</span> <span class="n">evalcov</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">da</span><span class="p">]))</span> <span class="c"># = a, a+da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">ada</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>   <span class="c"># should be da again</span>
<span class="go">1(0)e-08</span>
</pre></div>
</div>
<p>Here the call to <a class="reference internal" href="#gvar.evalcov" title="gvar.evalcov"><code class="xref py py-func docutils literal"><span class="pre">gvar.evalcov()</span></code></a> creates a new covariance matrix for
<code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">ada</span> <span class="pre">=</span> <span class="pre">a+da</span></code>, but the matrix does not have enough numerical
precision to encode the size of <code class="docutils literal"><span class="pre">da</span></code>&#8216;s variance, which gets set, in
effect, to zero. The problem arises here for values of <code class="docutils literal"><span class="pre">tiny</span></code> less than
about 2e-8 (with 64-bit floating point numbers &#8212; <code class="docutils literal"><span class="pre">tiny**2</span></code> is what
appears in the covariance matrix).</p>
</div>
<div class="section" id="optimizations">
<h2>Optimizations<a class="headerlink" href="#optimizations" title="Permalink to this headline">¶</a></h2>
<p>When there are lots of primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, the number of derivatives stored
for each derived <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> can
become rather large, potentially (though not necessarily) leading to slower
calculations. One way to alleviate this problem, should it arise, is to
separate the primary variables into groups that are never mixed in
calculations and to use different <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>s when generating the
variables in different groups. New versions of <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a> are
obtained using <a class="reference internal" href="#gvar.switch_gvar" title="gvar.switch_gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.switch_gvar()</span></code></a>: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span>
<span class="o">...</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="o">...</span> <span class="n">other</span> <span class="n">manipulations</span> <span class="n">involving</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">...</span>
<span class="n">gvar</span><span class="o">.</span><span class="n">switch_gvar</span><span class="p">()</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="o">...</span> <span class="n">other</span> <span class="n">manipulations</span> <span class="n">involving</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span> <span class="p">(</span><span class="n">but</span> <span class="ow">not</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">)</span> <span class="o">...</span>
</pre></div>
</div>
<p>Here the <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a> used to create <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> is a different
function than the one used to create <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>. A derived quantity,
like <code class="docutils literal"><span class="pre">c</span></code>, knows about its derivatives with respect to <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>,
and about their covariance matrix; but it carries no derivative information
about <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>. Absent the <code class="docutils literal"><span class="pre">switch_gvar</span></code> line, <code class="docutils literal"><span class="pre">c</span></code> would have
information about its derivatives with respect to <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> (zero
derivative in both cases) and this would make calculations involving <code class="docutils literal"><span class="pre">c</span></code>
slightly slower than with the <code class="docutils literal"><span class="pre">switch_gvar</span></code> line. Usually the difference
is negligible &#8212; it used to be more important, in earlier implementations
of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> before sparse matrices were introduced to keep track of
covariances. Note that the previous <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a> can be restored using
<a class="reference internal" href="#gvar.restore_gvar" title="gvar.restore_gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.restore_gvar()</span></code></a>.</p>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<p>The function used to create Gaussian variable objects is:</p>
<dl class="function">
<dt id="gvar.gvar">
<code class="descclassname">gvar.</code><code class="descname">gvar</code><span class="sig-paren">(</span><em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.gvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Create one or more new <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</p>
<p>Each of the following creates new <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s:</p>
<dl class="function">
<dt>
<code class="descclassname">gvar.</code><code class="descname">gvar</code><span class="sig-paren">(</span><em>x</em>, <em>xsdev</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> with mean <code class="docutils literal"><span class="pre">x</span></code> and standard deviation <code class="docutils literal"><span class="pre">xsdev</span></code>.
Returns an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s if <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">xsdev</span></code> are arrays
with the same shape; the shape of the result is the same as the
shape of <code class="docutils literal"><span class="pre">x</span></code>. Returns a <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> if <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">xsdev</span></code>
are dictionaries with the same keys and layout; the result has
the same keys and layout as <code class="docutils literal"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">gvar.</code><code class="descname">gvar</code><span class="sig-paren">(</span><em>x</em>, <em>xcov</em><span class="sig-paren">)</span></dt>
<dd><p>Returns an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s with means given by array <code class="docutils literal"><span class="pre">x</span></code> and a
covariance matrix given by array <code class="docutils literal"><span class="pre">xcov</span></code>, where <code class="docutils literal"><span class="pre">xcov.shape</span> <span class="pre">=</span>
<span class="pre">2*x.shape</span></code>; the result has the same shape as <code class="docutils literal"><span class="pre">x</span></code>. Returns a
<a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> if <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">xcov</span></code> are dictionaries, where the
keys in <code class="docutils literal"><span class="pre">xcov</span></code> are <code class="docutils literal"><span class="pre">(k1,k2)</span></code> for any keys <code class="docutils literal"><span class="pre">k1</span></code> and <code class="docutils literal"><span class="pre">k2</span></code>
in <code class="docutils literal"><span class="pre">x</span></code>. Returns a single <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> if <code class="docutils literal"><span class="pre">x</span></code> is a number and
<code class="docutils literal"><span class="pre">xcov</span></code> is a one-by-one matrix. The layout for <code class="docutils literal"><span class="pre">xcov</span></code> is
compatible with that produced by <a class="reference internal" href="#gvar.evalcov" title="gvar.evalcov"><code class="xref py py-func docutils literal"><span class="pre">gvar.evalcov()</span></code></a> for
a single <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or a dictionary whose
values are <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s and/or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. Therefore
<code class="docutils literal"><span class="pre">gvar.gvar(gvar.mean(g),</span> <span class="pre">gvar.evalcov(g))</span></code> creates <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
with the same means and covariance matrix as the <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
in <code class="docutils literal"><span class="pre">g</span></code> provided <code class="docutils literal"><span class="pre">g</span></code> is a single <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, or an array or
dictionary of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">gvar.</code><code class="descname">gvar</code><span class="sig-paren">(</span><em>(x</em>, <em>xsdev)</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> with mean <code class="docutils literal"><span class="pre">x</span></code> and standard deviation <code class="docutils literal"><span class="pre">xsdev</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">gvar.</code><code class="descname">gvar</code><span class="sig-paren">(</span><em>xstr</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> corresponding to string <code class="docutils literal"><span class="pre">xstr</span></code> which is
either of the form <code class="docutils literal"><span class="pre">&quot;xmean</span> <span class="pre">+-</span> <span class="pre">xsdev&quot;</span></code> or <code class="docutils literal"><span class="pre">&quot;x(xerr)&quot;</span></code> (see
<a class="reference internal" href="#gvar.GVar.fmt" title="gvar.GVar.fmt"><code class="xref py py-meth docutils literal"><span class="pre">GVar.fmt()</span></code></a>).</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">gvar.</code><code class="descname">gvar</code><span class="sig-paren">(</span><em>xgvar</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> <code class="docutils literal"><span class="pre">xgvar</span></code> unchanged.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">gvar.</code><code class="descname">gvar</code><span class="sig-paren">(</span><em>xdict</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a dictionary (<a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">BufferDict</span></code></a>) <code class="docutils literal"><span class="pre">b</span></code> where
<code class="docutils literal"><span class="pre">b[k]</span> <span class="pre">=</span> <span class="pre">gvar(xdict[k])</span></code> for every key in dictionary <code class="docutils literal"><span class="pre">xdict</span></code>.
The values in <code class="docutils literal"><span class="pre">xdict</span></code>, therefore, can be strings, tuples or
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (see above), or arrays of these.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">gvar.</code><code class="descname">gvar</code><span class="sig-paren">(</span><em>xarray</em><span class="sig-paren">)</span></dt>
<dd><p>Returns an array <code class="docutils literal"><span class="pre">a</span></code> having the same shape as <code class="docutils literal"><span class="pre">xarray</span></code> where
every element <code class="docutils literal"><span class="pre">a[i...]</span> <span class="pre">=</span> <span class="pre">gvar(xarray[i...])</span></code>. The values in
<code class="docutils literal"><span class="pre">xarray</span></code>, therefore, can be strings, tuples or <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (see
above).</p>
</dd></dl>

<p><code class="docutils literal"><span class="pre">gvar.gvar</span></code> is actually an object of type <code class="xref py py-class docutils literal"><span class="pre">gvar.GVarFactory</span></code>.</p>
</dd></dl>

<p>The following function is useful for constructing new functions that
can accept <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s as arguments:</p>
<dl class="function">
<dt id="gvar.gvar_function">
<code class="descclassname">gvar.</code><code class="descname">gvar_function</code><span class="sig-paren">(</span><em>x</em>, <em>f</em>, <em>dfdx</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.gvar_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> for function f(x) given f and df/dx at x.</p>
<p>This function creates a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> corresponding to a function of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s <code class="docutils literal"><span class="pre">x</span></code>
whose value is <code class="docutils literal"><span class="pre">f</span></code> and whose derivatives with respect to each
<code class="docutils literal"><span class="pre">x</span></code> are given by <code class="docutils literal"><span class="pre">dfdx</span></code>. Here <code class="docutils literal"><span class="pre">x</span></code> can be a single <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>,
an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (for a multidimensional function), or
a dictionary whose values are <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, while
<code class="docutils literal"><span class="pre">dfdx</span></code> must be a float, an array of floats, or a dictionary
whose values are floats or arrays of floats, respectively.</p>
<p>This function is useful for creating functions that can accept
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s as arguments. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>

<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gv</span><span class="o">.</span><span class="n">GVar</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
        <span class="n">dfdx</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dfdx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>creates a version of <code class="docutils literal"><span class="pre">sin(x)</span></code> that works with either floats or
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s as its argument. This particular function is unnecessary since
it is already provided by <a class="reference internal" href="#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or a dictionary of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s) &#8211; Point at which the function is evaluated.</li>
<li><strong>f</strong> (<em>float</em>) &#8211; Value of function at point <code class="docutils literal"><span class="pre">gvar.mean(x)</span></code>.</li>
<li><strong>dfdx</strong> (<em>float, array of floats, or a dictionary of floats</em>) &#8211; Derivatives of function with respect to x at
point <code class="docutils literal"><span class="pre">gvar.mean(x)</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> representing the function&#8217;s value at <code class="docutils literal"><span class="pre">x</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Means, standard deviations, variances, formatted strings, covariance
matrices and correlation/comparison information can be extracted from arrays
(or dictionaries) of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s using:</p>
<dl class="function">
<dt id="gvar.mean">
<code class="descclassname">gvar.</code><code class="descname">mean</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract means from <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p><code class="docutils literal"><span class="pre">g</span></code> can be a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or a dictionary containing
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. Result has the same layout as <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p>Elements of <code class="docutils literal"><span class="pre">g</span></code> that are not <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are left unchanged.</p>
</dd></dl>

<dl class="function">
<dt id="gvar.sdev">
<code class="descclassname">gvar.</code><code class="descname">sdev</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.sdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract standard deviations from <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p><code class="docutils literal"><span class="pre">g</span></code> can be a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or a dictionary containing
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. Result has the same layout as <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p>The deviation is set to 0.0 for elements of <code class="docutils literal"><span class="pre">g</span></code> that are not <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</p>
</dd></dl>

<dl class="function">
<dt id="gvar.var">
<code class="descclassname">gvar.</code><code class="descname">var</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract variances from <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p><code class="docutils literal"><span class="pre">g</span></code> can be a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or a dictionary containing
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. Result has the same layout as <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p>The variance is set to 0.0 for elements of <code class="docutils literal"><span class="pre">g</span></code> that are not <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</p>
</dd></dl>

<dl class="function">
<dt id="gvar.fmt">
<code class="descclassname">gvar.</code><code class="descname">fmt</code><span class="sig-paren">(</span><em>g</em>, <em>ndecimal=None</em>, <em>sep=''</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.fmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Format <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p><code class="docutils literal"><span class="pre">g</span></code> can be a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or a dictionary containing
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. Each <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> <code class="docutils literal"><span class="pre">gi</span></code> in <code class="docutils literal"><span class="pre">g</span></code> is replaced
by the string generated by <code class="docutils literal"><span class="pre">gi.fmt(ndecimal,sep)</span></code>. Result has same
structure as <code class="docutils literal"><span class="pre">g</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="gvar.evalcov">
<code class="descclassname">gvar.</code><code class="descname">evalcov</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.evalcov" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute covariance matrix for elements of
array/dictionary <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">g</span></code> is an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, <code class="docutils literal"><span class="pre">evalcov</span></code> returns the
covariance matrix as an array with shape <code class="docutils literal"><span class="pre">g.shape+g.shape</span></code>.
If <code class="docutils literal"><span class="pre">g</span></code> is a dictionary whose values are <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, the result is a doubly-indexed dictionary where
<code class="docutils literal"><span class="pre">cov[k1,k2]</span></code> is the covariance for <code class="docutils literal"><span class="pre">g[k1].flat</span></code> and <code class="docutils literal"><span class="pre">g[k2].flat</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="gvar.evalcorr">
<code class="descclassname">gvar.</code><code class="descname">evalcorr</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.evalcorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute correlation matrix for elements of
array/dictionary <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">g</span></code> is an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, <code class="docutils literal"><span class="pre">evalcorr</span></code> returns the
correlation matrix as an array with shape <code class="docutils literal"><span class="pre">g.shape+g.shape</span></code>.
If <code class="docutils literal"><span class="pre">g</span></code> is a dictionary whose values are <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, the result is a doubly-indexed dictionary where
<code class="docutils literal"><span class="pre">corr[k1,k2]</span></code> is the correlation for <code class="docutils literal"><span class="pre">g[k1]</span></code> and <code class="docutils literal"><span class="pre">g[k2]</span></code>.</p>
<p>The correlation matrix is related to the covariance matrix by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">corr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">cov</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="o">**</span> <span class="mf">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="gvar.uncorrelated">
<code class="descclassname">gvar.</code><code class="descname">uncorrelated</code><span class="sig-paren">(</span><em>g1</em>, <em>g2</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.uncorrelated" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in <code class="docutils literal"><span class="pre">g1</span></code> uncorrelated with those in <code class="docutils literal"><span class="pre">g2</span></code>.</p>
<p><code class="docutils literal"><span class="pre">g1</span></code> and <code class="docutils literal"><span class="pre">g2</span></code> can be <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or dictionaries
containing <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. Returns <code class="docutils literal"><span class="pre">True</span></code> if either
of <code class="docutils literal"><span class="pre">g1</span></code> or <code class="docutils literal"><span class="pre">g2</span></code> is <code class="docutils literal"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="gvar.chi2">
<code class="descclassname">gvar.</code><code class="descname">chi2</code><span class="sig-paren">(</span><em>g1</em>, <em>g2</em>, <em>svdcut=1e-15</em>, <em>fmt=False</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute chi**2 of <code class="docutils literal"><span class="pre">g1-g2</span></code>.</p>
<p><code class="docutils literal"><span class="pre">chi**2</span></code> is a measure of whether the multi-dimensional
Gaussian distributions <code class="docutils literal"><span class="pre">g1</span></code> and <code class="docutils literal"><span class="pre">g2</span></code> (dictionaries or arrays)
agree with each other &#8212; that is, do their means agree
within errors for corresponding elements. The probability is high
if <code class="docutils literal"><span class="pre">chi2(g1,g2)/chi2.dof</span></code> is of order 1 or smaller.</p>
<p>Usually <code class="docutils literal"><span class="pre">g1</span></code> and <code class="docutils literal"><span class="pre">g2</span></code> are dictionaries with the same keys,
where <code class="docutils literal"><span class="pre">g1[k]</span></code> and <code class="docutils literal"><span class="pre">g2[k]</span></code> are <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s having the same shape. Alternatively <code class="docutils literal"><span class="pre">g1</span></code> and <code class="docutils literal"><span class="pre">g2</span></code>
can be <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s having the same shape.</p>
<p>One of <code class="docutils literal"><span class="pre">g1</span></code> or <code class="docutils literal"><span class="pre">g2</span></code> can contain numbers instead of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s,
in which case <code class="docutils literal"><span class="pre">chi**2</span></code> is a measure of the likelihood that
the numbers came from the distribution specified by the other
argument.</p>
<p>One or the other of <code class="docutils literal"><span class="pre">g1</span></code> or <code class="docutils literal"><span class="pre">g2</span></code> can be missing keys, or missing
elements from arrays. Only the parts of <code class="docutils literal"><span class="pre">g1</span></code> and <code class="docutils literal"><span class="pre">g2</span></code> that
overlap are used. Also setting <code class="docutils literal"><span class="pre">g2=None</span></code> is equivalent to replacing its
elements by zeros.</p>
<p><code class="docutils literal"><span class="pre">chi**2</span></code> is computed from the inverse of the covariance matrix
of <code class="docutils literal"><span class="pre">g1-g2</span></code>. The matrix inversion can be sensitive to roundoff
errors. In such cases, SVD cuts can be applied by setting
parameters <code class="docutils literal"><span class="pre">svdcut</span></code>; see the documentation
for <a class="reference internal" href="#gvar.svd" title="gvar.svd"><code class="xref py py-func docutils literal"><span class="pre">gvar.svd()</span></code></a>, which is used to apply the cut.</p>
<p>The return value is the <code class="docutils literal"><span class="pre">chi**2</span></code>. Extra data is stored in
<code class="docutils literal"><span class="pre">chi2</span></code> itself:</p>
<dl class="attribute">
<dt id="gvar.chi2.dof">
<code class="descclassname">chi2.</code><code class="descname">dof</code><a class="headerlink" href="#gvar.chi2.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of degrees of freedom (that is, the number of variables
compared).</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.chi2.Q">
<code class="descclassname">chi2.</code><code class="descname">Q</code><a class="headerlink" href="#gvar.chi2.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>The probability that the <code class="docutils literal"><span class="pre">chi**2</span></code> could have been larger,
by chance, even if <code class="docutils literal"><span class="pre">g1</span></code> and <code class="docutils literal"><span class="pre">g2</span></code> agree.
Values smaller than 0.1 or so suggest that they do not
agree. Also called the <em>p-value</em>.</p>
</dd></dl>

<p>If argument <code class="docutils literal"><span class="pre">fmt==True</span></code>, then a string is returned containing the
<code class="docutils literal"><span class="pre">chi**2</span></code> per degree of freedom, the number of degrees of freedom, and
<code class="docutils literal"><span class="pre">Q</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="gvar.fmt_chi2">
<code class="descclassname">gvar.</code><code class="descname">fmt_chi2</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.fmt_chi2" title="Permalink to this definition">¶</a></dt>
<dd><p>Return string containing <code class="docutils literal"><span class="pre">chi**2/dof</span></code>, <code class="docutils literal"><span class="pre">dof</span></code> and <code class="docutils literal"><span class="pre">Q</span></code> from <code class="docutils literal"><span class="pre">f</span></code>.</p>
<p>Assumes <code class="docutils literal"><span class="pre">f</span></code> has attributes <code class="docutils literal"><span class="pre">chi2</span></code>, <code class="docutils literal"><span class="pre">dof</span></code> and <code class="docutils literal"><span class="pre">Q</span></code>. The
logarithm of the Bayes factor will also be printed if <code class="docutils literal"><span class="pre">f</span></code> has
attribute <code class="docutils literal"><span class="pre">logGBF</span></code>.</p>
</dd></dl>

<p><a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s can be stored (pickled) and retrieved from files (or strings) using:</p>
<dl class="function">
<dt id="gvar.dump">
<code class="descclassname">gvar.</code><code class="descname">dump</code><span class="sig-paren">(</span><em>g</em>, <em>outputfile</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>pickle a collection <code class="docutils literal"><span class="pre">g</span></code> of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in file <code class="docutils literal"><span class="pre">outputfile</span></code>.</p>
<p>The <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are recovered using <a class="reference internal" href="#gvar.load" title="gvar.load"><code class="xref py py-func docutils literal"><span class="pre">gvar.load()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>g</strong> &#8211; A <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or dictionary whose values
are <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s and/or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</li>
<li><strong>outputfile</strong> (<em>string or file-like object</em>) &#8211; The name of a file or a file object in which the
pickled <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are stored.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gvar.dumps">
<code class="descclassname">gvar.</code><code class="descname">dumps</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>pickle a collection <code class="docutils literal"><span class="pre">g</span></code> of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s and return as a string.</p>
<p>The <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are recovered using <a class="reference internal" href="#gvar.loads" title="gvar.loads"><code class="xref py py-func docutils literal"><span class="pre">gvar.loads()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>g</strong> &#8211; A <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or dictionary whose values
are <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s and/or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gvar.load">
<code class="descclassname">gvar.</code><code class="descname">load</code><span class="sig-paren">(</span><em>inputfile</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load and return pickled <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s from file <code class="docutils literal"><span class="pre">inputfile</span></code>.</p>
<p>This function recovers <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s pickled with <a class="reference internal" href="#gvar.dump" title="gvar.dump"><code class="xref py py-func docutils literal"><span class="pre">gvar.dump()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputfile</strong> (<em>string or file-like object</em>) &#8211; The name of the file or a file object in which the
pickled <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are stored.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The reconstructed <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, or array or dictionary of
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gvar.loads">
<code class="descclassname">gvar.</code><code class="descname">loads</code><span class="sig-paren">(</span><em>inputstring</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>Load and return pickled <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s from string <code class="docutils literal"><span class="pre">inputstring</span></code>.</p>
<p>This function recovers <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s pickled with <a class="reference internal" href="#gvar.dumps" title="gvar.dumps"><code class="xref py py-func docutils literal"><span class="pre">gvar.dumps()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>inputstring</strong> &#8211; A string containing <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s pickled using
<a class="reference internal" href="#gvar.dumps" title="gvar.dumps"><code class="xref py py-func docutils literal"><span class="pre">gvar.dumps()</span></code></a>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The reconstructed <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, or array or dictionary of
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p><a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s contain information about derivatives with respect to the <em>independent</em>
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s from which they were constructed. This information can be extracted using:</p>
<dl class="function">
<dt id="gvar.deriv">
<code class="descclassname">gvar.</code><code class="descname">deriv</code><span class="sig-paren">(</span><em>g</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute first derivatives wrt <code class="docutils literal"><span class="pre">x</span></code> of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p><code class="docutils literal"><span class="pre">g</span></code> can be a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or a dictionary containing
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. Result has the same layout as <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p><code class="docutils literal"><span class="pre">x</span></code> must be an <em>primary</em> <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, which is a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> created by a
call to <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a> (<em>e.g.</em>, <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">gvar.gvar(xmean,</span> <span class="pre">xsdev)</span></code>) or a
function <code class="docutils literal"><span class="pre">f(x)</span></code> of such a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>. (More precisely, <code class="docutils literal"><span class="pre">x.der</span></code> must have
only one nonzero entry.)</p>
</dd></dl>

<p>The following function creates an iterator that generates random arrays
from the distribution defined by array (or dictionary) <code class="docutils literal"><span class="pre">g</span></code> of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.
The random numbers incorporate any correlations implied by the <code class="docutils literal"><span class="pre">g</span></code>s.</p>
<dl class="function">
<dt id="gvar.raniter">
<code class="descclassname">gvar.</code><code class="descname">raniter</code><span class="sig-paren">(</span><em>g</em>, <em>n=None</em>, <em>svdcut=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.raniter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return iterator for random samples from distribution <code class="docutils literal"><span class="pre">g</span></code></p>
<p>The gaussian variables (<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> objects) in array (or dictionary) <code class="docutils literal"><span class="pre">g</span></code>
collectively define a multidimensional gaussian distribution. The
iterator defined by <a class="reference internal" href="#gvar.raniter" title="gvar.raniter"><code class="xref py py-func docutils literal"><span class="pre">raniter()</span></code></a> generates an array (or dictionary)
containing random numbers drawn from that distribution, with
correlations intact.</p>
<p>The layout for the result is the same as for <code class="docutils literal"><span class="pre">g</span></code>. So an array of the
same shape is returned if <code class="docutils literal"><span class="pre">g</span></code> is an array. When <code class="docutils literal"><span class="pre">g</span></code> is a dictionary,
individual entries <code class="docutils literal"><span class="pre">g[k]</span></code> may be <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s,
with arbitrary shapes.</p>
<p><a class="reference internal" href="#gvar.raniter" title="gvar.raniter"><code class="xref py py-func docutils literal"><span class="pre">raniter()</span></code></a> also works when <code class="docutils literal"><span class="pre">g</span></code> is a single <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, in which case
the resulting iterator returns random numbers drawn from the
distribution specified by <code class="docutils literal"><span class="pre">g</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>g</strong> (<em>array or dictionary or BufferDict or GVar</em>) &#8211; An array (or dictionary) of objects of type <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>; or a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>.</li>
<li><strong>n</strong> &#8211; Maximum number of random iterations. Setting <code class="docutils literal"><span class="pre">n=None</span></code>
(the default) implies there is no maximum number.</li>
<li><strong>svdcut</strong> (<code class="docutils literal"><span class="pre">None</span></code> or number) &#8211; If positive, replace eigenvalues <code class="docutils literal"><span class="pre">eig</span></code> of <code class="docutils literal"><span class="pre">g</span></code>&#8216;s
correlation matrix with <code class="docutils literal"><span class="pre">max(eig,</span> <span class="pre">svdcut</span> <span class="pre">*</span> <span class="pre">max_eig)</span></code> where
<code class="docutils literal"><span class="pre">max_eig</span></code> is the largest eigenvalue; if negative,
discard eigenmodes with eigenvalues smaller
than <code class="docutils literal"><span class="pre">|svdcut|</span> <span class="pre">*</span> <span class="pre">max_eig</span></code>. Default is <code class="docutils literal"><span class="pre">None</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator that returns random arrays or dictionaries
with the same shape as <code class="docutils literal"><span class="pre">g</span></code> drawn from the gaussian distribution
defined by <code class="docutils literal"><span class="pre">g</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gvar.bootstrap_iter">
<code class="descclassname">gvar.</code><code class="descname">bootstrap_iter</code><span class="sig-paren">(</span><em>g</em>, <em>n=None</em>, <em>svdcut=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.bootstrap_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return iterator for bootstrap copies of <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p>The gaussian variables (<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> objects) in array (or dictionary) <code class="docutils literal"><span class="pre">g</span></code>
collectively define a multidimensional gaussian distribution. The
iterator created by <a class="reference internal" href="#gvar.bootstrap_iter" title="gvar.bootstrap_iter"><code class="xref py py-func docutils literal"><span class="pre">bootstrap_iter()</span></code></a> generates an array (or
dictionary) of new <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s whose covariance matrix is the same as
<code class="docutils literal"><span class="pre">g</span></code>&#8216;s but whose means are drawn at random from the original <code class="docutils literal"><span class="pre">g</span></code>
distribution. This is a <em>bootstrap copy</em> of the original distribution.
Each iteration of the iterator has different means (but the same
covariance matrix).</p>
<p><a class="reference internal" href="#gvar.bootstrap_iter" title="gvar.bootstrap_iter"><code class="xref py py-func docutils literal"><span class="pre">bootstrap_iter()</span></code></a> also works when <code class="docutils literal"><span class="pre">g</span></code> is a single <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>, in
which case the resulting iterator returns bootstrap copies of the
<code class="docutils literal"><span class="pre">g</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>g</strong> (<em>array or dictionary or BufferDict</em>) &#8211; An array (or dictionary) of objects of type <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>.</li>
<li><strong>n</strong> &#8211; Maximum number of random iterations. Setting <code class="docutils literal"><span class="pre">n=None</span></code>
(the default) implies there is no maximum number.</li>
<li><strong>svdcut</strong> (<code class="docutils literal"><span class="pre">None</span></code> or number) &#8211; If positive, replace eigenvalues <code class="docutils literal"><span class="pre">eig</span></code> of <code class="docutils literal"><span class="pre">g</span></code>&#8216;s
correlation matrix with <code class="docutils literal"><span class="pre">max(eig,</span> <span class="pre">svdcut</span> <span class="pre">*</span> <span class="pre">max_eig)</span></code> where
<code class="docutils literal"><span class="pre">max_eig</span></code> is the largest eigenvalue; if negative,
discard eigenmodes with eigenvalues smaller
than <code class="docutils literal"><span class="pre">|svdcut|</span> <span class="pre">*</span> <span class="pre">max_eig</span></code>. Default is <code class="docutils literal"><span class="pre">None</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator that returns bootstrap copies of <code class="docutils literal"><span class="pre">g</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gvar.ranseed">
<code class="descclassname">gvar.</code><code class="descname">ranseed</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.ranseed" title="Permalink to this definition">¶</a></dt>
<dd><p>Seed random number generators with tuple <code class="docutils literal"><span class="pre">seed</span></code>.</p>
<p>Argument <code class="docutils literal"><span class="pre">seed</span></code> is a <code class="xref py py-class docutils literal"><span class="pre">tuple</span></code> of integers that is used to seed
the random number generators used by <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> and
<code class="xref py py-mod docutils literal"><span class="pre">random</span></code> (and therefore by <a class="reference internal" href="#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code></a>). Reusing
the same <code class="docutils literal"><span class="pre">seed</span></code> results in the same set of random numbers.</p>
<p><code class="docutils literal"><span class="pre">ranseed</span></code> generates its own seed when called without an argument
or with <code class="docutils literal"><span class="pre">seed=None</span></code>. This seed is stored in <code class="docutils literal"><span class="pre">ranseed.seed</span></code> and
also returned by the function. The seed can be used to regenerate
the same set of random numbers at a later time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>seed</strong> (<em>tuple or None</em>) &#8211; A tuple of integers. Generates a random tuple if <code class="docutils literal"><span class="pre">None</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The seed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The following two functions that are useful for tabulating results
and for analyzing where the errors in a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> constructed from
other <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s come from:</p>
<dl class="function">
<dt id="gvar.fmt_errorbudget">
<code class="descclassname">gvar.</code><code class="descname">fmt_errorbudget</code><span class="sig-paren">(</span><em>outputs</em>, <em>inputs</em>, <em>ndecimal=2</em>, <em>percent=True</em>, <em>verify=False</em>, <em>colwidth=10</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.fmt_errorbudget" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulate error budget for <code class="docutils literal"><span class="pre">outputs[ko]</span></code> due to <code class="docutils literal"><span class="pre">inputs[ki]</span></code>.</p>
<p>For each output <code class="docutils literal"><span class="pre">outputs[ko]</span></code>, <code class="docutils literal"><span class="pre">fmt_errorbudget</span></code> computes the
contributions to <code class="docutils literal"><span class="pre">outputs[ko]</span></code>&#8216;s standard deviation coming from the
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s collected in <code class="docutils literal"><span class="pre">inputs[ki]</span></code>. This is done for each key
combination <code class="docutils literal"><span class="pre">(ko,ki)</span></code> and the results are tabulated with columns and
rows labeled by <code class="docutils literal"><span class="pre">ko</span></code> and <code class="docutils literal"><span class="pre">ki</span></code>, respectively. If a <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> in
<code class="docutils literal"><span class="pre">inputs[ki]</span></code> is correlated with other <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, the contribution from
the others is included in the <code class="docutils literal"><span class="pre">ki</span></code> contribution as well (since
contributions from correlated <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s cannot be distinguished). The table
is returned as a string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>outputs</strong> &#8211; Dictionary of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s for which an error budget
is computed.</li>
<li><strong>inputs</strong> &#8211; Dictionary of: <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, arrays/dictionaries of
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or lists of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s and/or arrays/dictionaries of
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. <code class="docutils literal"><span class="pre">fmt_errorbudget</span></code> tabulates the parts of the standard
deviations of each <code class="docutils literal"><span class="pre">outputs[ko]</span></code> due to each <code class="docutils literal"><span class="pre">inputs[ki]</span></code>.</li>
<li><strong>ndecimal</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; Number of decimal places displayed in table.</li>
<li><strong>percent</strong> (<em>boolean</em>) &#8211; Tabulate % errors if <code class="docutils literal"><span class="pre">percent</span> <span class="pre">is</span> <span class="pre">True</span></code>; otherwise
tabulate the errors themselves.</li>
<li><strong>colwidth</strong> (<em>positive integer</em>) &#8211; Width of each column.</li>
<li><strong>verify</strong> (<em>boolean</em>) &#8211; If <code class="docutils literal"><span class="pre">True</span></code>, a warning is issued if: 1) different inputs are
correlated (and therefore double count errors); or
2) the sum (in quadrature) of partial errors is not equal to the
total error to within 0.1% of the error (and the error budget is incomplete or
overcomplete). No checking is done if <code class="docutils literal"><span class="pre">verify==False</span></code> (default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A table (<code class="docutils literal"><span class="pre">str</span></code>) containing the error budget.
Output variables are labeled by the keys in <code class="docutils literal"><span class="pre">outputs</span></code>
(columns); sources of uncertainty are labeled by the keys in
<code class="docutils literal"><span class="pre">inputs</span></code> (rows).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gvar.fmt_values">
<code class="descclassname">gvar.</code><code class="descname">fmt_values</code><span class="sig-paren">(</span><em>outputs</em>, <em>ndecimal=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.fmt_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulate <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in <code class="docutils literal"><span class="pre">outputs</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>outputs</strong> &#8211; A dictionary of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> objects.</li>
<li><strong>ndecimal</strong> (<code class="docutils literal"><span class="pre">int</span></code> or <code class="docutils literal"><span class="pre">None</span></code>) &#8211; Format values <code class="docutils literal"><span class="pre">v</span></code> using <code class="docutils literal"><span class="pre">v.fmt(ndecimal)</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A table (<code class="docutils literal"><span class="pre">str</span></code>) containing values and standard
deviations for variables in <code class="docutils literal"><span class="pre">outputs</span></code>, labeled by the keys
in <code class="docutils literal"><span class="pre">outputs</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The following function applies an SVD cut to the correlation matrix
of a set of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s:</p>
<dl class="function">
<dt id="gvar.svd">
<code class="descclassname">gvar.</code><code class="descname">svd</code><span class="sig-paren">(</span><em>g</em>, <em>svdcut=1e-15</em>, <em>wgts=False</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply svd cuts to collection of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p>Standard usage is, for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">svdcut</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">gmod</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">svdcut</span><span class="o">=</span><span class="n">svdcut</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">g</span></code> is an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or a dictionary containing <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
and/or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. When <code class="docutils literal"><span class="pre">svdcut&gt;0</span></code>, <code class="docutils literal"><span class="pre">gmod</span></code> is
a copy of <code class="docutils literal"><span class="pre">g</span></code> whose <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s have been modified to make
their correlation matrix less singular than that of the
original <code class="docutils literal"><span class="pre">g</span></code>: each eigenvalue <code class="docutils literal"><span class="pre">eig</span></code> of the correlation matrix is
replaced by <code class="docutils literal"><span class="pre">max(eig,</span> <span class="pre">svdcut</span> <span class="pre">*</span> <span class="pre">max_eig)</span></code> where <code class="docutils literal"><span class="pre">max_eig</span></code> is
the largest eigenvalue. This SVD cut, which is applied separately
to each block-diagonal sub-matrix of the correlation matrix,
increases the variance of the eigenmodes with eigenvalues smaller
than <code class="docutils literal"><span class="pre">svdcut</span> <span class="pre">*</span> <span class="pre">max_eig</span></code>.</p>
<p>When <code class="docutils literal"><span class="pre">svdcut</span></code> is negative, eigenmodes of the correlation matrix
whose eigenvalues are smaller than <code class="docutils literal"><span class="pre">|svdcut|</span> <span class="pre">*</span> <span class="pre">max_eig</span></code> are dropped
from the new matrix and the corresponding components of <code class="docutils literal"><span class="pre">g</span></code> are
zeroed out (that is, replaced by 0(0)) in <code class="docutils literal"><span class="pre">gmod</span></code>.</p>
<p>There is an additional parameter <code class="docutils literal"><span class="pre">wgts</span></code> in <a class="reference internal" href="#gvar.svd" title="gvar.svd"><code class="xref py py-func docutils literal"><span class="pre">gvar.svd()</span></code></a> whose
default value is <code class="docutils literal"><span class="pre">False</span></code>. Setting <code class="docutils literal"><span class="pre">wgts=1</span></code> or <code class="docutils literal"><span class="pre">wgts=-1</span></code> instead
causes <a class="reference internal" href="#gvar.svd" title="gvar.svd"><code class="xref py py-func docutils literal"><span class="pre">gvar.svd()</span></code></a> to return a tuple <code class="docutils literal"><span class="pre">(gmod,</span> <span class="pre">i_wgts)</span></code> where
<code class="docutils literal"><span class="pre">gmod</span></code>  is the modified copy of <code class="docutils literal"><span class="pre">g</span></code>, and <code class="docutils literal"><span class="pre">i_wgts</span></code> contains a
spectral  decomposition of the covariance matrix corresponding to
the  modified correlation matrix if <code class="docutils literal"><span class="pre">wgts=1</span></code>, or a decomposition of its
inverse if <code class="docutils literal"><span class="pre">wgts=-1</span></code>. The first entry <code class="docutils literal"><span class="pre">i,</span> <span class="pre">wgts</span> <span class="pre">=</span> <span class="pre">i_wgts[0]</span></code>  specifies
the diagonal part of the matrix: <code class="docutils literal"><span class="pre">i</span></code> is a list of the indices in
<code class="docutils literal"><span class="pre">gmod.flat</span></code> corresponding to diagonal elements, and <code class="docutils literal"><span class="pre">wgts</span> <span class="pre">**</span> <span class="pre">2</span></code>
gives the corresponding matrix elements. The second and subsequent
entries, <code class="docutils literal"><span class="pre">i,</span> <span class="pre">wgts</span> <span class="pre">=</span> <span class="pre">i_wgts[n]</span></code> for <code class="docutils literal"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, each correspond
to block-diagonal sub-matrices, where <code class="docutils literal"><span class="pre">i</span></code> is the list of
indices corresponding to the block, and <code class="docutils literal"><span class="pre">wgts[j]</span></code> are eigenvectors of
the sub-matrix rescaled so that</p>
<div class="highlight-python"><div class="highlight"><pre>numpy.sum(numpy.outer(wi, wi) for wi in wgts[j]
</pre></div>
</div>
<p>is the sub-matrix (<code class="docutils literal"><span class="pre">wgts=1</span></code>) or its inverse (<code class="docutils literal"><span class="pre">wgts=-1</span></code>).</p>
<p>To compute the inverse of the covariance matrix from <code class="docutils literal"><span class="pre">i_wgts</span></code>,
for example, one could use code like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gmod</span><span class="p">,</span> <span class="n">i_wgts</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">svdcut</span><span class="o">=</span><span class="n">svdcut</span><span class="p">,</span> <span class="n">wgts</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">inv_cov</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
<span class="n">i</span><span class="p">,</span> <span class="n">wgts</span> <span class="o">=</span> <span class="n">i_wgts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                       <span class="c"># 1x1 sub-matrices</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">inv_cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wgts</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wgts</span> <span class="ow">in</span> <span class="n">i_wgts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>                <span class="c"># nxn sub-matrices (n&gt;1)</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wgts</span><span class="p">:</span>
        <span class="n">inv_cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>This sets <code class="docutils literal"><span class="pre">inv_cov</span></code> equal to the inverse of the covariance matrix of
the <code class="docutils literal"><span class="pre">gmod</span></code>s. Similarly, we can  compute the expectation value,
<code class="docutils literal"><span class="pre">u.dot(inv_cov.dot(v))</span></code>, between two vectors (<code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> arrays) using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">i</span><span class="p">,</span> <span class="n">wgts</span> <span class="o">=</span> <span class="n">i_wgts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                       <span class="c"># 1x1 sub-matrices</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">wgts</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">wgts</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wgts</span> <span class="ow">in</span> <span class="n">i_wgts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>                <span class="c"># nxn sub-matrices (n&gt;1)</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wgts</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">wgts</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">result</span></code> is the desired expectation value.</p>
<p>The input parameters are :</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>g</strong> &#8211; An array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or a dicitionary whose values are
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s and/or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</li>
<li><strong>svdcut</strong> (<code class="docutils literal"><span class="pre">None</span></code> or number <code class="docutils literal"><span class="pre">(|svdcut|&lt;=1)</span></code>.) &#8211; If positive, replace eigenvalues <code class="docutils literal"><span class="pre">eig</span></code> of the correlation
matrix with <code class="docutils literal"><span class="pre">max(eig,</span> <span class="pre">svdcut</span> <span class="pre">*</span> <span class="pre">max_eig)</span></code> where <code class="docutils literal"><span class="pre">max_eig</span></code> is
the largest eigenvalue; if negative,
discard eigenmodes with eigenvalues smaller
than <code class="docutils literal"><span class="pre">|svdcut|</span> <span class="pre">*</span> <span class="pre">max_eig</span></code>. Default is 1e-15.</li>
<li><strong>wgts</strong> &#8211; Setting <code class="docutils literal"><span class="pre">wgts=1</span></code> causes <a class="reference internal" href="#gvar.svd" title="gvar.svd"><code class="xref py py-func docutils literal"><span class="pre">gvar.svd()</span></code></a> to compute
and return a spectral decomposition of the covariance matrix of
the modified <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, <code class="docutils literal"><span class="pre">gmod</span></code>. Setting <code class="docutils literal"><span class="pre">wgts=-1</span></code> results in
a decomposition of the inverse of the covariance matrix. The
default value is <code class="docutils literal"><span class="pre">False</span></code>, in which case only <code class="docutils literal"><span class="pre">gmod</span></code> is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A copy <code class="docutils literal"><span class="pre">gmod</span></code> of <code class="docutils literal"><span class="pre">g</span></code> whose correlation matrix is modified by
<em>svd</em> cuts. If <code class="docutils literal"><span class="pre">wgts</span></code> is not <code class="docutils literal"><span class="pre">False</span></code>,
a tuple <code class="docutils literal"><span class="pre">(g,</span> <span class="pre">i_wgts)</span></code> is returned where <code class="docutils literal"><span class="pre">i_wgts</span></code>
contains a spectral decomposition of <code class="docutils literal"><span class="pre">gmod</span></code>&#8216;s
covariance matrix or its inverse.</p>
</td>
</tr>
</tbody>
</table>
<p>Data from the <em>svd</em> analysis of <code class="docutils literal"><span class="pre">g</span></code>&#8216;s covariance matrix is stored in
<code class="docutils literal"><span class="pre">svd</span></code> itself:</p>
<dl class="attribute">
<dt id="gvar.svd.dof">
<code class="descclassname">svd.</code><code class="descname">dof</code><a class="headerlink" href="#gvar.svd.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of independent degrees of freedom left after the
<em>svd</em> cut. This is the same as the number initially unless
<code class="docutils literal"><span class="pre">svdcut</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> in which case it may be smaller.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.svd.nmod">
<code class="descclassname">svd.</code><code class="descname">nmod</code><a class="headerlink" href="#gvar.svd.nmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of modes whose eignevalue was modified by the
<em>svd</em> cut.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.svd.nblocks">
<code class="descclassname">svd.</code><code class="descname">nblocks</code><a class="headerlink" href="#gvar.svd.nblocks" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary where <code class="docutils literal"><span class="pre">svd.nblocks[s]</span></code> contains the number of
block-diagonal <code class="docutils literal"><span class="pre">s</span></code>-by-<code class="docutils literal"><span class="pre">s</span></code> sub-matrices in the correlation
matrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.svd.eigen_range">
<code class="descclassname">svd.</code><code class="descname">eigen_range</code><a class="headerlink" href="#gvar.svd.eigen_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Ratio of the smallest to largest eigenvalue before <em>svd</em> cuts are
applied (but after rescaling).</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.svd.logdet">
<code class="descclassname">svd.</code><code class="descname">logdet</code><a class="headerlink" href="#gvar.svd.logdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithm of the determinant of the covariance matrix after <em>svd</em>
cuts are applied (excluding any omitted modes when
<code class="docutils literal"><span class="pre">svdcut</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>).</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.svd.correction">
<code class="descclassname">svd.</code><code class="descname">correction</code><a class="headerlink" href="#gvar.svd.correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Array containing the <em>svd</em> corrections that were added to <code class="docutils literal"><span class="pre">g.flat</span></code>
to create the modified <code class="docutils literal"><span class="pre">g</span></code>s.</p>
</dd></dl>

</dd></dl>

<p>This function is useful when the correlation matrix is singular
or almost singular, and its inverse is needed (as in curve fitting).</p>
<p>The following function can be used to rebuild collections of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s,
ignoring all correlations with other variables. It can also be used to
introduce correlations between uncorrelated variables.</p>
<dl class="function">
<dt id="gvar.rebuild">
<code class="descclassname">gvar.</code><code class="descname">rebuild</code><span class="sig-paren">(</span><em>g</em>, <em>gvar=gvar</em>, <em>corr=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.rebuild" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebuild <code class="docutils literal"><span class="pre">g</span></code> stripping correlations with variables not in <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p><code class="docutils literal"><span class="pre">g</span></code> is either an array of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s or a dictionary containing
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s and/or arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s. <code class="docutils literal"><span class="pre">rebuild(g)</span></code> creates a new
collection <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s with the same layout, means and covariance matrix
as those in <code class="docutils literal"><span class="pre">g</span></code>, but discarding all correlations with variables not
in <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">corr</span></code> is nonzero, <code class="docutils literal"><span class="pre">rebuild</span></code> will introduce correlations
wherever there aren&#8217;t any using</p>
<div class="highlight-python"><div class="highlight"><pre>cov[i,j] -&gt; corr * sqrt(cov[i,i]*cov[j,j])
</pre></div>
</div>
<p>wherever <code class="docutils literal"><span class="pre">cov[i,j]==0.0</span></code> initially. Positive values for <code class="docutils literal"><span class="pre">corr</span></code>
introduce positive correlations, negative values anti-correlations.</p>
<p>Parameter <code class="docutils literal"><span class="pre">gvar</span></code> specifies a function for creating new <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s that
replaces <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a> (the default).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>g</strong> (<em>array or dictionary</em>) &#8211; <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s to be rebuilt.</li>
<li><strong>gvar</strong> (<code class="xref py py-class docutils literal"><span class="pre">gvar.GVarFactory</span></code> or <code class="docutils literal"><span class="pre">None</span></code>) &#8211; Replacement for <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a> to use in rebuilding.
Default is <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>.</li>
<li><strong>corr</strong> (<em>number</em>) &#8211; Size of correlations to introduce where none exist
initially.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Array or dictionary (gvar.BufferDict) of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s  (same
layout as <code class="docutils literal"><span class="pre">g</span></code>) where all correlations with variables other than
those in <code class="docutils literal"><span class="pre">g</span></code> are erased.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The following functions creates new functions that generate <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (to
replace <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>):</p>
<dl class="function">
<dt id="gvar.switch_gvar">
<code class="descclassname">gvar.</code><code class="descname">switch_gvar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gvar.switch_gvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a> to new <code class="xref py py-class docutils literal"><span class="pre">gvar.GVarFactory</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">New <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gvar.restore_gvar">
<code class="descclassname">gvar.</code><code class="descname">restore_gvar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gvar.restore_gvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore previous <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Previous <a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gvar.gvar_factory">
<code class="descclassname">gvar.</code><code class="descname">gvar_factory</code><span class="sig-paren">(</span><em>cov=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.gvar_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Return new function for creating <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (to replace
<a class="reference internal" href="#gvar.gvar" title="gvar.gvar"><code class="xref py py-func docutils literal"><span class="pre">gvar.gvar()</span></code></a>).</p>
<p>If <code class="docutils literal"><span class="pre">cov</span></code> is specified, it is used as the covariance matrix
for new <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s created by the function returned by
<code class="docutils literal"><span class="pre">gvar_factory(cov)</span></code>. Otherwise a new covariance matrix is created
internally.</p>
</dd></dl>

<p><a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s created by different functions cannot be combined in arithmetic
expressions (the error message &#8220;Incompatible GVars.&#8221; results).</p>
</div>
<div class="section" id="gvar-gvar-objects">
<h2><a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> Objects<a class="headerlink" href="#gvar-gvar-objects" title="Permalink to this headline">¶</a></h2>
<p>The fundamental class for representing Gaussian variables is:</p>
<dl class="class">
<dt id="gvar.GVar">
<em class="property">class </em><code class="descclassname">gvar.</code><code class="descname">GVar</code><a class="headerlink" href="#gvar.GVar" title="Permalink to this definition">¶</a></dt>
<dd><p>The basic attributes are:</p>
<dl class="attribute">
<dt id="gvar.GVar.mean">
<code class="descname">mean</code><a class="headerlink" href="#gvar.GVar.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean value.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.GVar.sdev">
<code class="descname">sdev</code><a class="headerlink" href="#gvar.GVar.sdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard deviation.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.GVar.var">
<code class="descname">var</code><a class="headerlink" href="#gvar.GVar.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Variance.</p>
</dd></dl>

<p>Two methods allow one to isolate the contributions to the variance
or standard deviation coming from other <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s:</p>
<dl class="method">
<dt id="gvar.GVar.partialvar">
<code class="descname">partialvar</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.GVar.partialvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute partial variance due to <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in <code class="docutils literal"><span class="pre">args</span></code>.</p>
<p>This method computes the part of <code class="docutils literal"><span class="pre">self.var</span></code> due to the <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
in <code class="docutils literal"><span class="pre">args</span></code>. If <code class="docutils literal"><span class="pre">args[i]</span></code> is correlated with other <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, the
variance coming from these is included in the result as well. (This
last convention is necessary because variances associated with
correlated <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s cannot be disentangled into contributions
corresponding to each variable separately.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args[i]</strong> (<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> or array/dictionary of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s) &#8211; Variables contributing to the partial variance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Partial variance due to all of <code class="docutils literal"><span class="pre">args</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gvar.GVar.partialsdev">
<code class="descname">partialsdev</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.GVar.partialsdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute partial standard deviation due to <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s in <code class="docutils literal"><span class="pre">args</span></code>.</p>
<p>This method computes the part of <code class="docutils literal"><span class="pre">self.sdev</span></code> due to the <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s
in <code class="docutils literal"><span class="pre">args</span></code>. If <code class="docutils literal"><span class="pre">args[i]</span></code> is correlated with other <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, the
standard deviation coming from these is included in the result as
well. (This last convention is necessary because variances
associated with correlated <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s cannot be disentangled into
contributions corresponding to each variable separately.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args[i]</strong> (<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> or array/dictionary of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s) &#8211; Variables contributing to the partial standard
deviation.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Partial standard deviation due to <code class="docutils literal"><span class="pre">args</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Partial derivatives of the <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> with respect to the independent
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s from which it was constructed are given by:</p>
<dl class="method">
<dt id="gvar.GVar.deriv">
<code class="descname">deriv</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.GVar.deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of <code class="docutils literal"><span class="pre">self</span></code> with respest to <em>primary</em> <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>All <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s are constructed from primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.
<code class="docutils literal"><span class="pre">self.deriv(x)</span></code> returns the partial derivative of <code class="docutils literal"><span class="pre">self</span></code> with
respect to primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> <code class="docutils literal"><span class="pre">x</span></code>, holding all of the other
primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s constant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> &#8211; A primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> (or a function of a single
primary <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The derivative of <code class="docutils literal"><span class="pre">self</span></code> with respect to <code class="docutils literal"><span class="pre">x</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>There are two methods for converting <code class="docutils literal"><span class="pre">self</span></code> into a string, for
printing:</p>
<dl class="method">
<dt id="gvar.GVar.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gvar.GVar.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return string representation of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>The representation is designed to show at least
one digit of the mean and two digits of the standard deviation.
For cases where mean and standard deviation are not
too different in magnitude, the representation is of the
form <code class="docutils literal"><span class="pre">'mean(sdev)'</span></code>. When this is not possible, the string
has the form <code class="docutils literal"><span class="pre">'mean</span> <span class="pre">+-</span> <span class="pre">sdev'</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="gvar.GVar.fmt">
<code class="descname">fmt</code><span class="sig-paren">(</span><em>ndecimal=None</em>, <em>sep=''</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.GVar.fmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to string with format: <code class="docutils literal"><span class="pre">mean(sdev)</span></code>.</p>
<p>Leading zeros in the standard deviation are omitted: for example,
<code class="docutils literal"><span class="pre">25.67</span> <span class="pre">+-</span> <span class="pre">0.02</span></code> becomes <code class="docutils literal"><span class="pre">25.67(2)</span></code>. Parameter <code class="docutils literal"><span class="pre">ndecimal</span></code>
specifies how many digits follow the decimal point in the mean.
Parameter <code class="docutils literal"><span class="pre">sep</span></code> is a string that is inserted between the <code class="docutils literal"><span class="pre">mean</span></code>
and the <code class="docutils literal"><span class="pre">(sdev)</span></code>. If <code class="docutils literal"><span class="pre">ndecimal</span></code> is <code class="docutils literal"><span class="pre">None</span></code> (default), it is set
automatically to the larger of <code class="docutils literal"><span class="pre">int(2-log10(self.sdev))</span></code> or
<code class="docutils literal"><span class="pre">0</span></code>; this will display at least two digits of error. Very large
or very small numbers are written with exponential notation when
<code class="docutils literal"><span class="pre">ndecimal</span></code> is <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>Setting <code class="docutils literal"><span class="pre">ndecimal</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> returns <code class="docutils literal"><span class="pre">mean</span> <span class="pre">+-</span> <span class="pre">sdev</span></code>.</p>
</dd></dl>

<p>Two attributes and a method make reference to the original
variables from which <code class="docutils literal"><span class="pre">self</span></code> is derived:</p>
<dl class="attribute">
<dt id="gvar.GVar.cov">
<code class="descname">cov</code><a class="headerlink" href="#gvar.GVar.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Underlying covariance matrix (type <code class="xref py py-class docutils literal"><span class="pre">gvar.smat</span></code>) shared by all
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.GVar.der">
<code class="descname">der</code><a class="headerlink" href="#gvar.GVar.der" title="Permalink to this definition">¶</a></dt>
<dd><p>Array of derivatives with respect to  underlying (original)
<a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</p>
</dd></dl>

<dl class="method">
<dt id="gvar.GVar.dotder">
<code class="descname">dotder</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.GVar.dotder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dot product of <code class="docutils literal"><span class="pre">self.der</span></code> and <code class="docutils literal"><span class="pre">v</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="other-classes">
<h2>Other Classes<a class="headerlink" href="#other-classes" title="Permalink to this headline">¶</a></h2>
<p>The following class is a specialized form of an ordered dictionary for
holding <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (or other scalars) and arrays of <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (or other
scalars) that supports Python pickling:</p>
<dl class="class">
<dt id="gvar.BufferDict">
<em class="property">class </em><code class="descclassname">gvar.</code><code class="descname">BufferDict</code><a class="headerlink" href="#gvar.BufferDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordered dictionary whose data are packed into a 1-d buffer (numpy.array).</p>
<p>A <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> object is an ordered dictionary whose values must
either be scalars or arrays (like <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> arrays, with arbitrary
shapes). The scalars and arrays are assembled into different parts of a
single one-dimensional buffer. The various scalars and arrays are
retrieved using keys: <em>e.g.</em>,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">BufferDict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s">&#39;scalar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s">&#39;vector&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s">&#39;tensor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">],[</span><span class="mf">5.</span><span class="p">,</span><span class="mf">6.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>              <span class="c"># print a&#39;s buffer</span>
<span class="go">[ 0.  1.  2.  3.  4.  5.  6.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>                     <span class="c"># iterate over keys in a</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
<span class="go">scalar 0.0</span>
<span class="go">vector [ 1.  2.]</span>
<span class="go">tensor [[ 3.  4.]</span>
<span class="go"> [ 5.  6.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s">&#39;vector&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="s">&#39;vector&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span>    <span class="c"># change the &#39;vector&#39; part of a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="go">[  0.  10.  20.   3.   4.   5.   6.]</span>
</pre></div>
</div>
<p>The first four lines here could have been collapsed to one statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">BufferDict</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">vector</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],</span><span class="n">tensor</span><span class="o">=</span><span class="p">[[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">],[</span><span class="mf">5.</span><span class="p">,</span><span class="mf">6.</span><span class="p">]])</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">BufferDict</span><span class="p">([(</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="mf">0.0</span><span class="p">),(</span><span class="s">&#39;vector&#39;</span><span class="p">,[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">]),</span>
                <span class="p">(</span><span class="s">&#39;tensor&#39;</span><span class="p">,[[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">],[</span><span class="mf">5.</span><span class="p">,</span><span class="mf">6.</span><span class="p">]])])</span>
</pre></div>
</div>
<p>where in the second case the order of the keys is preserved in <code class="docutils literal"><span class="pre">a</span></code>
(since <code class="docutils literal"><span class="pre">BufferDict</span></code> is an ordered dictionary).</p>
<p>The keys and associated shapes in a <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> can be transferred to a
different buffer, creating a new <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a>: <em>e.g.</em>, using <code class="docutils literal"><span class="pre">a</span></code> from
above,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">10.</span><span class="p">,</span><span class="mf">20.</span><span class="p">,</span><span class="mf">30.</span><span class="p">,</span><span class="mf">40.</span><span class="p">,</span><span class="mf">50.</span><span class="p">,</span><span class="mf">60.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">BufferDict</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">)</span>          <span class="c"># clone a but with new buffer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s">&#39;tensor&#39;</span><span class="p">])</span>
<span class="go">[[ 30.  40.]</span>
<span class="go"> [ 50.  60.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="s">&#39;scalar&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="go">[  1.  10.  20.  30.  40.  50.  60.]</span>
</pre></div>
</div>
<p>Note how <code class="docutils literal"><span class="pre">b</span></code> references <code class="docutils literal"><span class="pre">buf</span></code> and can modify it. One can also
replace the buffer in the original <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> using, for example,
<code class="docutils literal"><span class="pre">a.buf</span> <span class="pre">=</span> <span class="pre">buf</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="s">&#39;tensor&#39;</span><span class="p">])</span>
<span class="go">[[ 30.  40.]</span>
<span class="go"> [ 50.  60.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s">&#39;tensor&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">10.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="go">[  1.  10.  20.  300.  400.  500.  600.]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">a.buf</span></code> is the numpy array used for <code class="docutils literal"><span class="pre">a</span></code>&#8216;s buffer. It can be used to
access and change the buffer directly. In <code class="docutils literal"><span class="pre">a.buf</span> <span class="pre">=</span> <span class="pre">buf</span></code>, the new
buffer <code class="docutils literal"><span class="pre">buf</span></code> must be a <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> array of the correct shape. The
buffer can also be accessed through iterator <code class="docutils literal"><span class="pre">a.flat</span></code> (in analogy
with <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> arrays), and through <code class="docutils literal"><span class="pre">a.flatten()</span></code> which returns a
copy of the buffer.</p>
<p>When creating a <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> from a dictionary (or another <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a>),
the keys included and their order can be specified using a list of keys:
for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="p">[[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">],[</span><span class="mf">5.</span><span class="p">,</span><span class="mf">6.</span><span class="p">]],</span><span class="n">d</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 0.0, &#39;c&#39;: [[3.0, 4.0], [5.0, 6.0]], &#39;b&#39;: [1.0, 2.0], &#39;d&#39;: None}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">BufferDict</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
<span class="go">d None</span>
<span class="go">b [1.0 2.0]</span>
<span class="go">a 0.0</span>
</pre></div>
</div>
<p>A <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> functions like a dictionary except: a) items cannot be
deleted once inserted; b) all values must be either scalars or arrays
of scalars, where the scalars can be any noniterable type that works
with <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> arrays; and c) any new value assigned to an existing
key must have the same size and shape as the original value.</p>
<p>Note that <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a>s can be pickled and unpickled even when they
store <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s (which themselves cannot be pickled separately).</p>
<p>The main attributes are:</p>
<dl class="attribute">
<dt id="gvar.BufferDict.size">
<code class="descname">size</code><a class="headerlink" href="#gvar.BufferDict.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of buffer array.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.BufferDict.flat">
<code class="descname">flat</code><a class="headerlink" href="#gvar.BufferDict.flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Buffer array iterator.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.BufferDict.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#gvar.BufferDict.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Data type of buffer array elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.BufferDict.buf">
<code class="descname">buf</code><a class="headerlink" href="#gvar.BufferDict.buf" title="Permalink to this definition">¶</a></dt>
<dd><p>The (1d) buffer array. Allows direct access to the buffer: for example,
<code class="docutils literal"><span class="pre">self.buf[i]</span> <span class="pre">=</span> <span class="pre">new_val</span></code> sets the value of the <code class="docutils literal"><span class="pre">i-th</span></code> element in
the buffer to value <code class="docutils literal"><span class="pre">new_val</span></code>.  Setting <code class="docutils literal"><span class="pre">self.buf</span> <span class="pre">=</span> <span class="pre">nbuf</span></code>
replaces the old buffer by new buffer <code class="docutils literal"><span class="pre">nbuf</span></code>. This only works if
<code class="docutils literal"><span class="pre">nbuf</span></code> is a one-dimensional <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> array having the same
length as the old buffer, since <code class="docutils literal"><span class="pre">nbuf</span></code> itself is used as the new
buffer (not a copy).</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.BufferDict.shape">
<code class="descname">shape</code><a class="headerlink" href="#gvar.BufferDict.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Always equal to <code class="docutils literal"><span class="pre">None</span></code>. This attribute is included since
<a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a>s share several attributes with <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> arrays to
simplify coding that might support either type. Being dictionaries
they do not have shapes in the sense of <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> arrays (hence
the shape is <code class="docutils literal"><span class="pre">None</span></code>).</p>
</dd></dl>

<p>The main methods are:</p>
<dl class="method">
<dt id="gvar.BufferDict.flatten">
<code class="descname">flatten</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gvar.BufferDict.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy of buffer array.</p>
</dd></dl>

<dl class="method">
<dt id="gvar.BufferDict.slice">
<code class="descname">slice</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.BufferDict.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return slice/index in <code class="docutils literal"><span class="pre">self.flat</span></code> corresponding to key <code class="docutils literal"><span class="pre">k</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="gvar.BufferDict.isscalar">
<code class="descname">isscalar</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.BufferDict.isscalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">self[k]</span></code> is scalar else <code class="docutils literal"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="gvar.BufferDict.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.BufferDict.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Add contents of dictionary <code class="docutils literal"><span class="pre">d</span></code> to <code class="docutils literal"><span class="pre">self</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="gvar.BufferDict.load">
<em class="property">static </em><code class="descname">load</code><span class="sig-paren">(</span><em>fobj</em>, <em>use_json=False</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.BufferDict.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load serialized <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> from file object <code class="docutils literal"><span class="pre">fobj</span></code>.
Uses <code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code> unless <code class="docutils literal"><span class="pre">use_json</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, in which case
it uses <code class="xref py py-mod docutils literal"><span class="pre">json</span></code> (obvioulsy).</p>
</dd></dl>

<dl class="staticmethod">
<dt id="gvar.BufferDict.loads">
<em class="property">static </em><code class="descname">loads</code><span class="sig-paren">(</span><em>s</em>, <em>use_json=False</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.BufferDict.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>Load serialized <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> from string object <code class="docutils literal"><span class="pre">s</span></code>.
Uses <code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code> unless <code class="docutils literal"><span class="pre">use_json</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, in which case
it uses <code class="xref py py-mod docutils literal"><span class="pre">json</span></code> (obvioulsy).</p>
</dd></dl>

<dl class="method">
<dt id="gvar.BufferDict.dump">
<code class="descname">dump</code><span class="sig-paren">(</span><em>fobj</em>, <em>use_json=False</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.BufferDict.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> in file object <code class="docutils literal"><span class="pre">fobj</span></code>.</p>
<p>Uses <code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code> unless <code class="docutils literal"><span class="pre">use_json</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, in which case
it uses <code class="xref py py-mod docutils literal"><span class="pre">json</span></code> (obviously). <code class="xref py py-mod docutils literal"><span class="pre">json</span></code> does not handle
non-string valued keys very well. This attempts a workaround, but
it will only work in simpler cases. Serialization only works when
<code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code> (or <code class="xref py py-mod docutils literal"><span class="pre">json</span></code>) knows how to serialize the data type
stored in the <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a>&#8216;s buffer (or for <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s).</p>
</dd></dl>

<dl class="method">
<dt id="gvar.BufferDict.dumps">
<code class="descname">dumps</code><span class="sig-paren">(</span><em>use_json=False</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.BufferDict.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize <a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a> into string.</p>
<p>Uses <code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code> unless <code class="docutils literal"><span class="pre">use_json</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, in which case
it uses <code class="xref py py-mod docutils literal"><span class="pre">json</span></code> (obviously). <code class="xref py py-mod docutils literal"><span class="pre">json</span></code> does not handle
non-string valued keys very well. This attempts a workaround, but
it will only work in simpler cases (e.g., integers, tuples of
integers, etc.). Serialization only works when <code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code> (or
<code class="xref py py-mod docutils literal"><span class="pre">json</span></code>) knows how to serialize the data type stored in the
<a class="reference internal" href="#gvar.BufferDict" title="gvar.BufferDict"><code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code></a>&#8216;s buffer (or for <a class="reference internal" href="#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s).</p>
</dd></dl>

</dd></dl>

<p>SVD analysis is handled by the following class:</p>
<dl class="class">
<dt id="gvar.SVD">
<em class="property">class </em><code class="descclassname">gvar.</code><code class="descname">SVD</code><span class="sig-paren">(</span><em>mat</em>, <em>svdcut=None</em>, <em>svdnum=None</em>, <em>compute_delta=False</em>, <em>rescale=False</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.SVD" title="Permalink to this definition">¶</a></dt>
<dd><p>SVD decomposition of a pos. sym. matrix.</p>
<p><a class="reference internal" href="#gvar.SVD" title="gvar.SVD"><code class="xref py py-class docutils literal"><span class="pre">SVD</span></code></a> is a function-class that computes the eigenvalues and
eigenvectors of a positive symmetric matrix <code class="docutils literal"><span class="pre">mat</span></code>. Eigenvalues that
are small (or negative, because of roundoff) can be eliminated or
modified using <em>svd</em> cuts. Typical usage is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mat</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.</span><span class="p">,</span><span class="o">.</span><span class="mi">25</span><span class="p">],[</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="mf">2.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SVD</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>             <span class="c"># eigenvalues</span>
<span class="go">[ 0.94098301  2.05901699]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>          <span class="c"># 1st eigenvector (for s.val[0])</span>
<span class="go">[ 0.97324899 -0.22975292]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>          <span class="c"># 2nd eigenvector (for s.val[1])</span>
<span class="go">[ 0.22975292  0.97324899]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SVD</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="n">svdcut</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>  <span class="c"># force s.val[i]&gt;=s.val[-1]*0.6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
<span class="go">[ 1.2354102   2.05901699]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>          <span class="c"># eigenvector unchanged</span>
<span class="go">[ 0.97324899 -0.22975292]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SVD</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">decomp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>         <span class="c"># decomposition of inverse of mat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invmat</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">wj</span><span class="p">,</span><span class="n">wj</span><span class="p">)</span> <span class="k">for</span> <span class="n">wj</span> <span class="ow">in</span> <span class="n">w</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="n">invmat</span><span class="p">))</span>    <span class="c"># should be unit matrix</span>
<span class="go">[[  1.00000000e+00   2.77555756e-17]</span>
<span class="go"> [  1.66533454e-16   1.00000000e+00]]</span>
</pre></div>
</div>
<p>Input parameters are:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> (2-d sequence (<code class="docutils literal"><span class="pre">numpy.array</span></code> or <code class="docutils literal"><span class="pre">list</span></code> or ...)) &#8211; Positive, symmetric matrix.</li>
<li><strong>svdcut</strong> (<code class="docutils literal"><span class="pre">None</span></code> or number <code class="docutils literal"><span class="pre">(|svdcut|&lt;=1)</span></code>.) &#8211; If positive, replace eigenvalues of <code class="docutils literal"><span class="pre">mat</span></code> with
<code class="docutils literal"><span class="pre">svdcut*(max</span> <span class="pre">eigenvalue)</span></code>; if negative, discard eigenmodes with
eigenvalues smaller than <code class="docutils literal"><span class="pre">svdcut</span></code> times the maximum eigenvalue.</li>
<li><strong>svdnum</strong> (<code class="docutils literal"><span class="pre">None</span></code> or int) &#8211; If positive, keep only the modes with the largest
<code class="docutils literal"><span class="pre">svdnum</span></code> eigenvalues; ignore if set to <code class="docutils literal"><span class="pre">None</span></code>.</li>
<li><strong>compute_delta</strong> (<em>boolean</em>) &#8211; Compute <code class="docutils literal"><span class="pre">delta</span></code> (see below) if <code class="docutils literal"><span class="pre">True</span></code>; set
<code class="docutils literal"><span class="pre">delta=None</span></code> otherwise.</li>
<li><strong>rescale</strong> &#8211; Rescale the input matrix to make its diagonal elements
equal to 1.0 before diagonalizing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The results are accessed using:</p>
<dl class="attribute">
<dt id="gvar.SVD.val">
<code class="descname">val</code><a class="headerlink" href="#gvar.SVD.val" title="Permalink to this definition">¶</a></dt>
<dd><p>An ordered array containing the eigenvalues or <code class="docutils literal"><span class="pre">mat</span></code>. Note
that <code class="docutils literal"><span class="pre">val[i]&lt;=val[i+1]</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.SVD.vec">
<code class="descname">vec</code><a class="headerlink" href="#gvar.SVD.vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvectors <code class="docutils literal"><span class="pre">vec[i]</span></code> corresponding to the eigenvalues
<code class="docutils literal"><span class="pre">val[i]</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.SVD.D">
<code class="descname">D</code><a class="headerlink" href="#gvar.SVD.D" title="Permalink to this definition">¶</a></dt>
<dd><p>The diagonal matrix used to precondition the input matrix if
<code class="docutils literal"><span class="pre">rescale==True</span></code>. The matrix diagonalized is <code class="docutils literal"><span class="pre">D</span> <span class="pre">M</span> <span class="pre">D</span></code> where <code class="docutils literal"><span class="pre">M</span></code>
is the input matrix. <code class="docutils literal"><span class="pre">D</span></code> is stored as a one-dimensional vector of
diagonal elements. <code class="docutils literal"><span class="pre">D</span></code> is <code class="docutils literal"><span class="pre">None</span></code> if <code class="docutils literal"><span class="pre">rescale==False</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.SVD.nmod">
<code class="descname">nmod</code><a class="headerlink" href="#gvar.SVD.nmod" title="Permalink to this definition">¶</a></dt>
<dd><p>The first <code class="docutils literal"><span class="pre">nmod</span></code> eigenvalues in <code class="docutils literal"><span class="pre">self.val</span></code> were modified by
the SVD cut (equals 0 unless <code class="docutils literal"><span class="pre">svdcut</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>).</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.SVD.eigen_range">
<code class="descname">eigen_range</code><a class="headerlink" href="#gvar.SVD.eigen_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Ratio of the smallest to the largest eigenvector in the
unconditioned matrix (after rescaling if <code class="docutils literal"><span class="pre">rescale=True</span></code>)</p>
</dd></dl>

<dl class="attribute">
<dt id="gvar.SVD.delta">
<code class="descname">delta</code><a class="headerlink" href="#gvar.SVD.delta" title="Permalink to this definition">¶</a></dt>
<dd><p>A vector of <code class="docutils literal"><span class="pre">gvar</span></code>s whose means are zero and whose
covariance matrix is what was added to <code class="docutils literal"><span class="pre">mat</span></code> to condition
its eigenvalues. Is <code class="docutils literal"><span class="pre">None</span></code> if <code class="docutils literal"><span class="pre">svdcut&lt;0</span></code> or
<code class="docutils literal"><span class="pre">compute_delta==False</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="gvar.SVD.decomp">
<code class="descname">decomp</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.SVD.decomp" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector decomposition of input matrix raised to power <code class="docutils literal"><span class="pre">n</span></code>.</p>
<p>Computes vectors <code class="docutils literal"><span class="pre">w[i]</span></code> such that</p>
<blockquote>
<div>mat**n = sum_i numpy.outer(w[i],w[i])</div></blockquote>
<p>where <code class="docutils literal"><span class="pre">mat</span></code> is the original input matrix to <a class="reference internal" href="#gvar.svd" title="gvar.svd"><code class="xref py py-class docutils literal"><span class="pre">svd</span></code></a>. This
decomposition cannot be computed if the input matrix was rescaled
(<code class="docutils literal"><span class="pre">rescale=True</span></code>) except for <code class="docutils literal"><span class="pre">n=1</span></code> and <code class="docutils literal"><span class="pre">n=-1</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>number</em>) &#8211; Power of input matrix.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Array <code class="docutils literal"><span class="pre">w</span></code> of vectors.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code></a> makes heavy use of <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> for array manipulations. It
also uses the <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> code for implementing elementary functions
(<em>e.g.</em>, <code class="docutils literal"><span class="pre">sin</span></code>, <code class="docutils literal"><span class="pre">exp</span></code> ...) in terms of member functions.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">gvar</span></code> - Gaussian Random Variables</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#creating-gaussian-variables">Creating Gaussian Variables</a></li>
<li><a class="reference internal" href="#gvar-arithmetic-and-functions"><code class="docutils literal"><span class="pre">gvar.GVar</span></code> Arithmetic and Functions</a></li>
<li><a class="reference internal" href="#error-budgets-from-gvars">Error Budgets from <code class="docutils literal"><span class="pre">gvar.GVar</span></code>s</a></li>
<li><a class="reference internal" href="#storing-gvars-for-later-use-bufferdicts">Storing <code class="docutils literal"><span class="pre">gvar.GVar</span></code>s for Later Use; <code class="docutils literal"><span class="pre">gvar.BufferDict</span></code>s</a></li>
<li><a class="reference internal" href="#random-number-generators">Random Number Generators</a></li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
<li><a class="reference internal" href="#optimizations">Optimizations</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#gvar-gvar-objects"><code class="docutils literal"><span class="pre">gvar.GVar</span></code> Objects</a></li>
<li><a class="reference internal" href="#other-classes">Other Classes</a></li>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="case-pendulum.html"
                        title="previous chapter">Case Study: Pendulum</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="gvar_dataset.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">gvar.dataset</span></code> - Random Data Sets</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gvar_dataset.html" title="gvar.dataset - Random Data Sets"
             >next</a> |</li>
        <li class="right" >
          <a href="case-pendulum.html" title="Case Study: Pendulum"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">lsqfit 6.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2009-2014, G. P. Lepage.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>