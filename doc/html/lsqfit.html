<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lsqfit - Nonlinear Least Squares Fitting &mdash; lsqfit 8.0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '8.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="lsqfit 8.0.1 documentation" href="index.html" />
    <link rel="prev" title="Case Study: Outliers and Bayesian Integrals" href="case-outliers.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body role="document">

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="case-outliers.html" title="Case Study: Outliers and Bayesian Integrals"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">lsqfit 8.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lsqfit-nonlinear-least-squares-fitting">
<h1><a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></code></a> - Nonlinear Least Squares Fitting<a class="headerlink" href="#lsqfit-nonlinear-least-squares-fitting" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-lsqfit"></span><div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This package contains tools for nonlinear least-squares curve fitting of
data. In general a fit has four inputs:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The dependent data <code class="docutils literal"><span class="pre">y</span></code> that is to be fit &#8212; typically <code class="docutils literal"><span class="pre">y</span></code>
is a Python dictionary in an <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></code></a> analysis. Its values
<code class="docutils literal"><span class="pre">y[k]</span></code> are either <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s or arrays (any shape or dimension) of
<code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s that specify the values of the dependent variables
and their errors.</li>
<li>A collection <code class="docutils literal"><span class="pre">x</span></code> of independent data &#8212; <code class="docutils literal"><span class="pre">x</span></code> can have any
structure and contain any data (or no data).</li>
<li>A fit function <code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">p)</span></code> whose parameters <code class="docutils literal"><span class="pre">p</span></code> are adjusted by
the fit until <code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">p)</span></code> equals <code class="docutils literal"><span class="pre">y</span></code> to within <code class="docutils literal"><span class="pre">y</span></code>s errors
&#8212; parameters <cite>p`</cite> are usually specified by a dictionary whose
values <code class="docutils literal"><span class="pre">p[k]</span></code> are individual parameters or (<code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code>)
arrays of parameters. The fit function is assumed independent
of <code class="docutils literal"><span class="pre">x</span></code> (that is, <code class="docutils literal"><span class="pre">f(p)</span></code>) if <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">False</span></code> (or if <code class="docutils literal"><span class="pre">x</span></code> is
omitted from the input data).</li>
<li>Initial estimates or <em>priors</em> for each parameter in <code class="docutils literal"><span class="pre">p</span></code>
&#8212; priors are usually specified using a dictionary <code class="docutils literal"><span class="pre">prior</span></code>
whose values <code class="docutils literal"><span class="pre">prior[k]</span></code> are <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s or arrays of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s that
give initial estimates (values and errors) for parameters <code class="docutils literal"><span class="pre">p[k]</span></code>.</li>
</ol>
</div></blockquote>
<p>A typical code sequence has the structure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">...</span> <span class="n">collect</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">prior</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">compute</span> <span class="n">fit</span> <span class="n">to</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">y</span><span class="p">,</span> <span class="n">using</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">...</span>
    <span class="o">...</span> <span class="k">return</span> <span class="n">dictionary</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">fit</span> <span class="n">values</span> <span class="k">for</span> <span class="n">the</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="n">s</span> <span class="o">...</span>

<span class="n">fit</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">fcn</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>      <span class="c"># variable fit is of type nonlinear_fit</span>
</pre></div>
</div>
<p>The parameters <code class="docutils literal"><span class="pre">p[k]</span></code> are varied until the <code class="docutils literal"><span class="pre">chi**2</span></code> for the fit is
minimized.</p>
<p>The best-fit values for the parameters are recovered after fitting
using, for example, <code class="docutils literal"><span class="pre">p=fit.p</span></code>. Then the <code class="docutils literal"><span class="pre">p[k]</span></code> are <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s or
arrays of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s that give best-fit estimates and fit uncertainties
in those estimates. The <code class="docutils literal"><span class="pre">print(fit)</span></code> statement prints a summary of
the fit results.</p>
<p>The dependent variable <code class="docutils literal"><span class="pre">y</span></code> above could be an array instead of a
dictionary, which is less flexible in general but possibly more
convenient in simpler fits. Then the approximate <code class="docutils literal"><span class="pre">y</span></code> returned by fit
function <code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">p)</span></code> must be an array with the same shape as the dependent
variable. The prior <code class="docutils literal"><span class="pre">prior</span></code> could also be represented by an array
instead of a dictionary.</p>
<p>By default priors are Gaussian/normal distributions, represented by  <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s.
Setting <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">nonlinear_fit</span></code></a> parameter <code class="docutils literal"><span class="pre">extend=True</span></code>  allows for log-normal
and sqrt-normal distributions as well. The latter are indicated by replacing
the prior (in a dictionary prior) with key <code class="docutils literal"><span class="pre">c</span></code>,  for example, by a prior for
the parameter&#8217;s logarithm or square root, with key <code class="docutils literal"><span class="pre">log(c)</span></code> or <code class="docutils literal"><span class="pre">sqrt(c)</span></code>,
respectively.  <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">nonlinear_fit</span></code></a> adds parameter <code class="docutils literal"><span class="pre">c</span></code> to the parameter
dictionary, deriving its value from parameter <code class="docutils literal"><span class="pre">log(c)</span></code> or <code class="docutils literal"><span class="pre">sqrt(c)</span></code>. The
fit function can be expressed directly in terms of parameter <code class="docutils literal"><span class="pre">c</span></code>  and so is
the same no matter which distribution is used for <code class="docutils literal"><span class="pre">c</span></code>. Note that a
sqrt-normal distribution with zero mean is equivalent to an exponential
distribution. Additional distributions can be added using
<a class="reference internal" href="#gvar.add_parameter_distribution" title="gvar.add_parameter_distribution"><code class="xref py py-meth docutils literal"><span class="pre">gvar.add_parameter_distribution()</span></code></a>.</p>
<p>The <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></code></a> tutorial contains extended explanations and examples.
The first appendix in the paper at <a class="reference external" href="http://arxiv.org/abs/arXiv:1406.2279">http://arxiv.org/abs/arXiv:1406.2279</a>
provides conceptual background on the techniques used in this
module for fits and, especially, error budgets.</p>
</div>
<div class="section" id="nonlinear-fit-objects">
<h2>nonlinear_fit Objects<a class="headerlink" href="#nonlinear-fit-objects" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lsqfit.nonlinear_fit">
<em class="property">class </em><code class="descclassname">lsqfit.</code><code class="descname">nonlinear_fit</code><span class="sig-paren">(</span><em>data</em>, <em>fcn</em>, <em>prior=None</em>, <em>p0=None</em>, <em>extend=False</em>, <em>svdcut=1e-15</em>, <em>debug=False</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Nonlinear least-squares fit.</p>
<p><a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a> fits a (nonlinear) function <code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">p)</span></code>
to data <code class="docutils literal"><span class="pre">y</span></code> by varying parameters <code class="docutils literal"><span class="pre">p</span></code>, and stores the results: for
example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">fcn</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>   <span class="c"># do fit</span>
<span class="k">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>                               <span class="c"># print fit results</span>
</pre></div>
</div>
<p>The best-fit values for the parameters are in <code class="docutils literal"><span class="pre">fit.p</span></code>, while the
<code class="docutils literal"><span class="pre">chi**2</span></code>, the number of degrees of freedom, the logarithm of Gaussian
Bayes Factor, the number of iterations, and the cpu time needed for the
fit are in <code class="docutils literal"><span class="pre">fit.chi2</span></code>, <code class="docutils literal"><span class="pre">fit.dof</span></code>, <code class="docutils literal"><span class="pre">fit.logGBF</span></code>, <code class="docutils literal"><span class="pre">fit.nit</span></code>, and
<code class="docutils literal"><span class="pre">fit.time</span></code>, respectively. Results for individual parameters in
<code class="docutils literal"><span class="pre">fit.p</span></code> are of type <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>, and therefore carry information about
errors and correlations with other parameters. The fit data and prior
can be recovered using <code class="docutils literal"><span class="pre">fit.x</span></code> (equals <code class="docutils literal"><span class="pre">False</span></code> if there is no <code class="docutils literal"><span class="pre">x</span></code>),
<code class="docutils literal"><span class="pre">fit.y</span></code>, and <code class="docutils literal"><span class="pre">fit.prior</span></code>; the data and prior are corrected for the
<em>svd</em> cut, if there is one (that is, their covariance matrices have been
modified in accordance with the <em>svd</em> cut).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; <p>Data to be fit by <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a>. It can
have any of the following formats:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y</span></code></dt>
<dd><code class="docutils literal"><span class="pre">x</span></code> is the independent data that is passed to the fit
function with the fit parameters: <code class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. <code class="docutils literal"><span class="pre">y</span></code> is a
dictionary (or array) of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s that encode the means and
covariance matrix for the data that is to be fit being fit.
The fit function must return a result having the same
layout as <code class="docutils literal"><span class="pre">y</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">y</span></code></dt>
<dd><code class="docutils literal"><span class="pre">y</span></code> is a dictionary (or array) of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s that encode
the means and covariance matrix for the data being fit.
There is no independent data so the fit function depends
only upon the fit parameters: <code class="docutils literal"><span class="pre">fit(p)</span></code>. The fit function
must return a result having the same layout as <code class="docutils literal"><span class="pre">y</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">ymean,</span> <span class="pre">ycov</span></code></dt>
<dd><code class="docutils literal"><span class="pre">x</span></code> is the independent data that is passed to the fit
function with the fit parameters: <code class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. <code class="docutils literal"><span class="pre">ymean</span></code>
is an array containing the mean values of the fit data.
<code class="docutils literal"><span class="pre">ycov</span></code> is an array containing the covariance matrix of
the fit data; <code class="docutils literal"><span class="pre">ycov.shape</span></code> equals <code class="docutils literal"><span class="pre">2*ymean.shape</span></code>.
The fit function must return an array having the same
shape as <code class="docutils literal"><span class="pre">ymean</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">ymean,</span> <span class="pre">ysdev</span></code></dt>
<dd><code class="docutils literal"><span class="pre">x</span></code> is the independent data that is passed to the fit
function with the fit parameters: <code class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. <code class="docutils literal"><span class="pre">ymean</span></code>
is an array containing the mean values of the fit data.
<code class="docutils literal"><span class="pre">ysdev</span></code> is an array containing the standard deviations of
the fit data; <code class="docutils literal"><span class="pre">ysdev.shape</span></code> equals <code class="docutils literal"><span class="pre">ymean.shape</span></code>. The
data are assumed to be uncorrelated. The fit function must
return an array having the same shape as <code class="docutils literal"><span class="pre">ymean</span></code>.</dd>
</dl>
</div></blockquote>
<p>Setting <code class="docutils literal"><span class="pre">x=False</span></code> in the first, third or fourth of these formats
implies that the fit function depends only on the fit parameters:
that is, <code class="docutils literal"><span class="pre">fcn(p)</span></code> instead of <code class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. (This is not assumed
if <code class="docutils literal"><span class="pre">x=None</span></code>.)</p>
</li>
<li><strong>fcn</strong> (<em>function</em>) &#8211; The function to be fit to <code class="docutils literal"><span class="pre">data</span></code>. It is either a
function of the independent data <code class="docutils literal"><span class="pre">x</span></code> and the fit parameters <code class="docutils literal"><span class="pre">p</span></code>
(<code class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>), or a function of just the fit parameters
(<code class="docutils literal"><span class="pre">fcn(p)</span></code>) when there is no <code class="docutils literal"><span class="pre">x</span></code> data or <code class="docutils literal"><span class="pre">x=False</span></code>. The
parameters are tuned in the fit until the function returns values
that agree with the <code class="docutils literal"><span class="pre">y</span></code> data to within the <code class="docutils literal"><span class="pre">y</span></code>s&#8217; errors. The
function&#8217;s return value must have the same layout as the <code class="docutils literal"><span class="pre">y</span></code> data
(a dictionary or an array). The fit parameters <code class="docutils literal"><span class="pre">p</span></code> are either: 1)
a dictionary where each <code class="docutils literal"><span class="pre">p[k]</span></code> is a single parameter or an array
of parameters (any shape); or, 2) a single array of parameters. The
layout of the parameters is the same as that of prior <code class="docutils literal"><span class="pre">prior</span></code> if
it is specified; otherwise, it is inferred from of the starting
value <code class="docutils literal"><span class="pre">p0</span></code> for the fit.</li>
<li><strong>prior</strong> (dictionary, array, or <code class="docutils literal"><span class="pre">None</span></code>) &#8211; A dictionary (or array) containing <em>a priori</em> estimates
for all parameters <code class="docutils literal"><span class="pre">p</span></code> used by fit function <code class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code> (or
<code class="docutils literal"><span class="pre">fcn(p)</span></code>). Fit parameters <code class="docutils literal"><span class="pre">p</span></code> are stored in a dictionary (or
array) with the same keys and structure (or shape) as <code class="docutils literal"><span class="pre">prior</span></code>.
The default value is <code class="docutils literal"><span class="pre">None</span></code>; <code class="docutils literal"><span class="pre">prior</span></code> must be defined if <code class="docutils literal"><span class="pre">p0</span></code>
is <code class="docutils literal"><span class="pre">None</span></code>.</li>
<li><strong>p0</strong> (dictionary, array, string or <code class="docutils literal"><span class="pre">None</span></code>) &#8211; Starting values for fit parameters in fit.
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a> adjusts <code class="docutils literal"><span class="pre">p0</span></code> to make it consistent
in shape and structure with <code class="docutils literal"><span class="pre">prior</span></code> when the latter is
specified: elements missing from <code class="docutils literal"><span class="pre">p0</span></code> are filled
in using <code class="docutils literal"><span class="pre">prior</span></code>, and elements in
<code class="docutils literal"><span class="pre">p0</span></code> that are not in <code class="docutils literal"><span class="pre">prior</span></code> are discarded. If <code class="docutils literal"><span class="pre">p0</span></code> is a
string, it is taken as a file name and
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a> attempts to read starting values from
that file; best-fit parameter values are written out to the same
file after the fit (for priming future fits). If <code class="docutils literal"><span class="pre">p0</span></code> is <code class="docutils literal"><span class="pre">None</span></code>
or the attempt to read the file fails, starting values are
extracted from <code class="docutils literal"><span class="pre">prior</span></code>. The default value is <code class="docutils literal"><span class="pre">None</span></code>; <code class="docutils literal"><span class="pre">p0</span></code>
must be defined if <code class="docutils literal"><span class="pre">prior</span></code> is <code class="docutils literal"><span class="pre">None</span></code>.</li>
<li><strong>svdcut</strong> (<code class="docutils literal"><span class="pre">None</span></code> or <code class="docutils literal"><span class="pre">float</span></code>) &#8211; If <code class="docutils literal"><span class="pre">svdcut</span></code> is nonzero (not <code class="docutils literal"><span class="pre">None</span></code>), <em>svd</em> cuts
are applied to every block-diagonal sub-matrix of the covariance
matrix for the data <code class="docutils literal"><span class="pre">y</span></code> and <code class="docutils literal"><span class="pre">prior</span></code> (if there is a prior).
The blocks are first rescaled so that all
diagonal elements equal 1 &#8211; that is, the blocks are replaced
by the correlation matrices for the corresponding subsets of variables.
Then, if <code class="docutils literal"><span class="pre">svdcut</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>,
eigenvalues of the rescaled matrices that are smaller than <code class="docutils literal"><span class="pre">svdcut</span></code>
times the maximum eigenvalue are replaced by <code class="docutils literal"><span class="pre">svdcut</span></code> times the
maximum eigenvalue. This makes the covariance matrix less singular
and less susceptible to roundoff error. When <code class="docutils literal"><span class="pre">svdcut</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>,
eigenvalues smaller than <code class="docutils literal"><span class="pre">|svdcut|</span></code> times the maximum eigenvalue
are discarded and the corresponding components in <code class="docutils literal"><span class="pre">y</span></code> and
<code class="docutils literal"><span class="pre">prior</span></code> are zeroed out.</li>
<li><strong>extend</strong> &#8211; Log-normal and sqrt-normal distributions can be used
for fit priors when <code class="docutils literal"><span class="pre">extend=True</span></code>, provided the parameters are
specified by a dictionary (as opposed to an array). To use such a
distribution  for a parameter <code class="docutils literal"><span class="pre">'c'</span></code> in the fit prior, replace
<code class="docutils literal"><span class="pre">prior['c']</span></code>  with a prior specifying its logarithm or  square
root, designated by <code class="docutils literal"><span class="pre">prior['log(c)']</span></code>  or <code class="docutils literal"><span class="pre">prior['sqrt(c)']</span></code>,
respectively. The dictionaries containing parameters generated by
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a> will have entries for both <code class="docutils literal"><span class="pre">'c'</span></code>   and <code class="docutils literal"><span class="pre">'log(c)'</span></code>
or <code class="docutils literal"><span class="pre">'sqrt(c)'</span></code>, so only the prior need be changed to  switch to
log-normal/sqrt-normal distributions. Setting <code class="docutils literal"><span class="pre">extend=False</span></code> (the
default) restricts all parameters to Gaussian distributions.
Additional distributions can be added using
<a class="reference internal" href="#gvar.add_parameter_distribution" title="gvar.add_parameter_distribution"><code class="xref py py-meth docutils literal"><span class="pre">gvar.add_parameter_distribution()</span></code></a>.</li>
<li><strong>debug</strong> (<em>boolean</em>) &#8211; Set to <code class="docutils literal"><span class="pre">True</span></code> for extra debugging of the fit function
and a check for roundoff errors. (Default is <code class="docutils literal"><span class="pre">False</span></code>.)</li>
<li><strong>fitterargs</strong> &#8211; Dictionary of arguments passed on to
<a class="reference internal" href="#lsqfit.multifit" title="lsqfit.multifit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.multifit</span></code></a>, which does the fitting.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The results from the fit are accessed through the following attributes
(of <code class="docutils literal"><span class="pre">fit</span></code> where <code class="docutils literal"><span class="pre">fit</span> <span class="pre">=</span> <span class="pre">nonlinear_fit(...)</span></code>):</p>
<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.chi2">
<code class="descname">chi2</code><a class="headerlink" href="#lsqfit.nonlinear_fit.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum <code class="docutils literal"><span class="pre">chi**2</span></code> for the fit. <code class="docutils literal"><span class="pre">fit.chi2</span> <span class="pre">/</span> <span class="pre">fit.dof</span></code> is usually
of order one in good fits; values much less than one suggest
that the actual standard deviations in the input data and/or priors are
smaller than the standard deviations used in the fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.cov">
<code class="descname">cov</code><a class="headerlink" href="#lsqfit.nonlinear_fit.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Covariance matrix of the best-fit parameters from the fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.dof">
<code class="descname">dof</code><a class="headerlink" href="#lsqfit.nonlinear_fit.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of degrees of freedom in the fit, which equals the number of
pieces of data being fit when priors are specified for the fit
parameters. Without priors, it is the number of pieces of data minus
the number of fit parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.logGBF">
<code class="descname">logGBF</code><a class="headerlink" href="#lsqfit.nonlinear_fit.logGBF" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm of the probability (density) of obtaining
the fit data by randomly sampling the parameter model
(priors plus fit function) used in the fit. This quantity is
useful for comparing fits of the same data to different models,
with different priors and/or fit functions. The model with the
largest value of <code class="docutils literal"><span class="pre">fit.logGBF</span></code> is the one prefered by the data.
The exponential of the difference in <code class="docutils literal"><span class="pre">fit.logGBF</span></code> between two models
is the ratio of probabilities (Bayes factor) for those models. Differences
in <code class="docutils literal"><span class="pre">fit.logGBF</span></code> smaller than 1 are not very significant. Gaussian
statistics are assumed when computing <code class="docutils literal"><span class="pre">fit.logGBF</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.p">
<code class="descname">p</code><a class="headerlink" href="#lsqfit.nonlinear_fit.p" title="Permalink to this definition">¶</a></dt>
<dd><p>Best-fit parameters from fit. Depending upon what was used for
the prior (or <code class="docutils literal"><span class="pre">p0</span></code>), it is either: a dictionary
(<code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code>) of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s and/or arrays of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s; or
an array (<code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code>) of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s. <code class="docutils literal"><span class="pre">fit.p</span></code> represents a
multi-dimensional Gaussian distribution which, in Bayesian terminology,
is the <em>posterior</em> probability distribution of the fit parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.pmean">
<code class="descname">pmean</code><a class="headerlink" href="#lsqfit.nonlinear_fit.pmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Means of the best-fit parameters from fit (dictionary or array).</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.psdev">
<code class="descname">psdev</code><a class="headerlink" href="#lsqfit.nonlinear_fit.psdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard deviations of the best-fit parameters from fit
(dictionary or array).</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.palt">
<code class="descname">palt</code><a class="headerlink" href="#lsqfit.nonlinear_fit.palt" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">fit.p</span></code> except that the errors are computed directly
from <code class="docutils literal"><span class="pre">fit.cov</span></code>. This is faster but means that no information about
correlations with the input data is retained (unlike in <code class="docutils literal"><span class="pre">fit.p</span></code>);
and, therefore, <code class="docutils literal"><span class="pre">fit.palt</span></code> cannot be used to generate error
budgets. <code class="docutils literal"><span class="pre">fit.p</span></code> and <code class="docutils literal"><span class="pre">fit.palt</span></code> give the same means and normally
give the same errors for each parameter. They differ only when the
input data&#8217;s covariance matrix is too singular to invert accurately
(because of roundoff error), in which case an SVD cut is advisable.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.p0">
<code class="descname">p0</code><a class="headerlink" href="#lsqfit.nonlinear_fit.p0" title="Permalink to this definition">¶</a></dt>
<dd><p>The parameter values used to start the fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.Q">
<code class="descname">Q</code><a class="headerlink" href="#lsqfit.nonlinear_fit.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>The probability that the <code class="docutils literal"><span class="pre">chi**2</span></code> from the fit could have been
larger, by chance, assuming the best-fit model is correct. Good fits have
<code class="docutils literal"><span class="pre">Q</span></code> values larger than 0.1 or so. Also called the <em>p-value</em> of
the fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.svdcorrection">
<code class="descname">svdcorrection</code><a class="headerlink" href="#lsqfit.nonlinear_fit.svdcorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>The sum of all SVD corrections, if any, added to the fit
data <code class="docutils literal"><span class="pre">y</span></code> or the prior <code class="docutils literal"><span class="pre">prior</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.svdn">
<code class="descname">svdn</code><a class="headerlink" href="#lsqfit.nonlinear_fit.svdn" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of eignemodes modified (and/or deleted) by the SVD cut.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.nblocks">
<code class="descname">nblocks</code><a class="headerlink" href="#lsqfit.nonlinear_fit.nblocks" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary where <code class="docutils literal"><span class="pre">nblocks[s]</span></code> equals the number of block-diagonal
sub-matrices of the <code class="docutils literal"><span class="pre">y</span></code>&#8211;<code class="docutils literal"><span class="pre">prior</span></code> covariance matrix that are size
<code class="docutils literal"><span class="pre">s</span></code>-by-<code class="docutils literal"><span class="pre">s</span></code>. This is sometimes useful for debugging.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.time">
<code class="descname">time</code><a class="headerlink" href="#lsqfit.nonlinear_fit.time" title="Permalink to this definition">¶</a></dt>
<dd><p>CPU time (in secs) taken by fit.</p>
</dd></dl>

<p>The input parameters to the fit can be accessed as attributes. Note
in particular attributes:</p>
<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.prior">
<code class="descname">prior</code><a class="headerlink" href="#lsqfit.nonlinear_fit.prior" title="Permalink to this definition">¶</a></dt>
<dd><p>Prior used in the fit. This may differ from the input prior if an
SVD cut is used. It is either a dictionary
(<code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code>) or an array (<code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code>),
depending upon the input. Equals <code class="docutils literal"><span class="pre">None</span></code> if no prior was specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.x">
<code class="descname">x</code><a class="headerlink" href="#lsqfit.nonlinear_fit.x" title="Permalink to this definition">¶</a></dt>
<dd><p>The first field in the input <code class="docutils literal"><span class="pre">data</span></code>. This is sometimes the
independent variable (as in &#8216;y vs x&#8217; plot), but may be anything. It
is set equal to <code class="docutils literal"><span class="pre">False</span></code> if the <code class="docutils literal"><span class="pre">x</span></code> field is omitted from the
input <code class="docutils literal"><span class="pre">data</span></code>. (This also means that the fit function has no <code class="docutils literal"><span class="pre">x</span></code>
argument: so <code class="docutils literal"><span class="pre">f(p)</span></code> rather than <code class="docutils literal"><span class="pre">f(x,p)</span></code>.)</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.y">
<code class="descname">y</code><a class="headerlink" href="#lsqfit.nonlinear_fit.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit data used in the fit. This may differ from the input data if
an SVD cut is used. It is either a dictionary
(<code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code>) or an array (<code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code>),
depending upon the input.</p>
</dd></dl>

<p>Additional methods are provided for printing out detailed information
about the fit, testing fits with simulated data,
doing bootstrap analyses of the fit errors,
dumping (for later use) and loading parameter values, and checking for roundoff
errors in the final error estimates:</p>
<dl class="method">
<dt id="lsqfit.nonlinear_fit.format">
<code class="descname">format</code><span class="sig-paren">(</span><em>maxline=0</em>, <em>pstyle='v'</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Formats fit output details into a string for printing.</p>
<p>The output tabulates the <code class="docutils literal"><span class="pre">chi**2</span></code> per degree of freedom of the fit
(<code class="docutils literal"><span class="pre">chi2/dof</span></code>), the number of degrees of freedom, the logarithm of the
Gaussian Bayes Factor for the fit (<code class="docutils literal"><span class="pre">logGBF</span></code>), and the number of fit-
algorithm iterations needed by the fit. Optionally, it will also list
the best-fit values for the fit parameters together with the prior for
each (in <code class="docutils literal"><span class="pre">[]</span></code> on each line). Lines for parameters that deviate from
their prior by more than one (prior) standard deviation are marked
with asterisks, with the number of asterisks equal to the number of
standard deviations (up to five). <code class="docutils literal"><span class="pre">format</span></code> can also list all of the
data and the corresponding values from the fit, again with asterisks
on lines  where there is a significant discrepancy. At the end it
lists the SVD cut, the number of eigenmodes modified by the SVD cut,
the tolerances used in the fit, and the time in seconds needed to do
the fit. The tolerance used to terminate the fit is marked with an
asterisk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>maxline</strong> (<em>integer or bool</em>) &#8211; Maximum number of data points for which fit
results and input data are tabulated. <code class="docutils literal"><span class="pre">maxline&lt;0</span></code> implies
that only <code class="docutils literal"><span class="pre">chi2</span></code>, <code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">logGBF</span></code>, and <code class="docutils literal"><span class="pre">itns</span></code> are
tabulated; no parameter values are included. Setting
<code class="docutils literal"><span class="pre">maxline=True</span></code> prints all data points; setting it
equal <code class="docutils literal"><span class="pre">None</span></code> or <code class="docutils literal"><span class="pre">False</span></code> is the same as setting
it equal to <code class="docutils literal"><span class="pre">-1</span></code>. Default is <code class="docutils literal"><span class="pre">maxline=0</span></code>.</li>
<li><strong>pstyle</strong> (<em>&#8216;vv&#8217;, &#8216;v&#8217;, or &#8216;m&#8217;</em>) &#8211; Style used for parameter list. Supported values are
&#8216;vv&#8217; for very verbose, &#8216;v&#8217; for verbose, and &#8216;m&#8217; for minimal.
When &#8216;m&#8217; is set, only parameters whose values differ from their
prior values are listed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">String containing detailed information about fit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.fmt_errorbudget">
<code class="descname">fmt_errorbudget</code><span class="sig-paren">(</span><em>outputs</em>, <em>inputs</em>, <em>ndecimal=2</em>, <em>percent=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.fmt_errorbudget" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulate error budget for <code class="docutils literal"><span class="pre">outputs[ko]</span></code> due to <code class="docutils literal"><span class="pre">inputs[ki]</span></code>.</p>
<p>For each output <code class="docutils literal"><span class="pre">outputs[ko]</span></code>, <code class="docutils literal"><span class="pre">fmt_errorbudget</span></code> computes the
contributions to <code class="docutils literal"><span class="pre">outputs[ko]</span></code>&#8216;s standard deviation coming from the
<code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s collected in <code class="docutils literal"><span class="pre">inputs[ki]</span></code>. This is done for each key
combination <code class="docutils literal"><span class="pre">(ko,ki)</span></code> and the results are tabulated with columns and
rows labeled by <code class="docutils literal"><span class="pre">ko</span></code> and <code class="docutils literal"><span class="pre">ki</span></code>, respectively. If a <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code> in
<code class="docutils literal"><span class="pre">inputs[ki]</span></code> is correlated with other <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s, the contribution from
the others is included in the <code class="docutils literal"><span class="pre">ki</span></code> contribution as well (since
contributions from correlated <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s cannot be distinguished). The table
is returned as a string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>outputs</strong> &#8211; Dictionary of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s for which an error budget
is computed.</li>
<li><strong>inputs</strong> &#8211; Dictionary of: <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s, arrays/dictionaries of
<code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s, or lists of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s and/or arrays/dictionaries of
<code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s. <code class="docutils literal"><span class="pre">fmt_errorbudget</span></code> tabulates the parts of the standard
deviations of each <code class="docutils literal"><span class="pre">outputs[ko]</span></code> due to each <code class="docutils literal"><span class="pre">inputs[ki]</span></code>.</li>
<li><strong>ndecimal</strong> (<code class="docutils literal"><span class="pre">int</span></code>) &#8211; Number of decimal places displayed in table.</li>
<li><strong>percent</strong> (<em>boolean</em>) &#8211; Tabulate % errors if <code class="docutils literal"><span class="pre">percent</span> <span class="pre">is</span> <span class="pre">True</span></code>; otherwise
tabulate the errors themselves.</li>
<li><strong>colwidth</strong> (<em>positive integer or None</em>) &#8211; Width of each column. This is set automatically, to
accommodate label widths, if <code class="docutils literal"><span class="pre">colwidth=None</span></code> (default).</li>
<li><strong>verify</strong> (<em>boolean</em>) &#8211; If <code class="docutils literal"><span class="pre">True</span></code>, a warning is issued if: 1) different inputs are
correlated (and therefore double count errors); or
2) the sum (in quadrature) of partial errors is not equal to the
total error to within 0.1% of the error (and the error budget is incomplete or
overcomplete). No checking is done if <code class="docutils literal"><span class="pre">verify==False</span></code> (default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A table (<code class="docutils literal"><span class="pre">str</span></code>) containing the error budget.
Output variables are labeled by the keys in <code class="docutils literal"><span class="pre">outputs</span></code>
(columns); sources of uncertainty are labeled by the keys in
<code class="docutils literal"><span class="pre">inputs</span></code> (rows).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.fmt_values">
<code class="descname">fmt_values</code><span class="sig-paren">(</span><em>outputs</em>, <em>ndecimal=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.fmt_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulate <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s in <code class="docutils literal"><span class="pre">outputs</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>outputs</strong> &#8211; A dictionary of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code> objects.</li>
<li><strong>ndecimal</strong> (<code class="docutils literal"><span class="pre">int</span></code> or <code class="docutils literal"><span class="pre">None</span></code>) &#8211; Format values <code class="docutils literal"><span class="pre">v</span></code> using <code class="docutils literal"><span class="pre">v.fmt(ndecimal)</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A table (<code class="docutils literal"><span class="pre">str</span></code>) containing values and standard
deviations for variables in <code class="docutils literal"><span class="pre">outputs</span></code>, labeled by the keys
in <code class="docutils literal"><span class="pre">outputs</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.simulated_fit_iter">
<code class="descname">simulated_fit_iter</code><span class="sig-paren">(</span><em>n=None</em>, <em>pexact=None</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.simulated_fit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that returns simulation copies of a fit.</p>
<p>Fit reliability can be tested using simulated data which
replaces the mean values in <code class="docutils literal"><span class="pre">self.y</span></code> with random numbers
drawn from a distribution whose mean equals <code class="docutils literal"><span class="pre">self.fcn(pexact)</span></code>
and whose covariance matrix is the same as <code class="docutils literal"><span class="pre">self.y</span></code>&#8216;s. Simulated
data is very similar to the original fit data, <code class="docutils literal"><span class="pre">self.y</span></code>,
but corresponds to a world where the correct values for
the parameters (<em>i.e.</em>, averaged over many simulated data
sets) are given by <code class="docutils literal"><span class="pre">pexact</span></code>. <code class="docutils literal"><span class="pre">pexact</span></code> is usually taken
equal to <code class="docutils literal"><span class="pre">fit.pmean</span></code>.</p>
<p>Each iteration of the iterator creates new simulated data,
with different random numbers, and fits it, returning the
the <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a> that results. The simulated
data has the same covariance matrix as <code class="docutils literal"><span class="pre">fit.y</span></code>.
Typical usage is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">...</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">sfit</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">simulated_fit_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">verify</span> <span class="n">that</span> <span class="n">sfit</span><span class="o">.</span><span class="n">p</span> <span class="n">agrees</span> <span class="k">with</span> <span class="n">pexact</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">pmean</span> <span class="n">within</span> <span class="n">errors</span> <span class="o">...</span>
</pre></div>
</div>
<p>Only a few iterations are needed to get a sense of the fit&#8217;s
reliability since we know the correct answer in each case. The
simulated fit&#8217;s output results should agree with <code class="docutils literal"><span class="pre">pexact</span></code>
(<code class="docutils literal"><span class="pre">=fit.pmean</span></code> here) within the simulated fit&#8217;s errors.</p>
<p>Simulated fits can also be used to estimate biases in the fit&#8217;s
output parameters or functions of them, should non-Gaussian behavior
arise. This is possible, again, because we know the correct value for
every parameter before we do the fit. Again only a few iterations
may be needed for reliable estimates.</p>
<p>The (possibly non-Gaussian) probability distributions for parameters,
or functions of them, can be explored in more detail by setting option
<code class="docutils literal"><span class="pre">bootstrap=True</span></code> and collecting results from a large number of
simulated fits. With <code class="docutils literal"><span class="pre">bootstrap=True</span></code>, the means of the priors are
also varied from fit to fit, as in a bootstrap simulation; the new
prior means are chosen at random from the prior distribution.
Variations in the best-fit parameters (or functions of them)
from fit to fit define the probability distributions for those
quantities. For example, one would use the following code to
analyze the distribution of function <code class="docutils literal"><span class="pre">g(p)</span></code> of the fit parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="o">...</span>

<span class="n">glist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">sfit</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">simulated_fit_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">glist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">sfit</span><span class="o">.</span><span class="n">pmean</span><span class="p">))</span>

<span class="o">...</span> <span class="n">analyze</span> <span class="n">samples</span> <span class="n">glist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="kn">from</span> <span class="nn">g</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">distribution</span> <span class="o">...</span>
</pre></div>
</div>
<p>This code generates <code class="docutils literal"><span class="pre">n=100</span></code> samples <code class="docutils literal"><span class="pre">glist[i]</span></code> from the
probability distribution of <code class="docutils literal"><span class="pre">g(p)</span></code>. If everything is Gaussian,
the mean and standard deviation of <code class="docutils literal"><span class="pre">glist[i]</span></code> should agree
with <code class="docutils literal"><span class="pre">g(fit.p).mean</span></code> and <code class="docutils literal"><span class="pre">g(fit.p).sdev</span></code>.</p>
<p>The only difference between simulated fits with <code class="docutils literal"><span class="pre">bootstrap=True</span></code>
and <code class="docutils literal"><span class="pre">bootstrap=False</span></code> (the default) is that the prior means are
varied. It is essential that they be varied in a bootstrap analysis
since one wants to capture the impact of the priors on the final
distributions, but it is not necessary and probably not desirable
when simply testing a fit&#8217;s reliability.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (integer or <code class="docutils literal"><span class="pre">None</span></code>) &#8211; Maximum number of iterations (equals infinity if <code class="docutils literal"><span class="pre">None</span></code>).</li>
<li><strong>pexact</strong> (<code class="docutils literal"><span class="pre">None</span></code> or array or dictionary of numbers) &#8211; Fit-parameter values for the underlying distribution
used to generate simulated data; replaced by <code class="docutils literal"><span class="pre">self.pmean</span></code> if
is <code class="docutils literal"><span class="pre">None</span></code> (default).</li>
<li><strong>bootstrap</strong> (<em>bool</em>) &#8211; Vary prior means if <code class="docutils literal"><span class="pre">True</span></code>; otherwise vary only
the means in <code class="docutils literal"><span class="pre">self.y</span></code> (default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator that returns <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a>s
for different simulated data.</p>
</td>
</tr>
</tbody>
</table>
<p>Note that additional keywords can be added to overwrite keyword
arguments in <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.bootstrap_iter">
<code class="descname">bootstrap_iter</code><span class="sig-paren">(</span><em>n=None</em>, <em>datalist=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.bootstrap_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that returns bootstrap copies of a fit.</p>
<p>A bootstrap analysis involves three steps: 1) make a large number
of &#8220;bootstrap copies&#8221; of the original input data and prior that differ
from each other by random amounts characteristic of the underlying
randomness in the original data; 2) repeat the entire fit analysis
for each bootstrap copy of the data, extracting fit results from
each; and 3) use the variation of the fit results from bootstrap
copy to bootstrap copy to determine an approximate probability
distribution (possibly non-gaussian) for the fit parameters and/or
functions of them: the results from each bootstrap fit are samples
from that distribution.</p>
<p>Bootstrap copies of the data for step 2 are provided in
<code class="docutils literal"><span class="pre">datalist</span></code>. If <code class="docutils literal"><span class="pre">datalist</span></code> is <code class="docutils literal"><span class="pre">None</span></code>, they are generated
instead from the means and covariance matrix of the fit data
(assuming gaussian statistics). The maximum number of bootstrap
copies considered is specified by <code class="docutils literal"><span class="pre">n</span></code> (<code class="docutils literal"><span class="pre">None</span></code> implies no
limit).</p>
<p>Variations in the best-fit parameters (or functions of them)
from bootstrap fit to bootstrap fit define the probability
distributions for those quantities. For example, one could use the
following code to analyze the distribution of function <code class="docutils literal"><span class="pre">g(p)</span></code>
of the fit parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="o">...</span>

<span class="n">glist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">sfit</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">bootstrapped_fit_iter</span><span class="p">(</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">datalist</span><span class="o">=</span><span class="n">datalist</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="bp">True</span>
    <span class="p">):</span>
    <span class="n">glist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">sfit</span><span class="o">.</span><span class="n">pmean</span><span class="p">))</span>

<span class="o">...</span> <span class="n">analyze</span> <span class="n">samples</span> <span class="n">glist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="kn">from</span> <span class="nn">g</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">distribution</span> <span class="o">...</span>
</pre></div>
</div>
<p>This code generates <code class="docutils literal"><span class="pre">n=100</span></code> samples <code class="docutils literal"><span class="pre">glist[i]</span></code> from the
probability distribution of <code class="docutils literal"><span class="pre">g(p)</span></code>. If everything is Gaussian,
the mean and standard deviation of <code class="docutils literal"><span class="pre">glist[i]</span></code> should agree
with <code class="docutils literal"><span class="pre">g(fit.p).mean</span></code> and <code class="docutils literal"><span class="pre">g(fit.p).sdev</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>integer</em>) &#8211; Maximum number of iterations if <code class="docutils literal"><span class="pre">n</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>;
otherwise there is no maximum.</li>
<li><strong>datalist</strong> (sequence or iterator or <code class="docutils literal"><span class="pre">None</span></code>) &#8211; Collection of bootstrap <code class="docutils literal"><span class="pre">data</span></code> sets for fitter.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Iterator that returns an <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a> object
containing results from the fit to the next data set in
<code class="docutils literal"><span class="pre">datalist</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.dump_p">
<code class="descname">dump_p</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.dump_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump parameter values (<code class="docutils literal"><span class="pre">fit.p</span></code>) into file <code class="docutils literal"><span class="pre">filename</span></code>.</p>
<p><code class="docutils literal"><span class="pre">fit.dump_p(filename)</span></code> saves the best-fit parameter values
(<code class="docutils literal"><span class="pre">fit.p</span></code>) from a <code class="docutils literal"><span class="pre">nonlinear_fit</span></code> called <code class="docutils literal"><span class="pre">fit</span></code>. These values
are recovered using
<code class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">nonlinear_fit.load_parameters(filename)</span></code>
where <code class="docutils literal"><span class="pre">p</span></code>&#8216;s layout is the same as that of <code class="docutils literal"><span class="pre">fit.p</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.dump_pmean">
<code class="descname">dump_pmean</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.dump_pmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump parameter means (<code class="docutils literal"><span class="pre">fit.pmean</span></code>) into file <code class="docutils literal"><span class="pre">filename</span></code>.</p>
<p><code class="docutils literal"><span class="pre">fit.dump_pmean(filename)</span></code> saves the means of the best-fit
parameter values (<code class="docutils literal"><span class="pre">fit.pmean</span></code>) from a <code class="docutils literal"><span class="pre">nonlinear_fit</span></code> called
<code class="docutils literal"><span class="pre">fit</span></code>. These values are recovered using
<code class="docutils literal"><span class="pre">p0</span> <span class="pre">=</span> <span class="pre">nonlinear_fit.load_parameters(filename)</span></code>
where <code class="docutils literal"><span class="pre">p0</span></code>&#8216;s layout is the same as <code class="docutils literal"><span class="pre">fit.pmean</span></code>. The saved
values can be used to initialize a later fit (<code class="docutils literal"><span class="pre">nonlinear_fit</span></code>
parameter <code class="docutils literal"><span class="pre">p0</span></code>).</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lsqfit.nonlinear_fit.load_parameters">
<em class="property">static </em><code class="descname">load_parameters</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.load_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Load parameters stored in file <code class="docutils literal"><span class="pre">filename</span></code>.</p>
<p><code class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">nonlinear_fit.load_p(filename)</span></code> is used to recover the
values of fit parameters dumped using <code class="docutils literal"><span class="pre">fit.dump_p(filename)</span></code> (or
<code class="docutils literal"><span class="pre">fit.dump_pmean(filename)</span></code>) where <code class="docutils literal"><span class="pre">fit</span></code> is of type
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a>. The layout of the returned
parameters <code class="docutils literal"><span class="pre">p</span></code> is the same as that of <code class="docutils literal"><span class="pre">fit.p</span></code> (or
<code class="docutils literal"><span class="pre">fit.pmean</span></code>).</p>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.check_roundoff">
<code class="descname">check_roundoff</code><span class="sig-paren">(</span><em>rtol=0.25</em>, <em>atol=1e-6</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.check_roundoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for roundoff errors in fit.p.</p>
<p>Compares standard deviations from fit.p and fit.palt to see if they
agree to within relative tolerance <code class="docutils literal"><span class="pre">rtol</span></code> and absolute tolerance
<code class="docutils literal"><span class="pre">atol</span></code>. Generates a warning if they do not (in which
case an <em>svd</em> cut might be advisable).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="lsqfit.empbayes_fit">
<code class="descclassname">lsqfit.</code><code class="descname">empbayes_fit</code><span class="sig-paren">(</span><em>z0</em>, <em>fitargs</em>, <em>**minargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.empbayes_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Call <code class="docutils literal"><span class="pre">lsqfit.nonlinear_fit(**fitargs(z))</span></code> varying <code class="docutils literal"><span class="pre">z</span></code>,
starting at <code class="docutils literal"><span class="pre">z0</span></code>, to maximize <code class="docutils literal"><span class="pre">logGBF</span></code> (empirical Bayes procedure).</p>
<p>The fit is redone for each value of <code class="docutils literal"><span class="pre">z</span></code> that is tried, in order
to determine <code class="docutils literal"><span class="pre">logGBF</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z0</strong> (<em>array</em>) &#8211; Starting point for search.</li>
<li><strong>fitargs</strong> (<em>function</em>) &#8211; Function of array <code class="docutils literal"><span class="pre">z</span></code> that determines which fit
parameters to use. The function returns these as an argument
dictionary for <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-func docutils literal"><span class="pre">lsqfit.nonlinear_fit()</span></code></a>.</li>
<li><strong>minargs</strong> (<em>dictionary</em>) &#8211; Optional argument dictionary, passed on to
<a class="reference internal" href="#lsqfit.multiminex" title="lsqfit.multiminex"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.multiminex</span></code></a>, which finds the minimum.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple containing the best fit (object of type
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a>) and the optimal value for parameter <code class="docutils literal"><span class="pre">z</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lsqfit.wavg">
<code class="descclassname">lsqfit.</code><code class="descname">wavg</code><span class="sig-paren">(</span><em>dataseq</em>, <em>prior=None</em>, <em>fast=False</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.wavg" title="Permalink to this definition">¶</a></dt>
<dd><p>Weighted average of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s or arrays/dicts of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s.</p>
<p>The weighted average of several <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s is what one obtains from
a  least-squares fit of the collection of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s to the
one-parameter fit function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">N</span></code> is the number of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s. The average is the best-fit
value for <code class="docutils literal"><span class="pre">p[0]</span></code>.  <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s with smaller standard deviations carry
more weight than those with larger standard deviations. The averages
computed by <code class="docutils literal"><span class="pre">wavg</span></code> take account of correlations between the <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s.</p>
<p>If <code class="docutils literal"><span class="pre">prior</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>, it is added to the list of data
used in the average. Thus <code class="docutils literal"><span class="pre">wavg([x2,</span> <span class="pre">x3],</span> <span class="pre">prior=x1)</span></code> is the
same as <code class="docutils literal"><span class="pre">wavg([x1,</span> <span class="pre">x2,</span> <span class="pre">x3])</span></code>.</p>
<p>Typical usage is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x1</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">x3</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">xavg</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">])</span>   <span class="c"># weighted average of x1, x2 and x3</span>
</pre></div>
</div>
<p>where the result <code class="docutils literal"><span class="pre">xavg</span></code> is a <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code> containing the weighted average.</p>
<p>The individual <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s in the last example can be  replaced by
multidimensional distributions, represented by arrays of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s
or dictionaries of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s (or arrays of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s). For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x1</span> <span class="o">=</span> <span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)]</span>
<span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)]</span>
<span class="n">x3</span> <span class="o">=</span> <span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)]</span>
<span class="n">xavg</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">])</span>
    <span class="c"># xavg[i] is wgtd avg of x1[i], x2[i], x3[i]</span>
</pre></div>
</div>
<p>where each array <code class="docutils literal"><span class="pre">x1</span></code>, <code class="docutils literal"><span class="pre">x2</span></code> ... must have the same shape.
The result <code class="docutils literal"><span class="pre">xavg</span></code> in this case is an array of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s, where
the shape of the array is the same as that of <code class="docutils literal"><span class="pre">x1</span></code>, etc.</p>
<p>Another example is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)],</span> <span class="n">b</span><span class="o">=</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">x2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)],</span> <span class="n">b</span><span class="o">=</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">x3</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)])</span>
<span class="n">xavg</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">])</span>
    <span class="c"># xavg[&#39;a&#39;][i] is wgtd avg of x1[&#39;a&#39;][i], x2[&#39;a&#39;][i], x3[&#39;a&#39;][i]</span>
    <span class="c"># xavg[&#39;b&#39;] is gtd avg of x1[&#39;b&#39;], x2[&#39;b&#39;]</span>
</pre></div>
</div>
<p>where different dictionaries can have (some) different keys. Here the
result <code class="docutils literal"><span class="pre">xavg</span></code> is a <code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict`</span></code> having the same keys as
<code class="docutils literal"><span class="pre">x1</span></code>, etc.</p>
<p>Weighted averages can become costly when the number of random samples being
averaged is large (100s or more). In such cases it might be useful to set
parameter <code class="docutils literal"><span class="pre">fast=True</span></code>. This causes <code class="docutils literal"><span class="pre">wavg</span></code> to estimate the weighted
average by incorporating the random samples one at a time into a
running average:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="n">prior</span>
<span class="k">for</span> <span class="n">dataseq_i</span> <span class="ow">in</span> <span class="n">dataseq</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">result</span><span class="p">,</span> <span class="n">dataseq_i</span><span class="p">],</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>This method is much faster when <code class="docutils literal"><span class="pre">len(dataseq)</span></code> is large, and gives the
exact result when there are no correlations between different elements
of list <code class="docutils literal"><span class="pre">dataseq</span></code>. The results are approximately correct when
<code class="docutils literal"><span class="pre">dataseq[i]</span></code> and <code class="docutils literal"><span class="pre">dataseq[j]</span></code> are correlated for <code class="docutils literal"><span class="pre">i!=j</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dataseq</strong> &#8211; The <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s to be averaged. <code class="docutils literal"><span class="pre">dataseq</span></code> is a one-dimensional
sequence of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s, or of arrays of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s, or of dictionaries
containing <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s or arrays of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s. All <code class="docutils literal"><span class="pre">dataseq[i]</span></code> must
have the same shape.</li>
<li><strong>prior</strong> (<code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code> or array/dictionary of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s) &#8211; Prior values for the averages, to be included in the weighted
average. Default value is <code class="docutils literal"><span class="pre">None</span></code>, in which case <code class="docutils literal"><span class="pre">prior</span></code> is ignored.</li>
<li><strong>fast</strong> (<em>bool</em>) &#8211; Setting <code class="docutils literal"><span class="pre">fast=True</span></code> causes <code class="docutils literal"><span class="pre">wavg</span></code> to compute an
approximation to the weighted average that is much faster to calculate
when averaging a large number of samples (100s or more). The default is
<code class="docutils literal"><span class="pre">fast=False</span></code>.</li>
<li><strong>kargs</strong> (<em>dict</em>) &#8211; Additional arguments (e.g., <code class="docutils literal"><span class="pre">svdcut</span></code>) to the fitter
used to do the averaging.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Results returned by <code class="xref py py-func docutils literal"><span class="pre">gvar.wavg()</span></code> have the following extra
attributes describing the average:</p>
<dl class="attribute">
<dt id="lsqfit.chi2">
<code class="descclassname">lsqfit.</code><code class="descname">chi2</code><a class="headerlink" href="#lsqfit.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">chi**2</span></code> for weighted average.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.dof">
<code class="descclassname">lsqfit.</code><code class="descname">dof</code><a class="headerlink" href="#lsqfit.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Effective number of degrees of freedom.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.Q">
<code class="descclassname">lsqfit.</code><code class="descname">Q</code><a class="headerlink" href="#lsqfit.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>The probability that the <code class="docutils literal"><span class="pre">chi**2</span></code> could have been larger,
by chance, assuming that the data are all Gaussain and consistent
with each other. Values smaller than 0.1 or suggest that the
data are not Gaussian or are inconsistent with each other. Also
called the <em>p-value</em>.</p>
<p>Quality factor <cite>Q</cite> (or <em>p-value</em>) for fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.time">
<code class="descclassname">lsqfit.</code><code class="descname">time</code><a class="headerlink" href="#lsqfit.time" title="Permalink to this definition">¶</a></dt>
<dd><p>Time required to do average.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.svdcorrection">
<code class="descclassname">lsqfit.</code><code class="descname">svdcorrection</code><a class="headerlink" href="#lsqfit.svdcorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>The <em>svd</em> corrections made to the data when <code class="docutils literal"><span class="pre">svdcut</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.fit">
<code class="descclassname">lsqfit.</code><code class="descname">fit</code><a class="headerlink" href="#lsqfit.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit output from average.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lsqfit.gammaQ">
<code class="descclassname">lsqfit.</code><code class="descname">gammaQ</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.gammaQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized incomplete gamma function <code class="docutils literal"><span class="pre">Q(a,x)</span> <span class="pre">=</span> <span class="pre">1-P(a,x)</span></code>.</p>
<p><code class="docutils literal"><span class="pre">Q(a,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">1/Gamma(a)</span> <span class="pre">*</span> <span class="pre">\int_x^\infty</span> <span class="pre">dt</span> <span class="pre">exp(-t)</span> <span class="pre">t</span> <span class="pre">**</span> <span class="pre">(a-1)</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">P(a,</span> <span class="pre">x)</span></code></p>
<p>Note that <code class="docutils literal"><span class="pre">gammaQ(ndof/2.,</span> <span class="pre">chi2/2.)</span></code> is the probabilty that one could
get a <code class="docutils literal"><span class="pre">chi**2</span></code> larger than <code class="docutils literal"><span class="pre">chi2</span></code> with <code class="docutils literal"><span class="pre">ndof</span></code> degrees
of freedom even if the model used to construct <code class="docutils literal"><span class="pre">chi2</span></code> is correct.</p>
</dd></dl>

<dl class="function">
<dt id="gvar.add_parameter_distribution">
<code class="descclassname">gvar.</code><code class="descname">add_parameter_distribution</code><span class="sig-paren">(</span><em>name</em>, <em>invfcn</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.add_parameter_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new parameter distribution for use in fits.</p>
<p>This function adds new distributions for the parameters used in
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code></a>. For example, the code</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>
<span class="n">gv</span><span class="o">.</span><span class="n">add_parameter_distribution</span><span class="p">(</span><span class="s">&#39;log&#39;</span><span class="p">,</span> <span class="n">gv</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
</pre></div>
</div>
<p>enables the use of log-normal distributions for parameters. The log-normal
distribution is invoked for a parameter <code class="docutils literal"><span class="pre">p</span></code> by including <code class="docutils literal"><span class="pre">log(p)</span></code>
rather than <code class="docutils literal"><span class="pre">p</span></code> itself in the fit prior. log-normal, sqrt-normal,  and
erfinv-normal distributions are included by default. (Setting  a prior
<code class="docutils literal"><span class="pre">prior[erfinv(w)]</span></code> equal to <code class="docutils literal"><span class="pre">gv.gvar('0(1)')</span> <span class="pre">/</span> <span class="pre">gv.sqrt(2)</span></code>  means that
the prior probability for <code class="docutils literal"><span class="pre">w</span></code> is distributed uniformly between -1 and 1,
and is zero elsewhere.)</p>
<p>These distributions are implemented by replacing a fit parameter <code class="docutils literal"><span class="pre">p</span></code>
by a new fit parameter <code class="docutils literal"><span class="pre">fcn(p)</span></code> where <code class="docutils literal"><span class="pre">fcn</span></code> is some function. <code class="docutils literal"><span class="pre">fcn(p)</span></code>
is assumed to have a Gaussian distribution, and parameter <code class="docutils literal"><span class="pre">p</span></code> is
recovered using the inverse function <code class="docutils literal"><span class="pre">invfcn</span></code> where <code class="docutils literal"><span class="pre">p=invfcn(fcn(p))</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; Distribution&#8217;s name.</li>
<li><strong>invfcn</strong> &#8211; Inverse of the transformation function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gvar.del_parameter_distribution">
<code class="descclassname">gvar.</code><code class="descname">del_parameter_distribution</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.del_parameter_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete parameter distribution <code class="docutils literal"><span class="pre">name</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="gvar.add_parameter_parentheses">
<code class="descclassname">gvar.</code><code class="descname">add_parameter_parentheses</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.add_parameter_parentheses" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary with proper keys for parameter distributions (legacy code).</p>
<p>This utility function helps fix legacy code that uses
parameter keys like <code class="docutils literal"><span class="pre">logp</span></code> or <code class="docutils literal"><span class="pre">sqrtp</span></code> instead of
<code class="docutils literal"><span class="pre">log(p)</span></code> or <code class="docutils literal"><span class="pre">sqrt(p)</span></code>, as now required. This method creates a
copy of  dictionary <code class="docutils literal"><span class="pre">p''</span> <span class="pre">but</span> <span class="pre">with</span> <span class="pre">keys</span> <span class="pre">like</span> <span class="pre">``logp</span></code> or <code class="docutils literal"><span class="pre">sqrtp</span></code>
replaced by <code class="docutils literal"><span class="pre">log(p)</span></code> or <code class="docutils literal"><span class="pre">sqrt(p)</span></code>. So setting</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">add_parameter_parentheses</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>fixes the keys in <code class="docutils literal"><span class="pre">p</span></code> for log-normal and sqrt-normal parameters.</p>
</dd></dl>

</div>
<div class="section" id="classes-for-bayesian-integrals">
<h2>Classes for Bayesian Integrals<a class="headerlink" href="#classes-for-bayesian-integrals" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lsqfit.BayesPDF">
<em class="property">class </em><code class="descclassname">lsqfit.</code><code class="descname">BayesPDF</code><span class="sig-paren">(</span><em>fit</em>, <em>svdcut=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.BayesPDF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bayesian probability density function corresponding to <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">nonlinear_fit</span></code></a> <code class="docutils literal"><span class="pre">fit</span></code>.</p>
<p>The probability density function is the exponential of
<code class="docutils literal"><span class="pre">-1/2</span></code> times the <code class="docutils literal"><span class="pre">chi**2</span></code> function (data and priors) used
in <code class="docutils literal"><span class="pre">fit</span></code> divided by <code class="docutils literal"><span class="pre">norm</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fit</strong> &#8211; Fit from <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">nonlinear_fit</span></code></a>.</li>
<li><strong>svdcut</strong> (<em>non-negative float or None</em>) &#8211; If not <code class="docutils literal"><span class="pre">None</span></code>, replace
covariance matrix of <code class="docutils literal"><span class="pre">g</span></code> with a new matrix whose
small eigenvalues are modified: eigenvalues smaller than
<code class="docutils literal"><span class="pre">svdcut</span></code> times the maximum eigenvalue <code class="docutils literal"><span class="pre">eig_max</span></code> are
replaced by <code class="docutils literal"><span class="pre">svdcut*eig_max</span></code>. This can ameliorate
problems caused by roundoff errors when inverting the
covariance matrix. It increases the uncertainty associated
with the modified eigenvalues and so is conservative.
Setting <code class="docutils literal"><span class="pre">svdcut=None</span></code> or <code class="docutils literal"><span class="pre">svdcut=0</span></code> leaves the
covariance matrix unchanged. Default is <code class="docutils literal"><span class="pre">1e-15</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lsqfit.BayesPDF.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.BayesPDF.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Probability density function evaluated at <code class="docutils literal"><span class="pre">p</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lsqfit.BayesPDF.logpdf">
<code class="descname">logpdf</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.BayesPDF.logpdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithm of the probability density function evaluated at <code class="docutils literal"><span class="pre">p</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lsqfit.BayesIntegrator">
<em class="property">class </em><code class="descclassname">lsqfit.</code><code class="descname">BayesIntegrator</code><span class="sig-paren">(</span><em>fit</em>, <em>limit=1e15</em>, <em>scale=1</em>, <em>pdf=None</em>, <em>svdcut=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.BayesIntegrator" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-mod docutils literal"><span class="pre">vegas</span></code> integrator for Bayesian fit integrals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fit</strong> &#8211; Fit from <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">nonlinear_fit</span></code></a>.</li>
<li><strong>limit</strong> (<em>positive float</em>) &#8211; Limits the integrations to a finite
region of size <code class="docutils literal"><span class="pre">limit</span></code> times the standard deviation on
either side of the mean. This can be useful if the
functions being integrated misbehave for large parameter
values (e.g., <code class="docutils literal"><span class="pre">numpy.exp</span></code> overflows for a large range of
arguments). Default is <code class="docutils literal"><span class="pre">1e15</span></code>.</li>
<li><strong>scale</strong> (<em>positive float</em>) &#8211; The integration variables are
rescaled to emphasize parameter values of order
<code class="docutils literal"><span class="pre">scale</span></code> times the corresponding standard deviations.
The rescaling does not change the value of the integral but it
can reduce uncertainties in the <code class="xref py py-mod docutils literal"><span class="pre">vegas</span></code> estimates.
Default is <code class="docutils literal"><span class="pre">1.0</span></code>.</li>
<li><strong>pdf</strong> (<em>function</em>) &#8211; Probability density function <code class="docutils literal"><span class="pre">pdf(p)</span></code> of the
fit parameters to use in place of the normal PDF associated
with the least-squares fit used to create the integrator.</li>
<li><strong>svdcut</strong> (<em>non-negative float or None</em>) &#8211; If not <code class="docutils literal"><span class="pre">None</span></code>, replace
covariance matrix of <code class="docutils literal"><span class="pre">g</span></code> with a new matrix whose
small eigenvalues are modified: eigenvalues smaller than
<code class="docutils literal"><span class="pre">svdcut</span></code> times the maximum eigenvalue <code class="docutils literal"><span class="pre">eig_max</span></code> are
replaced by <code class="docutils literal"><span class="pre">svdcut*eig_max</span></code>. This can ameliorate
problems caused by roundoff errors when inverting the
covariance matrix. It increases the uncertainty associated
with the modified eigenvalues and so is conservative.
Setting <code class="docutils literal"><span class="pre">svdcut=None</span></code> or <code class="docutils literal"><span class="pre">svdcut=0</span></code> leaves the
covariance matrix unchanged. Default is <code class="docutils literal"><span class="pre">1e-15</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">BayesIntegrator(fit)</span></code> is a <code class="xref py py-mod docutils literal"><span class="pre">vegas</span></code> integrator that evaluates
expectation values for the multi-dimensional Bayesian distribution
associated with <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">nonlinear_fit</span></code></a> <code class="docutils literal"><span class="pre">fit</span></code>: the probability
density function is the exponential of the <code class="docutils literal"><span class="pre">chi**2</span></code> function
(times <code class="docutils literal"><span class="pre">-1/2</span></code>), for data and priors, used in the fit.
For linear fits, it is equivalent to <code class="docutils literal"><span class="pre">gvar.PDFIntegrator(fit.p)</span></code>,
since the <code class="docutils literal"><span class="pre">chi**2</span></code> function is  quadratic in the fit parameters;
but they can differ significantly for nonlinear fits.</p>
<p><code class="docutils literal"><span class="pre">BayesIntegrator</span></code> integrates over the entire parameter space but
first reexpresses the integrals in terms of variables that
diagonalize the covariance matrix of the best-fit parameters
<code class="docutils literal"><span class="pre">fit.p</span></code> from <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">nonlinear_fit</span></code></a> and are centered at the
best-fit values. This greatly facilitates the integration using
<code class="xref py py-mod docutils literal"><span class="pre">vegas</span></code>, making integrals over 10s or more of parameters feasible.
(The <code class="xref py py-mod docutils literal"><span class="pre">vegas</span></code> module must be installed separately in order
to use <code class="docutils literal"><span class="pre">BayesIntegrator</span></code>.)</p>
<p>A simple illustration of <code class="docutils literal"><span class="pre">BayesIntegrator</span></code> is given by the following
code, which we use to evaluate the mean and standard deviation for
<code class="docutils literal"><span class="pre">s*g</span></code> where <code class="docutils literal"><span class="pre">s</span></code> and <code class="docutils literal"><span class="pre">g</span></code> are fit parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">lsqfit</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c"># least-squares fit</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="s">&#39;1.2(1.0)&#39;</span><span class="p">,</span> <span class="s">&#39;2.4(1)&#39;</span><span class="p">,</span> <span class="s">&#39;2.0(1.2)&#39;</span><span class="p">,</span> <span class="s">&#39;5.2(3.2)&#39;</span><span class="p">])</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s">&#39;0(5)&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s">&#39;0(2)&#39;</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="s">&#39;2(2)&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="s">&#39;s&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="n">p</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">]</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">fcn</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>

<span class="c"># Bayesian integral to evaluate expectation value of s*g</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">sg</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s">&#39;s&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>

<span class="n">expval</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">BayesIntegrator</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mf">20.</span><span class="p">)</span>
<span class="n">warmup</span> <span class="o">=</span> <span class="n">expval</span><span class="p">(</span><span class="n">neval</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">expval</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;results =&#39;</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
<span class="n">sg</span><span class="p">,</span> <span class="n">sg2</span> <span class="o">=</span> <span class="n">results</span>
<span class="n">sg_sdev</span> <span class="o">=</span> <span class="p">(</span><span class="n">sg2</span> <span class="o">-</span> <span class="n">sg</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;s*g from Bayes integral:  mean =&#39;</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="s">&#39;  sdev =&#39;</span><span class="p">,</span> <span class="n">sg_sdev</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;s*g from fit:&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;s&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>where the <code class="docutils literal"><span class="pre">warmup</span></code> calls to the integrator are used to adapt it to
probability density function from the fit, and then the integrator
is used to evaluate the expectation value of <code class="docutils literal"><span class="pre">g(p)</span></code>, which is
returned in array <code class="docutils literal"><span class="pre">results</span></code>.  Here <code class="docutils literal"><span class="pre">neval</span></code> is the (approximate)
number of function calls per iteration of the <code class="xref py py-mod docutils literal"><span class="pre">vegas</span></code> algorithm
and <code class="docutils literal"><span class="pre">nitn</span></code> is the number of iterations. We use the integrator to
calculated the expectation value of <code class="docutils literal"><span class="pre">s*g</span></code> and <code class="docutils literal"><span class="pre">(s*g)**2</span></code> so we can
compute a mean and standard deviation.</p>
<p>The output from this code shows that the Gaussian approximation
for <code class="docutils literal"><span class="pre">s*g</span></code> (0.76(66)) is somewhat different from the result
obtained from a Bayesian integral (0.48(54)):</p>
<div class="highlight-python"><div class="highlight"><pre>Least Square Fit:
  chi2/dof [dof] = 0.32 [4]    Q = 0.87    logGBF = -9.2027

Parameters:
              a    1.61 (90)     [  0.0 (5.0) ]
              s    0.62 (81)     [  0.0 (2.0) ]
              g    1.2 (1.1)     [  2.0 (2.0) ]

Settings:
  svdcut/n = 1e-15/0    reltol/abstol = 0.0001/0*    (itns/time = 10/0.0)

itn   integral        average         chi2/dof        Q
-------------------------------------------------------
  1   1.034(21)       1.034(21)           0.00     1.00
  2   1.034(21)       1.034(15)           0.56     0.64
  3   1.024(18)       1.030(12)           0.37     0.90
  4   1.010(18)       1.0254(98)          0.47     0.89
  5   1.005(17)       1.0213(85)          0.55     0.88
  6   1.013(19)       1.0199(78)          0.69     0.80
  7   0.987(16)       1.0152(70)          0.78     0.72
  8   1.002(18)       1.0135(66)          0.90     0.59
  9   1.036(20)       1.0160(62)          0.86     0.66
 10   1.060(20)       1.0204(60)          0.94     0.55

results = [0.4837(32) 0.5259(47)]

s*g from Bayes integral:  mean = 0.4837(32)   sdev = 0.5403(25)
s*g from fit: 0.78(66)
</pre></div>
</div>
<p>The table shows estimates of the probability density function&#8217;s
normalization from each of the <code class="xref py py-mod docutils literal"><span class="pre">vegas</span></code> iterations used
by the integrator to estimate the final results.</p>
<p>In general functions being integrated can return a number, or an array
of numbers, or a dictionary whose values are numbers or arrays of
numbers. This allows multiple expectation values to be evaluated
simultaneously.</p>
<p>See the documentation with the <code class="xref py py-mod docutils literal"><span class="pre">vegas</span></code> module for more details on
its use, and on the attributes and methods associated with
integrators. The example above sets <code class="docutils literal"><span class="pre">adapt=False</span></code> when  computing
final results. This gives more reliable error estimates  when
<code class="docutils literal"><span class="pre">neval</span></code> is small. Note that <code class="docutils literal"><span class="pre">neval</span></code> may need to be much larger
(tens or hundreds of thousands) for more difficult high-dimension
integrals.</p>
<dl class="method">
<dt id="lsqfit.BayesIntegrator.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>f=None</em>, <em>mpi=False</em>, <em>pdf=None</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.BayesIntegrator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate expectation value of function <code class="docutils literal"><span class="pre">f(p)</span></code>.</p>
<p>Uses multi-dimensional integration modules <code class="xref py py-mod docutils literal"><span class="pre">vegas</span></code>  to
estimate the expectation value of <code class="docutils literal"><span class="pre">f(p)</span></code> with  respect to
the probability density function  associated with
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal"><span class="pre">nonlinear_fit</span></code></a> <code class="docutils literal"><span class="pre">fit</span></code>. Setting <code class="docutils literal"><span class="pre">mpi=True</span></code>
configures vegas for multi-processor running using MPI.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> (<em>function</em>) &#8211; Function <code class="docutils literal"><span class="pre">f(p)</span></code> to integrate. Integral is
the expectation value of the function with respect
to the distribution. The function can return a number,
an array of numbers, or a dictionary whose values are
numbers or arrays of numbers.</li>
<li><strong>mpi</strong> (<em>bool</em>) &#8211; <p>If <code class="docutils literal"><span class="pre">True</span></code> configure for use with multiple processors
and MPI. This option requires module <code class="xref py py-mod docutils literal"><span class="pre">mpi4py</span></code>. A
script <code class="docutils literal"><span class="pre">xxx.py</span></code> using an MPI integrator is run
with <code class="docutils literal"><span class="pre">mpirun</span></code>: e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre>mpirun -np 4 -output-filename xxx.out python xxx.py
</pre></div>
</div>
<p>runs on 4 processors. Setting <code class="docutils literal"><span class="pre">mpi=False</span></code> (default) does
not support multiple processors. The MPI processor
rank can be obtained from the <code class="docutils literal"><span class="pre">mpi_rank</span></code>
attribute of the integrator.</p>
</li>
<li><strong>pdf</strong> (<em>function</em>) &#8211; Probability density function <code class="docutils literal"><span class="pre">pdf(p)</span></code> of the
fit parameters to use in place of the normal PDF associated
with the least-squares fit used to create the integrator.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>All other keyword arguments are passed on to a <code class="xref py py-mod docutils literal"><span class="pre">vegas</span></code>
integrator; see the <code class="xref py py-mod docutils literal"><span class="pre">vegas</span></code> documentation for further
information.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="other-classes">
<h2>Other Classes<a class="headerlink" href="#other-classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lsqfit.multifit">
<em class="property">class </em><code class="descclassname">lsqfit.</code><code class="descname">multifit</code><span class="sig-paren">(</span><em>x0</em>, <em>n</em>, <em>f</em>, <em>tol=1e-4</em>, <em>maxit=1000</em>, <em>alg='lmsder'</em>, <em>analyzer=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.multifit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fitter for nonlinear least-squares multidimensional fits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x0</strong> (<code class="xref py py-class docutils literal"><span class="pre">numpy</span></code> array of floats) &#8211; Starting point for minimization.</li>
<li><strong>n</strong> (<em>positive integer</em>) &#8211; Length of vector returned by the fit function <code class="docutils literal"><span class="pre">f(x)</span></code>.</li>
<li><strong>f</strong> (<em>function</em>) &#8211; Fit function: <a class="reference internal" href="#lsqfit.multifit" title="lsqfit.multifit"><code class="xref py py-class docutils literal"><span class="pre">multifit</span></code></a> minimizes <code class="docutils literal"><span class="pre">sum_i</span> <span class="pre">f_i(x)**2</span></code>
by varying parameters <code class="docutils literal"><span class="pre">x</span></code>. The parameters are a 1-d
<code class="xref py py-class docutils literal"><span class="pre">numpy</span></code> array of either numbers or <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s.</li>
<li><strong>tol</strong> (<em>tuple or float</em>) &#8211; <p>Setting <code class="docutils literal"><span class="pre">tol=(reltol,</span> <span class="pre">abstol)</span></code> causes the fit to stop
searching for a solution when <code class="docutils literal"><span class="pre">|dx_i|</span> <span class="pre">&lt;=</span> <span class="pre">abstol</span> <span class="pre">+</span> <span class="pre">reltol</span> <span class="pre">*</span> <span class="pre">|x_i|</span></code>.
With version 2 or higher of the GSL library, <code class="docutils literal"><span class="pre">tol=(xtol,</span> <span class="pre">gtol,</span> <span class="pre">ftol)</span></code>
can be used, where the fit stops when any one of the following
three criteria is satisfied:</p>
<blockquote>
<div><ol class="arabic">
<li>step size small: <code class="docutils literal"><span class="pre">|dx_i|</span> <span class="pre">&lt;=</span> <span class="pre">xtol</span> <span class="pre">*</span> <span class="pre">(xtol</span> <span class="pre">+</span> <span class="pre">|x_i|)</span></code>;</li>
<li>gradient small: <code class="docutils literal"><span class="pre">||g</span> <span class="pre">.</span> <span class="pre">x||_inf</span> <span class="pre">&lt;=</span> <span class="pre">gtol</span> <span class="pre">*</span> <span class="pre">||f||^2</span></code>;</li>
<li>residuals small: <code class="docutils literal"><span class="pre">||f(x+dx)</span> <span class="pre">-</span> <span class="pre">f(x)||</span> <span class="pre">&lt;=</span> <span class="pre">ftol</span> <span class="pre">*</span> <span class="pre">max(||f(x)||,</span> <span class="pre">1)</span></code>.</li>
</ol>
</div></blockquote>
<p>Recommended values are: <code class="docutils literal"><span class="pre">xtol=1/10**d</span></code> for <code class="docutils literal"><span class="pre">d</span></code>
digits of precision in the parameters; <code class="docutils literal"><span class="pre">gtol=1e-6</span></code> to account
for roundoff errors in gradient <code class="docutils literal"><span class="pre">g</span></code> (unless the second order derivative
vanishes at minimum as well, in which case <code class="docutils literal"><span class="pre">gtol=0</span></code> might be good);
and <code class="docutils literal"><span class="pre">ftol&lt;&lt;1</span></code>. Setting <code class="docutils literal"><span class="pre">tol=reltol</span></code> is equivalent to setting
<code class="docutils literal"><span class="pre">tol=(reltol,</span> <span class="pre">0.0)</span></code>. The default setting is <code class="docutils literal"><span class="pre">tol=0.0001</span></code>.</p>
</li>
<li><strong>maxit</strong> (<em>integer</em>) &#8211; Maximum number of iterations in search for minimum;
default is 1000.</li>
<li><strong>alg</strong> (<em>string</em>) &#8211; <em>GSL</em> algorithm to use for minimization. Two options are
currently available: <code class="docutils literal"><span class="pre">&quot;lmsder&quot;</span></code>, the scaled <em>LMDER</em> algorithm
(default); and <code class="docutils literal"><span class="pre">&quot;lmder&quot;</span></code>, the unscaled <em>LMDER</em> algorithm.
With version 2 of the GSL library, another option is <code class="docutils literal"><span class="pre">&quot;lmniel&quot;</span></code>,
which can be useful when there is much more data than parameters.</li>
<li><strong>analyzer</strong> (<em>function</em>) &#8211; Optional function of <code class="docutils literal"><span class="pre">x,</span> <span class="pre">[...f_i(x)...],</span> <span class="pre">[[..df_ij(x)..]]</span></code>
which is called after each iteration. This can be used to inspect
intermediate steps in the minimization, if needed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#lsqfit.multifit" title="lsqfit.multifit"><code class="xref py py-class docutils literal"><span class="pre">multifit</span></code></a> is a function-class whose constructor does a least
squares fit by minimizing <code class="docutils literal"><span class="pre">sum_i</span> <span class="pre">f_i(x)**2</span></code> as a function of
vector <code class="docutils literal"><span class="pre">x</span></code>. The following attributes are available:</p>
<dl class="attribute">
<dt id="lsqfit.multifit.x">
<code class="descname">x</code><a class="headerlink" href="#lsqfit.multifit.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Location of the most recently computed (best) fit point.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multifit.cov">
<code class="descname">cov</code><a class="headerlink" href="#lsqfit.multifit.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Covariance matrix at the minimum point.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multifit.f">
<code class="descname">f</code><a class="headerlink" href="#lsqfit.multifit.f" title="Permalink to this definition">¶</a></dt>
<dd><p>The fit function <code class="docutils literal"><span class="pre">f(x)</span></code> at the minimum in the most recent fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multifit.J">
<code class="descname">J</code><a class="headerlink" href="#lsqfit.multifit.J" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient <code class="docutils literal"><span class="pre">J_ij</span> <span class="pre">=</span> <span class="pre">df_i/dx[j]</span></code> for most recent fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multifit.nit">
<code class="descname">nit</code><a class="headerlink" href="#lsqfit.multifit.nit" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterations used in last fit to find the minimum.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multifit.stopping_criterion">
<code class="descname">stopping_criterion</code><a class="headerlink" href="#lsqfit.multifit.stopping_criterion" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Criterion used to stop fit:</dt>
<dd>0 =&gt; didn&#8217;t converge
1 =&gt; step size small
2 =&gt; gradient small
3 =&gt; residuals small</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multifit.error">
<code class="descname">error</code><a class="headerlink" href="#lsqfit.multifit.error" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">None</span></code> if fit successful; an error message otherwise.</p>
</dd></dl>

<p><a class="reference internal" href="#lsqfit.multifit" title="lsqfit.multifit"><code class="xref py py-class docutils literal"><span class="pre">multifit</span></code></a> is a wrapper for the <code class="docutils literal"><span class="pre">multifit</span></code> <em>GSL</em> routine.</p>
</dd></dl>

<dl class="class">
<dt id="lsqfit.multiminex">
<em class="property">class </em><code class="descclassname">lsqfit.</code><code class="descname">multiminex</code><span class="sig-paren">(</span><em>x0</em>, <em>f</em>, <em>tol=1e-4</em>, <em>maxit=1000</em>, <em>step=1</em>, <em>alg='nmsimplex2'</em>, <em>analyzer=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.multiminex" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimizer for multidimensional functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x0</strong> (<code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> array of floats) &#8211; Starting point for minimization search.</li>
<li><strong>f</strong> (<em>function</em>) &#8211; Function <code class="docutils literal"><span class="pre">f(x)</span></code> to be minimized by varying vector <code class="docutils literal"><span class="pre">x</span></code>.</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; Minimization stops when <code class="docutils literal"><span class="pre">x</span></code> has converged to with
tolerance <code class="docutils literal"><span class="pre">tol</span></code>; default is <code class="docutils literal"><span class="pre">1e-4</span></code>.</li>
<li><strong>maxit</strong> (<em>integer</em>) &#8211; Maximum number of iterations in search for minimum;
default is 1000.</li>
<li><strong>step</strong> (<em>number</em>) &#8211; Initial step size to use in varying components of <code class="docutils literal"><span class="pre">x</span></code>;
default is 1.</li>
<li><strong>alg</strong> (<em>string</em>) &#8211; <em>GSL</em> algorithm to use for minimization. Three options are
currently available: <code class="docutils literal"><span class="pre">&quot;nmsimplex&quot;</span></code>, Nelder Mead Simplex
algorithm; <code class="docutils literal"><span class="pre">&quot;nmsimplex2&quot;</span></code>, an improved version of
<code class="docutils literal"><span class="pre">&quot;nmsimplex&quot;</span></code> (default); and <code class="docutils literal"><span class="pre">&quot;nmsimplex2rand&quot;</span></code>, a version
of <code class="docutils literal"><span class="pre">&quot;nmsimplex2&quot;</span></code> with random shifts in the start position.</li>
<li><strong>analyzer</strong> (<em>function</em>) &#8211; Optional function of <code class="docutils literal"><span class="pre">x,</span> <span class="pre">f(x),</span> <span class="pre">it</span></code>, where <code class="docutils literal"><span class="pre">it</span></code> is
the iteration number, which is called after each iteration.
This can be used to inspect intermediate steps in the
minimization, if needed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#lsqfit.multiminex" title="lsqfit.multiminex"><code class="xref py py-class docutils literal"><span class="pre">multiminex</span></code></a> is a function-class whose constructor minimizes a
multidimensional function <code class="docutils literal"><span class="pre">f(x)</span></code> by varying vector <code class="docutils literal"><span class="pre">x</span></code>. This routine
does <em>not</em> use user-supplied information about the gradient of <code class="docutils literal"><span class="pre">f(x)</span></code>.
The following attributes are available:</p>
<dl class="attribute">
<dt id="lsqfit.multiminex.x">
<code class="descname">x</code><a class="headerlink" href="#lsqfit.multiminex.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Location of the most recently computed minimum (1-d array).</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multiminex.f">
<code class="descname">f</code><a class="headerlink" href="#lsqfit.multiminex.f" title="Permalink to this definition">¶</a></dt>
<dd><p>Value of function <code class="docutils literal"><span class="pre">f(x)</span></code> at the most recently computed minimum.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multiminex.nit">
<code class="descname">nit</code><a class="headerlink" href="#lsqfit.multiminex.nit" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterations required to find most recent minimum.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multiminex.error">
<code class="descname">error</code><a class="headerlink" href="#lsqfit.multiminex.error" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">None</span></code> if fit successful; an error message otherwise.</p>
</dd></dl>

<p><a class="reference internal" href="#lsqfit.multiminex" title="lsqfit.multiminex"><code class="xref py py-class docutils literal"><span class="pre">multiminex</span></code></a> is a wrapper for the <code class="docutils literal"><span class="pre">multimin</span></code> <em>GSL</em> routine.</p>
</dd></dl>

</div>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></code></a> relies heavily on the <code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code>, and <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> modules.
Several utility functions are in <code class="xref py py-mod docutils literal"><span class="pre">lsqfit_util</span></code>. Also the minimization
routines are from the Gnu Scientific Library (<em>GSL</em>).</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">lsqfit</span></code> - Nonlinear Least Squares Fitting</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#nonlinear-fit-objects">nonlinear_fit Objects</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#classes-for-bayesian-integrals">Classes for Bayesian Integrals</a></li>
<li><a class="reference internal" href="#other-classes">Other Classes</a></li>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="case-outliers.html"
                        title="previous chapter">Case Study: Outliers and Bayesian Integrals</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="case-outliers.html" title="Case Study: Outliers and Bayesian Integrals"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">lsqfit 8.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2009-2014, G. P. Lepage.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>