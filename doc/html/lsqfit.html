<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lsqfit - Nonlinear Least Squares Fitting &mdash; lsqfit 4.8.3 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '4.8.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="lsqfit 4.8.3 documentation" href="index.html" />
    <link rel="prev" title="Numerical Analysis Modules in gvar" href="gvar_other.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gvar_other.html" title="Numerical Analysis Modules in gvar"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">lsqfit 4.8.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="lsqfit-nonlinear-least-squares-fitting">
<h1><a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><tt class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></tt></a> - Nonlinear Least Squares Fitting<a class="headerlink" href="#lsqfit-nonlinear-least-squares-fitting" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-lsqfit"></span><div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This package contains tools for nonlinear least-squares curve fitting of 
data. In general a fit has four inputs:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The dependent data <tt class="docutils literal"><span class="pre">y</span></tt> that is to be fit &#8212; typically <tt class="docutils literal"><span class="pre">y</span></tt> 
is a Python dictionary in an <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><tt class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></tt></a> analysis. Its values
<tt class="docutils literal"><span class="pre">y[k]</span></tt> are either <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s or arrays (any shape or dimension) of
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s that specify the values of the dependent variables 
and their errors.</li>
<li>A collection <tt class="docutils literal"><span class="pre">x</span></tt> of independent data &#8212; <tt class="docutils literal"><span class="pre">x</span></tt> can have any 
structure and contain any data (or no data).</li>
<li>A fit function <tt class="docutils literal"><span class="pre">f(x,</span> <span class="pre">p)</span></tt> whose parameters <tt class="docutils literal"><span class="pre">p</span></tt> are adjusted by 
the fit until <tt class="docutils literal"><span class="pre">f(x,</span> <span class="pre">p)</span></tt> equals <tt class="docutils literal"><span class="pre">y</span></tt> to within <tt class="docutils literal"><span class="pre">y</span></tt>s errors 
&#8212; parameters <cite>p`</cite> are usually specified by a dictionary whose 
values <tt class="docutils literal"><span class="pre">p[k]</span></tt> are individual parameters or (<tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt>) 
arrays of parameters. The fit function is assumed independent
of <tt class="docutils literal"><span class="pre">x</span></tt> (that is, <tt class="docutils literal"><span class="pre">f(p)</span></tt>) if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">False</span></tt> (or if <tt class="docutils literal"><span class="pre">x</span></tt> is 
omitted from the input data).</li>
<li>Initial estimates or <em>priors</em> for each parameter in <tt class="docutils literal"><span class="pre">p</span></tt> 
&#8212; priors are usually specified using a dictionary <tt class="docutils literal"><span class="pre">prior</span></tt> 
whose values <tt class="docutils literal"><span class="pre">prior[k]</span></tt> are <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s or arrays of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s that 
give initial estimates (values and errors) for parameters <tt class="docutils literal"><span class="pre">p[k]</span></tt>.</li>
</ol>
</div></blockquote>
<p>A typical code sequence has the structure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">...</span> <span class="n">collect</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">prior</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">compute</span> <span class="n">fit</span> <span class="n">to</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">y</span><span class="p">,</span> <span class="n">using</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">...</span>
    <span class="o">...</span> <span class="k">return</span> <span class="n">dictionary</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">fit</span> <span class="n">values</span> <span class="k">for</span> <span class="n">the</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="n">s</span> <span class="o">...</span>

<span class="n">fit</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">fcn</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>      <span class="c"># variable fit is of type nonlinear_fit</span>
</pre></div>
</div>
<p>The parameters <tt class="docutils literal"><span class="pre">p[k]</span></tt> are varied until the <tt class="docutils literal"><span class="pre">chi**2</span></tt> for the fit is 
minimized.</p>
<p>The best-fit values for the parameters are recovered after fitting 
using, for example, <tt class="docutils literal"><span class="pre">p=fit.p</span></tt>. Then the <tt class="docutils literal"><span class="pre">p[k]</span></tt> are <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s or 
arrays of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s that give best-fit estimates and fit uncertainties 
in those estimates. The <tt class="docutils literal"><span class="pre">print(fit)</span></tt> statement prints a summary of 
the fit results.</p>
<p>The dependent variable <tt class="docutils literal"><span class="pre">y</span></tt> above could be an array instead of a 
dictionary, which is less flexible in general but possibly more 
convenient in simpler fits. Then the approximate <tt class="docutils literal"><span class="pre">y</span></tt> returned by fit
function <tt class="docutils literal"><span class="pre">f(x,</span> <span class="pre">p)</span></tt> must be an array with the same shape as the dependent
variable. The prior <tt class="docutils literal"><span class="pre">prior</span></tt> could also be represented by an array 
instead of a dictionary.</p>
<p>The <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><tt class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></tt></a> tutorial contains extended explanations and examples.</p>
</div>
<div class="section" id="formal-background">
<h2>Formal Background<a class="headerlink" href="#formal-background" title="Permalink to this headline">¶</a></h2>
<p>The formal structure structure of a least-squares problem involves
fitting input data <img class="math" src="_images/math/ec62fe89a2cfa3e0993899eaa4237367667f3ebf.png" alt="y_i" style="vertical-align: -4px"/> with functions <img class="math" src="_images/math/40a2b604e99fd43b836e70a47c4af98fa9b3dbf4.png" alt="f_i(p)" style="vertical-align: -4px"/> by adjusting
fit parameters <img class="math" src="_images/math/ed4aa5bfaca4d391ba4f4c15c86179aa00fea00a.png" alt="p_a" style="vertical-align: -4px"/> to minimize</p>
<div class="math">
<p><img src="_images/math/f40042363f566fef59580698e379748a42ff8777.png" alt="\chi^2 &amp;\equiv \sum_{ij} \Delta y(p)_i\,(\mathrm{cov}_y^{-1})_{ij}\,
\Delta y(p)_j  \\
&amp;\equiv (\Delta y(p))^\mathrm{T}\cdot \mathrm{cov}_y^{-1}\cdot
\Delta y(p)"/></p>
</div><p>where <img class="math" src="_images/math/459a88976853e33e9a8ca59dfe83119955686c96.png" alt="\mathrm{cov}_y" style="vertical-align: -6px"/> is the covariance matrix for the input data
and</p>
<div class="math">
<p><img src="_images/math/7cfc9a8da0a30784fe3b8622dd1e0cb7c8ec38b7.png" alt="\Delta y(p)_i \equiv f_i(p) - y_i."/></p>
</div><p>There are generally two types of input data &#8212; actual data and
prior information for each fit parameter &#8212; but we lump these together
here since they enter in the same way (that is, the sums over <img class="math" src="_images/math/62494ad46772c68b86d00123a1ea8f195a7864b2.png" alt="i" style="vertical-align: 0px"/>
and <img class="math" src="_images/math/976b652be33ea6b747a03babbb113160506846d0.png" alt="j" style="vertical-align: -4px"/> are over all data and priors).</p>
<p>The best-fit values <img class="math" src="_images/math/fc4affc28fb114163c14165a1fb24a5c540a7963.png" alt="\overline{p}_a" style="vertical-align: -4px"/> for the fit parameters are those
that minimize <img class="math" src="_images/math/143d854fb865a4fb5147d3cc5d31426941bdd597.png" alt="\chi^2" style="vertical-align: -4px"/>:</p>
<div class="math">
<p><img src="_images/math/f58680b6ccfa686d3fd52533f7695c225c84cc6f.png" alt="(\partial_a \Delta y(\overline{p}))^\mathrm{T}
\cdot\mathrm{cov}_y^{-1}\cdot
\Delta y(\overline{p}) = 0"/></p>
</div><p>where the derivatives are <img class="math" src="_images/math/a99e208376ed9d408e7dffe3e6d624dfa400c2e2.png" alt="\partial_a = \partial/\partial
\overline{p}_a" style="vertical-align: -5px"/>. The covariance matrix <img class="math" src="_images/math/72f2f5202feb882926834030925accc55f1e7ab1.png" alt="\mathrm{cov}_p" style="vertical-align: -6px"/> for these is
obtained (approximately) from</p>
<div class="math">
<p><img src="_images/math/b7d11d4d11f6d0b877c276173a29943b1c1f77e3.png" alt="(\mathrm{cov^{-1}_p})_{ab} \equiv
(\partial_a \Delta y(\overline p))^\mathrm{T}
\cdot \mathrm{cov}^{-1}_y \cdot
(\partial_b\Delta y(\overline p))."/></p>
</div><p>Consequently the variance for any function <img class="math" src="_images/math/3985d3b8e9822d6dafd5436f37d08a10b9113004.png" alt="g(\overline p)" style="vertical-align: -4px"/> of the
best-fit parameters is given by (approximately)</p>
<div class="math">
<p><img src="_images/math/6b7b025185bc3193cae031d023cd22da436816e9.png" alt="\sigma^2_{g} = (\partial g(\overline p))^\mathrm{T} \cdot
\mathrm{cov}_p \cdot \partial g(\overline p)"/></p>
</div><p>The definition of the covariance matrix implies that it and any variance
<img class="math" src="_images/math/e4cf161bcc4d03d4a1c3f4441bcba57966672964.png" alt="\sigma^2_g" style="vertical-align: -8px"/> derived from it depend linearly (approximately) on the
elements of the input data covariance matrix <img class="math" src="_images/math/459a88976853e33e9a8ca59dfe83119955686c96.png" alt="\mathrm{cov}_y" style="vertical-align: -6px"/>, at
least when errors are small:</p>
<div class="math">
<p><img src="_images/math/16a5fda0992cfb22803ea1711d8814cd1c64e78b.png" alt="\sigma^2_g \approx \sum_{ij} c(\overline p)_{ij} \,
 (\mathrm{cov}_y)_{ij}"/></p>
</div><p>This allows us to associate different portions of the output error
<img class="math" src="_images/math/e4cf161bcc4d03d4a1c3f4441bcba57966672964.png" alt="\sigma^2_g" style="vertical-align: -8px"/> with different parts of the input error
<img class="math" src="_images/math/459a88976853e33e9a8ca59dfe83119955686c96.png" alt="\mathrm{cov}_y" style="vertical-align: -6px"/>, creating an &#8220;error budget&#8221; for
<img class="math" src="_images/math/3985d3b8e9822d6dafd5436f37d08a10b9113004.png" alt="g(\overline p)" style="vertical-align: -4px"/>.
Such information helps pinpoint the input errors that most affect the
output errors for any particular quantity  <img class="math" src="_images/math/3985d3b8e9822d6dafd5436f37d08a10b9113004.png" alt="g(\overline p)" style="vertical-align: -4px"/>,
and also indicates how those output errors might change for a given change
in input error.</p>
<p>The relationship between the input and output errors is only
approximately linear because the coefficients in the expansion depend upon
the best-fit values for the parameters, and these depend upon the input
errors &#8212; but only weakly when errors are small. Neglecting such variation
in the parameters, the error budget for any quantity is easily computed
using</p>
<div class="math">
<p><img src="_images/math/6248c44731bcc8df420d1adf355431b57aec1e6d.png" alt="\frac{\partial (\mathrm{cov}_p)_{ab}}{\partial (\mathrm{cov}_y)_{ij}}
 = D_{ai}\,D_{bj}"/></p>
</div><p>where</p>
<div class="math">
<p><img src="_images/math/e2e0fc02079c67ed3070a4042d363e1f3e8dd724.png" alt="D_{ai} \equiv (\mathrm{cov}_p \cdot \partial \Delta y \cdot
   \mathrm{cov}_y^{-1})_{ai}"/></p>
</div><p>and, trivially,
<img class="math" src="_images/math/ec3bade7b995767184074bd4bf6629ae26f0c3b9.png" alt="\mathrm{cov}_p = D\cdot\mathrm{cov}_y\cdot D^\mathrm{T}" style="vertical-align: -6px"/>.</p>
<p>This last formula suggests that</p>
<div class="math">
<p><img src="_images/math/990366a65b1942a67e5f80464888ece41a9ceb73.png" alt="\frac{\partial \overline{p}_a}{\partial y_i} = D_{ai}."/></p>
</div><p>This relationship is true in the limit of small errors, as is easily derived
from the minimum condition for the fit, which defines (implicitly)
<img class="math" src="_images/math/17df9cad4087304b9a125bceb586b4cca0513a83.png" alt="\overline{p}_a(y)" style="vertical-align: -4px"/>: Differentiating with respect to
<img class="math" src="_images/math/ec62fe89a2cfa3e0993899eaa4237367667f3ebf.png" alt="y_i" style="vertical-align: -4px"/> we obtain</p>
<div class="math">
<p><img src="_images/math/4344a120976bf6bcdd2c7bff8b213ee6d88acb75.png" alt="(\partial_a \Delta y(\overline{p}))^\mathrm{T}\cdot\mathrm{cov}_y^{-1}\cdot
\frac{\partial\Delta y(\overline{p})}{\partial y_i} = 0"/></p>
</div><p>where we have ignored terms suppressed by a factor of <img class="math" src="_images/math/a9c518b3071d03b1f8e0f098883f804c13aa8e73.png" alt="\Delta y(p)" style="vertical-align: -4px"/>.
This leads immediately to the relationship above.</p>
<p>The data&#8217;s covariance matrix <img class="math" src="_images/math/459a88976853e33e9a8ca59dfe83119955686c96.png" alt="\mathrm{cov}_y" style="vertical-align: -6px"/> is sometimes rather
singular, making it difficult to invert. This problem is dealt with using
an SVD cut: the covariance matrix is diagonalized, some number of the
smallest (and therefore least-well determined) eigenvalues and their
eigenvectors are discarded, and the inverse matrix is reconstituted from
the eigenmodes that remain. (Instead of discarding modes one can replace
their eigenvalues by the smallest eigenvalue that is retained; this is less
conservative and usually leads to more accurate results.)</p>
</div>
<div class="section" id="nonlinear-fit-objects">
<h2>nonlinear_fit Objects<a class="headerlink" href="#nonlinear-fit-objects" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lsqfit.nonlinear_fit">
<em class="property">class </em><tt class="descclassname">lsqfit.</tt><tt class="descname">nonlinear_fit</tt><big>(</big><em>data</em>, <em>fcn</em>, <em>prior=None</em>, <em>p0=None</em>, <em>svdcut=1e-15</em>, <em>debug=False</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#lsqfit.nonlinear_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Nonlinear least-squares fit.</p>
<p><a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></tt></a> fits a (nonlinear) function <tt class="docutils literal"><span class="pre">f(x,</span> <span class="pre">p)</span></tt>
to data <tt class="docutils literal"><span class="pre">y</span></tt> by varying parameters <tt class="docutils literal"><span class="pre">p</span></tt>, and stores the results: for
example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">fcn</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>   <span class="c"># do fit</span>
<span class="k">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>                               <span class="c"># print fit results</span>
</pre></div>
</div>
<p>The best-fit values for the parameters are in <tt class="docutils literal"><span class="pre">fit.p</span></tt>, while the
<tt class="docutils literal"><span class="pre">chi**2</span></tt>, the number of degrees of freedom, the logarithm of Gaussian
Bayes Factor, the number of iterations, and the cpu time needed for the
fit are in <tt class="docutils literal"><span class="pre">fit.chi2</span></tt>, <tt class="docutils literal"><span class="pre">fit.dof</span></tt>, <tt class="docutils literal"><span class="pre">fit.logGBF</span></tt>, <tt class="docutils literal"><span class="pre">fit.nit</span></tt>, and
<tt class="docutils literal"><span class="pre">fit.time</span></tt>, respectively. Results for individual parameters in
<tt class="docutils literal"><span class="pre">fit.p</span></tt> are of type <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>, and therefore carry information about
errors and correlations with other parameters. The fit data and prior 
can be recovered using <tt class="docutils literal"><span class="pre">fit.x</span></tt> (equals <tt class="docutils literal"><span class="pre">False</span></tt> if there is no <tt class="docutils literal"><span class="pre">x</span></tt>),
<tt class="docutils literal"><span class="pre">fit.y</span></tt>, and <tt class="docutils literal"><span class="pre">fit.prior</span></tt>; the data and prior are corrected for the
<em>svd</em> cut, if there is one (that is, their covariance matrices have been 
modified in accordance with the <em>svd</em> cut).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; <p>Data to be fit by <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></tt></a>. It can 
have any of the following formats:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">x</span></tt> is the independent data that is passed to the fit
function with the fit parameters: <tt class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></tt>. <tt class="docutils literal"><span class="pre">y</span></tt> is a
dictionary (or array) of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s that encode the means and
covariance matrix for the data that is to be fit being fit.
The fit function must return a result having the same
layout as <tt class="docutils literal"><span class="pre">y</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">y</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">y</span></tt> is a dictionary (or array) of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s that encode
the means and covariance matrix for the data being fit.
There is no independent data so the fit function depends
only upon the fit parameters: <tt class="docutils literal"><span class="pre">fit(p)</span></tt>. The fit function
must return a result having the same layout as <tt class="docutils literal"><span class="pre">y</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">ymean,</span> <span class="pre">ycov</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">x</span></tt> is the independent data that is passed to the fit
function with the fit parameters: <tt class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></tt>. <tt class="docutils literal"><span class="pre">ymean</span></tt>
is an array containing the mean values of the fit data.
<tt class="docutils literal"><span class="pre">ycov</span></tt> is an array containing the covariance matrix of
the fit data; <tt class="docutils literal"><span class="pre">ycov.shape</span></tt> equals <tt class="docutils literal"><span class="pre">2*ymean.shape</span></tt>. 
The fit function must return an array having the same
shape as <tt class="docutils literal"><span class="pre">ymean</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">ymean,</span> <span class="pre">ysdev</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">x</span></tt> is the independent data that is passed to the fit
function with the fit parameters: <tt class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></tt>. <tt class="docutils literal"><span class="pre">ymean</span></tt>
is an array containing the mean values of the fit data.
<tt class="docutils literal"><span class="pre">ysdev</span></tt> is an array containing the standard deviations of
the fit data; <tt class="docutils literal"><span class="pre">ysdev.shape</span></tt> equals <tt class="docutils literal"><span class="pre">ymean.shape</span></tt>. The
data are assumed to be uncorrelated. The fit function must
return an array having the same shape as <tt class="docutils literal"><span class="pre">ymean</span></tt>.</dd>
</dl>
</div></blockquote>
<p>Setting <tt class="docutils literal"><span class="pre">x=False</span></tt> in the first, third or fourth of these formats
implies that the fit function depends only on the fit parameters:
that is, <tt class="docutils literal"><span class="pre">fcn(p)</span></tt> instead of <tt class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></tt>. (This is not assumed
if <tt class="docutils literal"><span class="pre">x=None</span></tt>.)</p>
</li>
<li><strong>fcn</strong> (<em>function</em>) &#8211; The function to be fit to <tt class="docutils literal"><span class="pre">data</span></tt>. It is either a 
function of the independent data <tt class="docutils literal"><span class="pre">x</span></tt> and the fit parameters <tt class="docutils literal"><span class="pre">p</span></tt>
(<tt class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></tt>), or a function of just the fit parameters
(<tt class="docutils literal"><span class="pre">fcn(p)</span></tt>) when there is no <tt class="docutils literal"><span class="pre">x</span></tt> data or <tt class="docutils literal"><span class="pre">x=False</span></tt>. The
parameters are tuned in the fit until the function returns values
that agree with the <tt class="docutils literal"><span class="pre">y</span></tt> data to within the <tt class="docutils literal"><span class="pre">y</span></tt>s&#8217; errors. The
function&#8217;s return value must have the same layout as the <tt class="docutils literal"><span class="pre">y</span></tt> data
(a dictionary or an array). The fit parameters <tt class="docutils literal"><span class="pre">p</span></tt> are either: 1)
a dictionary where each <tt class="docutils literal"><span class="pre">p[k]</span></tt> is a single parameter or an array
of parameters (any shape); or, 2) a single array of parameters. The
layout of the parameters is the same as that of prior <tt class="docutils literal"><span class="pre">prior</span></tt> if
it is specified; otherwise, it is inferred from of the starting
value <tt class="docutils literal"><span class="pre">p0</span></tt> for the fit.</li>
<li><strong>prior</strong> (dictionary, array, or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; A dictionary (or array) containing <em>a priori</em> estimates 
for all parameters <tt class="docutils literal"><span class="pre">p</span></tt> used by fit function <tt class="docutils literal"><span class="pre">fcn(x,</span> <span class="pre">p)</span></tt> (or
<tt class="docutils literal"><span class="pre">fcn(p)</span></tt>). Fit parameters <tt class="docutils literal"><span class="pre">p</span></tt> are stored in a dictionary (or
array) with the same keys and structure (or shape) as <tt class="docutils literal"><span class="pre">prior</span></tt>.
The default value is <tt class="docutils literal"><span class="pre">None</span></tt>; <tt class="docutils literal"><span class="pre">prior</span></tt> must be defined if <tt class="docutils literal"><span class="pre">p0</span></tt>
is <tt class="docutils literal"><span class="pre">None</span></tt>.</li>
<li><strong>p0</strong> (dictionary, array, string or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Starting values for fit parameters in fit. 
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></tt></a> adjusts <tt class="docutils literal"><span class="pre">p0</span></tt> to make it consistent
in shape and structure with <tt class="docutils literal"><span class="pre">prior</span></tt> when the latter is 
specified: elements missing from <tt class="docutils literal"><span class="pre">p0</span></tt> are filled 
in using <tt class="docutils literal"><span class="pre">prior</span></tt>, and elements in 
<tt class="docutils literal"><span class="pre">p0</span></tt> that are not in <tt class="docutils literal"><span class="pre">prior</span></tt> are discarded. If <tt class="docutils literal"><span class="pre">p0</span></tt> is a
string, it is taken as a file name and
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></tt></a> attempts to read starting values from
that file; best-fit parameter values are written out to the same
file after the fit (for priming future fits). If <tt class="docutils literal"><span class="pre">p0</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>
or the attempt to read the file fails, starting values are
extracted from <tt class="docutils literal"><span class="pre">prior</span></tt>. The default value is <tt class="docutils literal"><span class="pre">None</span></tt>; <tt class="docutils literal"><span class="pre">p0</span></tt>
must be defined if <tt class="docutils literal"><span class="pre">prior</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>.</li>
<li><strong>svdcut</strong> (<tt class="docutils literal"><span class="pre">None</span></tt> or <tt class="docutils literal"><span class="pre">float</span></tt>) &#8211; If <tt class="docutils literal"><span class="pre">svdcut</span></tt> is nonzero (not <tt class="docutils literal"><span class="pre">None</span></tt>), <em>svd</em> cuts
are applied to every block-diagonal sub-matrix of the covariance 
matrix for the data <tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">prior</span></tt> (if there is a prior).
The blocks are first rescaled so that all 
diagonal elements equal 1 &#8211; that is, the blocks are replaced
by the correlation matrices for the corresponding subsets of variables. 
Then, if <tt class="docutils literal"><span class="pre">svdcut</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt>, 
eigenvalues of the rescaled matrices that are smaller than <tt class="docutils literal"><span class="pre">svdcut</span></tt> 
times the maximum eigenvalue are replaced by <tt class="docutils literal"><span class="pre">svdcut</span></tt> times the 
maximum eigenvalue. This makes the covariance matrix less singular 
and less susceptible to roundoff error. When <tt class="docutils literal"><span class="pre">svdcut</span> <span class="pre">&lt;</span> <span class="pre">0</span></tt>, 
eigenvalues smaller than <tt class="docutils literal"><span class="pre">|svdcut|</span></tt> times the maximum eigenvalue 
are discarded and the corresponding components in <tt class="docutils literal"><span class="pre">y</span></tt> and 
<tt class="docutils literal"><span class="pre">prior</span></tt> are zeroed out.</li>
<li><strong>debug</strong> (<em>boolean</em>) &#8211; Set to <tt class="docutils literal"><span class="pre">True</span></tt> for extra debugging of the fit function
and a check for roundoff errors. (Default is <tt class="docutils literal"><span class="pre">False</span></tt>.)</li>
<li><strong>fitterargs</strong> &#8211; Dictionary of arguments passed on to 
<a class="reference internal" href="#lsqfit.multifit" title="lsqfit.multifit"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.multifit</span></tt></a>, which does the fitting.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The results from the fit are accessed through the following attributes
(of <tt class="docutils literal"><span class="pre">fit</span></tt> where <tt class="docutils literal"><span class="pre">fit</span> <span class="pre">=</span> <span class="pre">nonlinear_fit(...)</span></tt>):</p>
<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.chi2">
<tt class="descname">chi2</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum <tt class="docutils literal"><span class="pre">chi**2</span></tt> for the fit. <tt class="docutils literal"><span class="pre">fit.chi2</span> <span class="pre">/</span> <span class="pre">fit.dof</span></tt> is usually
of order one in good fits; values much less than one suggest
that the actual standard deviations in the input data and/or priors are
smaller than the standard deviations used in the fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.cov">
<tt class="descname">cov</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Covariance matrix of the best-fit parameters from the fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.dof">
<tt class="descname">dof</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of degrees of freedom in the fit, which equals the number of
pieces of data being fit when priors are specified for the fit
parameters. Without priors, it is the number of pieces of data minus
the number of fit parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.logGBF">
<tt class="descname">logGBF</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.logGBF" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm of the probability (density) of obtaining
the fit data by randomly sampling the parameter model
(priors plus fit function) used in the fit. This quantity is
useful for comparing fits of the same data to different models,
with different priors and/or fit functions. The model with the
largest value of <tt class="docutils literal"><span class="pre">fit.logGBF</span></tt> is the one prefered by the data.
The exponential of the difference in <tt class="docutils literal"><span class="pre">fit.logGBF</span></tt> between two models
is the ratio of probabilities (Bayes factor) for those models. Differences
in <tt class="docutils literal"><span class="pre">fit.logGBF</span></tt> smaller than 1 are not very significant. Gaussian
statistics are assumed when computing <tt class="docutils literal"><span class="pre">fit.logGBF</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.p">
<tt class="descname">p</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.p" title="Permalink to this definition">¶</a></dt>
<dd><p>Best-fit parameters from fit. Depending upon what was used for
the prior (or <tt class="docutils literal"><span class="pre">p0</span></tt>), it is either: a dictionary
(<a class="reference internal" href="gvar.html#gvar.BufferDict" title="gvar.BufferDict"><tt class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></tt></a>) of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s and/or arrays of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s; or
an array (<tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>) of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s. <tt class="docutils literal"><span class="pre">fit.p</span></tt> represents a
multi-dimensional Gaussian distribution which, in Bayesian terminology,
is the <em>posterior</em> probability distribution of the fit parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.pmean">
<tt class="descname">pmean</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.pmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Means of the best-fit parameters from fit (dictionary or array).</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.psdev">
<tt class="descname">psdev</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.psdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard deviations of the best-fit parameters from fit
(dictionary or array).</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.palt">
<tt class="descname">palt</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.palt" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">fit.p</span></tt> except that the errors are computed directly
from <tt class="docutils literal"><span class="pre">fit.cov</span></tt>. This is faster but means that no information about
correlations with the input data is retained (unlike in <tt class="docutils literal"><span class="pre">fit.p</span></tt>);
and, therefore, <tt class="docutils literal"><span class="pre">fit.palt</span></tt> cannot be used to generate error
budgets. <tt class="docutils literal"><span class="pre">fit.p</span></tt> and <tt class="docutils literal"><span class="pre">fit.palt</span></tt> give the same means and normally
give the same errors for each parameter. They differ only when the
input data&#8217;s covariance matrix is too singular to invert accurately
(because of roundoff error), in which case an SVD cut is advisable.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.transformed_p">
<tt class="descname">transformed_p</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.transformed_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">fit.p</span></tt> but augmented to include the transforms of any
log-normal or other parameter implemented using decorator
<a class="reference internal" href="#lsqfit.transform_p" title="lsqfit.transform_p"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.transform_p</span></tt></a>. In the case of a log-normal variable
<tt class="docutils literal"><span class="pre">fit.p['logXX']</span></tt>, for example, <tt class="docutils literal"><span class="pre">fit.transformed_p['XX']</span></tt> is
defined equal to <tt class="docutils literal"><span class="pre">exp(fit.p['logXX'])</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.p0">
<tt class="descname">p0</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.p0" title="Permalink to this definition">¶</a></dt>
<dd><p>The parameter values used to start the fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.Q">
<tt class="descname">Q</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>The probability that the <tt class="docutils literal"><span class="pre">chi**2</span></tt> from the fit could have been
larger, by chance, assuming the best-fit model is correct. Good fits have
<tt class="docutils literal"><span class="pre">Q</span></tt> values larger than 0.1 or so. Also called the <em>p-value</em> of
the fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.svdcorrection">
<tt class="descname">svdcorrection</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.svdcorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>An array containing the (flattened) SVD corrections, if any, added
to the fit data <tt class="docutils literal"><span class="pre">y</span></tt> and the prior <tt class="docutils literal"><span class="pre">prior</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.svdn">
<tt class="descname">svdn</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.svdn" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of eignemodes modified (and/or deleted) by the SVD cut.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.nblocks">
<tt class="descname">nblocks</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.nblocks" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary where <tt class="docutils literal"><span class="pre">nblocks[s]</span></tt> equals the number of block-diagonal
sub-matrices of the <tt class="docutils literal"><span class="pre">y</span></tt>&#8211;<tt class="docutils literal"><span class="pre">prior</span></tt> covariance matrix that are size
<tt class="docutils literal"><span class="pre">s</span></tt>-by-<tt class="docutils literal"><span class="pre">s</span></tt>. This is sometimes useful for debugging.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.time">
<tt class="descname">time</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.time" title="Permalink to this definition">¶</a></dt>
<dd><p>CPU time (in secs) taken by fit.</p>
</dd></dl>

<p>The input parameters to the fit can be accessed as attributes. Note
in particular attributes:</p>
<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.prior">
<tt class="descname">prior</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.prior" title="Permalink to this definition">¶</a></dt>
<dd><p>Prior used in the fit. This may differ from the input prior if an
SVD cut is used. It is either a dictionary
(<a class="reference internal" href="gvar.html#gvar.BufferDict" title="gvar.BufferDict"><tt class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></tt></a>) or an array (<tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>),
depending upon the input. Equals <tt class="docutils literal"><span class="pre">None</span></tt> if no prior was specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.x">
<tt class="descname">x</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.x" title="Permalink to this definition">¶</a></dt>
<dd><p>The first field in the input <tt class="docutils literal"><span class="pre">data</span></tt>. This is sometimes the
independent variable (as in &#8216;y vs x&#8217; plot), but may be anything. It
is set equal to <tt class="docutils literal"><span class="pre">False</span></tt> if the <tt class="docutils literal"><span class="pre">x</span></tt> field is omitted from the
input <tt class="docutils literal"><span class="pre">data</span></tt>. (This also means that the fit function has no <tt class="docutils literal"><span class="pre">x</span></tt>
argument: so <tt class="docutils literal"><span class="pre">f(p)</span></tt> rather than <tt class="docutils literal"><span class="pre">f(x,p)</span></tt>.)</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.y">
<tt class="descname">y</tt><a class="headerlink" href="#lsqfit.nonlinear_fit.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit data used in the fit. This may differ from the input data if
an SVD cut is used. It is either a dictionary
(<a class="reference internal" href="gvar.html#gvar.BufferDict" title="gvar.BufferDict"><tt class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></tt></a>) or an array (<tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>),
depending upon the input.</p>
</dd></dl>

<p>Additional methods are provided for printing out detailed information
about the fit, testing fits with simulated data,
doing bootstrap analyses of the fit errors,
dumping (for later use) and loading parameter values, and checking for roundoff
errors in the final error estimates:</p>
<dl class="method">
<dt id="lsqfit.nonlinear_fit.format">
<tt class="descname">format</tt><big>(</big><em>maxline=0</em>, <em>pstyle='v'</em><big>)</big><a class="headerlink" href="#lsqfit.nonlinear_fit.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Formats fit output details into a string for printing.</p>
<p>The output tabulates the <tt class="docutils literal"><span class="pre">chi**2</span></tt> per degree of freedom of the 
fit (<tt class="docutils literal"><span class="pre">chi2/dof</span></tt>), the number of degrees of freedom, 
the logarithm of the Gaussian Bayes Factor for the fit (<tt class="docutils literal"><span class="pre">logGBF</span></tt>),
and the number of fit-algorithm iterations needed by the fit. 
Optionally, it will also list the best-fit values for the 
fit parameters together with the prior for each (in <tt class="docutils literal"><span class="pre">[]</span></tt> on 
each line). It can also list all of the data and the corresponding
values from the fit. At the end it lists the SVD cut, 
the number of eigenmodes modified by the SVD cut, the relative 
and absolute tolerances used in the fit, and the time in seconds
needed to do the fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>maxline</strong> (<em>integer or bool</em>) &#8211; Maximum number of data points for which fit 
results and input data are tabulated. <tt class="docutils literal"><span class="pre">maxline&lt;0</span></tt> implies
that only <tt class="docutils literal"><span class="pre">chi2</span></tt>, <tt class="docutils literal"><span class="pre">Q</span></tt>, <tt class="docutils literal"><span class="pre">logGBF</span></tt>, and <tt class="docutils literal"><span class="pre">itns</span></tt> are
tabulated; no parameter values are included. Setting
<tt class="docutils literal"><span class="pre">maxline=True</span></tt> prints all data points; setting it 
equal <tt class="docutils literal"><span class="pre">None</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt> is the same as setting
it equal to <tt class="docutils literal"><span class="pre">-1</span></tt>. Default is <tt class="docutils literal"><span class="pre">maxline=0</span></tt>.</li>
<li><strong>pstyle</strong> (<em>&#8216;vv&#8217;, &#8216;v&#8217;, or &#8216;m&#8217;</em>) &#8211; Style used for parameter list. Supported values are
&#8216;vv&#8217; for very verbose, &#8216;v&#8217; for verbose, and &#8216;m&#8217; for minimal.
When &#8216;m&#8217; is set, only parameters whose values differ from their
prior values are listed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">String containing detailed information about fit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.fmt_errorbudget">
<tt class="descname">fmt_errorbudget</tt><big>(</big><em>outputs</em>, <em>inputs</em>, <em>ndecimal=2</em>, <em>percent=True</em><big>)</big><a class="headerlink" href="#lsqfit.nonlinear_fit.fmt_errorbudget" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulate error budget for <tt class="docutils literal"><span class="pre">outputs[ko]</span></tt> due to <tt class="docutils literal"><span class="pre">inputs[ki]</span></tt>.</p>
<p>For each output <tt class="docutils literal"><span class="pre">outputs[ko]</span></tt>, <tt class="docutils literal"><span class="pre">fmt_errorbudget</span></tt> computes the
contributions to <tt class="docutils literal"><span class="pre">outputs[ko]</span></tt>&#8216;s standard deviation coming from the
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s collected in <tt class="docutils literal"><span class="pre">inputs[ki]</span></tt>. This is done for each key
combination <tt class="docutils literal"><span class="pre">(ko,ki)</span></tt> and the results are tabulated with columns and
rows labeled by <tt class="docutils literal"><span class="pre">ko</span></tt> and <tt class="docutils literal"><span class="pre">ki</span></tt>, respectively. If a <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a> in
<tt class="docutils literal"><span class="pre">inputs[ki]</span></tt> is correlated with other <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s, the contribution from
the others is included in the <tt class="docutils literal"><span class="pre">ki</span></tt> contribution as well (since
contributions from correlated <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s cannot be resolved). The table
is returned as a string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>outputs</strong> &#8211; Dictionary of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s for which an error budget 
is computed.</li>
<li><strong>inputs</strong> &#8211; Dictionary of: <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s, arrays/dictionaries of 
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s, or lists of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s and/or arrays/dictionaries of
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s. <tt class="docutils literal"><span class="pre">fmt_errorbudget</span></tt> tabulates the parts of the standard
deviations of each <tt class="docutils literal"><span class="pre">outputs[ko]</span></tt> due to each <tt class="docutils literal"><span class="pre">inputs[ki]</span></tt>.</li>
<li><strong>ndecimal</strong> (<tt class="docutils literal"><span class="pre">int</span></tt>) &#8211; Number of decimal places displayed in table.</li>
<li><strong>percent</strong> (<em>boolean</em>) &#8211; Tabulate % errors if <tt class="docutils literal"><span class="pre">percent</span> <span class="pre">is</span> <span class="pre">True</span></tt>; otherwise
tabulate the errors themselves.</li>
<li><strong>colwidth</strong> (<em>positive integer</em>) &#8211; Width of each column.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A table (<tt class="docutils literal"><span class="pre">str</span></tt>) containing the error budget. 
Output variables are labeled by the keys in <tt class="docutils literal"><span class="pre">outputs</span></tt>
(columns); sources of uncertainty are labeled by the keys in
<tt class="docutils literal"><span class="pre">inputs</span></tt> (rows).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.fmt_values">
<tt class="descname">fmt_values</tt><big>(</big><em>outputs</em>, <em>ndecimal=None</em><big>)</big><a class="headerlink" href="#lsqfit.nonlinear_fit.fmt_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulate <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s in <tt class="docutils literal"><span class="pre">outputs</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>outputs</strong> &#8211; A dictionary of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a> objects.</li>
<li><strong>ndecimal</strong> (<tt class="docutils literal"><span class="pre">int</span></tt> or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Format values <tt class="docutils literal"><span class="pre">v</span></tt> using <tt class="docutils literal"><span class="pre">v.fmt(ndecimal)</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A table (<tt class="docutils literal"><span class="pre">str</span></tt>) containing values and standard 
deviations for variables in <tt class="docutils literal"><span class="pre">outputs</span></tt>, labeled by the keys
in <tt class="docutils literal"><span class="pre">outputs</span></tt>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.simulated_fit_iter">
<tt class="descname">simulated_fit_iter</tt><big>(</big><em>n=None</em>, <em>pexact=None</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#lsqfit.nonlinear_fit.simulated_fit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that returns simulation copies of a fit.</p>
<p>Fit reliability can be tested using simulated data which
replaces the mean values in <tt class="docutils literal"><span class="pre">self.y</span></tt> with random numbers
drawn from a distribution whose mean equals <tt class="docutils literal"><span class="pre">self.fcn(pexact)</span></tt> 
and whose covariance matrix is the same as <tt class="docutils literal"><span class="pre">self.y</span></tt>&#8216;s. Simulated
data is very similar to the original fit data, <tt class="docutils literal"><span class="pre">self.y</span></tt>, 
but corresponds to a world where the correct values for
the parameters (<em>i.e.</em>, averaged over many simulated data
sets) are given by <tt class="docutils literal"><span class="pre">pexact</span></tt>. <tt class="docutils literal"><span class="pre">pexact</span></tt> is usually taken
equal to <tt class="docutils literal"><span class="pre">fit.pmean</span></tt>.</p>
<p>Each iteration of the iterator creates new simulated data,
with different random numbers, and fits it, returning the 
the <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></tt></a> that results. The simulated
data has the same covariance matrix as <tt class="docutils literal"><span class="pre">fit.y</span></tt>.
Typical usage is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">...</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">sfit</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">simulated_fit_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">verify</span> <span class="n">that</span> <span class="n">sfit</span><span class="o">.</span><span class="n">p</span> <span class="n">agrees</span> <span class="k">with</span> <span class="n">pexact</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">pmean</span> <span class="n">within</span> <span class="n">errors</span> <span class="o">...</span>
</pre></div>
</div>
<p>Only a few iterations are needed to get a sense of the fit&#8217;s 
reliability since we know the correct answer in each case. The 
simulated fit&#8217;s output results should agree with <tt class="docutils literal"><span class="pre">pexact</span></tt> 
(<tt class="docutils literal"><span class="pre">=fit.pmean</span></tt> here) within the simulated fit&#8217;s errors.</p>
<p>Simulated fits can also be used to estimate biases in the fit&#8217;s 
output parameters or functions of them, should non-Gaussian behavior 
arise. This is possible, again, because we know the correct value for 
every parameter before we do the fit. Again only a few iterations
may be needed for reliable estimates.</p>
<p>The (possibly non-Gaussian) probability distributions for parameters,
or functions of them, can be explored in more detail by setting option
<tt class="docutils literal"><span class="pre">bootstrap=True</span></tt> and collecting results from a large number of 
simulated fits. With <tt class="docutils literal"><span class="pre">bootstrap=True</span></tt>, the means of the priors are 
also varied from fit to fit, as in a bootstrap simulation; the new 
prior means are chosen at random from the prior distribution. 
Variations in the best-fit parameters (or functions of them) 
from fit to fit define the probability distributions for those 
quantities. For example, one would use the following code to 
analyze the distribution of function <tt class="docutils literal"><span class="pre">g(p)</span></tt> of the fit parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="o">...</span>

<span class="n">glist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">sfit</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">simulated_fit_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">glist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">sfit</span><span class="o">.</span><span class="n">pmean</span><span class="p">))</span>

<span class="o">...</span> <span class="n">analyze</span> <span class="n">samples</span> <span class="n">glist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="kn">from</span> <span class="nn">g</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">distribution</span> <span class="o">...</span>
</pre></div>
</div>
<p>This code generates <tt class="docutils literal"><span class="pre">n=100</span></tt> samples <tt class="docutils literal"><span class="pre">glist[i]</span></tt> from the 
probability distribution of <tt class="docutils literal"><span class="pre">g(p)</span></tt>. If everything is Gaussian,
the mean and standard deviation of <tt class="docutils literal"><span class="pre">glist[i]</span></tt> should agree 
with <tt class="docutils literal"><span class="pre">g(fit.p).mean</span></tt> and <tt class="docutils literal"><span class="pre">g(fit.p).sdev</span></tt>.</p>
<p>The only difference between simulated fits with <tt class="docutils literal"><span class="pre">bootstrap=True</span></tt>
and <tt class="docutils literal"><span class="pre">bootstrap=False</span></tt> (the default) is that the prior means are
varied. It is essential that they be varied in a bootstrap analysis
since one wants to capture the impact of the priors on the final 
distributions, but it is not necessary and probably not desirable
when simply testing a fit&#8217;s reliability.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (integer or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Maximum number of iterations (equals infinity if <tt class="docutils literal"><span class="pre">None</span></tt>).</li>
<li><strong>pexact</strong> (<tt class="docutils literal"><span class="pre">None</span></tt> or array or dictionary of numbers) &#8211; Fit-parameter values for the underlying distribution
used to generate simulated data; replaced by <tt class="docutils literal"><span class="pre">self.pmean</span></tt> if 
is <tt class="docutils literal"><span class="pre">None</span></tt> (default).</li>
<li><strong>bootstrap</strong> (<em>bool</em>) &#8211; Vary prior means if <tt class="docutils literal"><span class="pre">True</span></tt>; otherwise vary only
the means in <tt class="docutils literal"><span class="pre">self.y</span></tt> (default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator that returns <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></tt></a>s
for different simulated data.</p>
</td>
</tr>
</tbody>
</table>
<p>Note that additional keywords can be added to overwrite keyword 
arguments in <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.bootstrap_iter">
<tt class="descname">bootstrap_iter</tt><big>(</big><em>n=None</em>, <em>datalist=None</em><big>)</big><a class="headerlink" href="#lsqfit.nonlinear_fit.bootstrap_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that returns bootstrap copies of a fit.</p>
<p>A bootstrap analysis involves three steps: 1) make a large number
of &#8220;bootstrap copies&#8221; of the original input data and prior that differ
from each other by random amounts characteristic of the underlying
randomness in the original data; 2) repeat the entire fit analysis
for each bootstrap copy of the data, extracting fit results from
each; and 3) use the variation of the fit results from bootstrap
copy to bootstrap copy to determine an approximate probability
distribution (possibly non-gaussian) for the fit parameters and/or
functions of them: the results from each bootstrap fit are samples 
from that distribution.</p>
<p>Bootstrap copies of the data for step 2 are provided in
<tt class="docutils literal"><span class="pre">datalist</span></tt>. If <tt class="docutils literal"><span class="pre">datalist</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>, they are generated
instead from the means and covariance matrix of the fit data
(assuming gaussian statistics). The maximum number of bootstrap
copies considered is specified by <tt class="docutils literal"><span class="pre">n</span></tt> (<tt class="docutils literal"><span class="pre">None</span></tt> implies no
limit).</p>
<p>Variations in the best-fit parameters (or functions of them) 
from bootstrap fit to bootstrap fit define the probability 
distributions for those quantities. For example, one could use the 
following code to analyze the distribution of function <tt class="docutils literal"><span class="pre">g(p)</span></tt> 
of the fit parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="o">...</span>

<span class="n">glist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">sfit</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">bootstrapped_fit_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">datalist</span><span class="o">=</span><span class="n">datalist</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">glist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">sfit</span><span class="o">.</span><span class="n">pmean</span><span class="p">))</span>

<span class="o">...</span> <span class="n">analyze</span> <span class="n">samples</span> <span class="n">glist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="kn">from</span> <span class="nn">g</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">distribution</span> <span class="o">...</span>
</pre></div>
</div>
<p>This code generates <tt class="docutils literal"><span class="pre">n=100</span></tt> samples <tt class="docutils literal"><span class="pre">glist[i]</span></tt> from the 
probability distribution of <tt class="docutils literal"><span class="pre">g(p)</span></tt>. If everything is Gaussian,
the mean and standard deviation of <tt class="docutils literal"><span class="pre">glist[i]</span></tt> should agree 
with <tt class="docutils literal"><span class="pre">g(fit.p).mean</span></tt> and <tt class="docutils literal"><span class="pre">g(fit.p).sdev</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>integer</em>) &#8211; Maximum number of iterations if <tt class="docutils literal"><span class="pre">n</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt>;
otherwise there is no maximum.</li>
<li><strong>datalist</strong> (sequence or iterator or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Collection of bootstrap <tt class="docutils literal"><span class="pre">data</span></tt> sets for fitter.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Iterator that returns an <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></tt></a> object 
containing results from the fit to the next data set in
<tt class="docutils literal"><span class="pre">datalist</span></tt></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.dump_p">
<tt class="descname">dump_p</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#lsqfit.nonlinear_fit.dump_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump parameter values (<tt class="docutils literal"><span class="pre">fit.p</span></tt>) into file <tt class="docutils literal"><span class="pre">filename</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">fit.dump_p(filename)</span></tt> saves the best-fit parameter values
(<tt class="docutils literal"><span class="pre">fit.p</span></tt>) from a <tt class="docutils literal"><span class="pre">nonlinear_fit</span></tt> called <tt class="docutils literal"><span class="pre">fit</span></tt>. These values
are recovered using 
<tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">nonlinear_fit.load_parameters(filename)</span></tt>
where <tt class="docutils literal"><span class="pre">p</span></tt>&#8216;s layout is the same as that of <tt class="docutils literal"><span class="pre">fit.p</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.dump_pmean">
<tt class="descname">dump_pmean</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#lsqfit.nonlinear_fit.dump_pmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump parameter means (<tt class="docutils literal"><span class="pre">fit.pmean</span></tt>) into file <tt class="docutils literal"><span class="pre">filename</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">fit.dump_pmean(filename)</span></tt> saves the means of the best-fit
parameter values (<tt class="docutils literal"><span class="pre">fit.pmean</span></tt>) from a <tt class="docutils literal"><span class="pre">nonlinear_fit</span></tt> called
<tt class="docutils literal"><span class="pre">fit</span></tt>. These values are recovered using 
<tt class="docutils literal"><span class="pre">p0</span> <span class="pre">=</span> <span class="pre">nonlinear_fit.load_parameters(filename)</span></tt> 
where <tt class="docutils literal"><span class="pre">p0</span></tt>&#8216;s layout is the same as <tt class="docutils literal"><span class="pre">fit.pmean</span></tt>. The saved
values can be used to initialize a later fit (<tt class="docutils literal"><span class="pre">nonlinear_fit</span></tt>
parameter <tt class="docutils literal"><span class="pre">p0</span></tt>).</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lsqfit.nonlinear_fit.load_parameters">
<em class="property">static </em><tt class="descname">load_parameters</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#lsqfit.nonlinear_fit.load_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Load parameters stored in file <tt class="docutils literal"><span class="pre">filename</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">nonlinear_fit.load_p(filename)</span></tt> is used to recover the
values of fit parameters dumped using <tt class="docutils literal"><span class="pre">fit.dump_p(filename)</span></tt> (or
<tt class="docutils literal"><span class="pre">fit.dump_pmean(filename)</span></tt>) where <tt class="docutils literal"><span class="pre">fit</span></tt> is of type
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></tt></a>. The layout of the returned
parameters <tt class="docutils literal"><span class="pre">p</span></tt> is the same as that of <tt class="docutils literal"><span class="pre">fit.p</span></tt> (or
<tt class="docutils literal"><span class="pre">fit.pmean</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.check_roundoff">
<tt class="descname">check_roundoff</tt><big>(</big><em>rtol=0.25</em>, <em>atol=1e-6</em><big>)</big><a class="headerlink" href="#lsqfit.nonlinear_fit.check_roundoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for roundoff errors in fit.p.</p>
<p>Compares standard deviations from fit.p and fit.palt to see if they
agree to within relative tolerance <tt class="docutils literal"><span class="pre">rtol</span></tt> and absolute tolerance
<tt class="docutils literal"><span class="pre">atol</span></tt>. Generates a warning if they do not (in which
case an <em>svd</em> cut might be advisable).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="lsqfit.empbayes_fit">
<tt class="descclassname">lsqfit.</tt><tt class="descname">empbayes_fit</tt><big>(</big><em>z0</em>, <em>fitargs</em>, <em>**minargs</em><big>)</big><a class="headerlink" href="#lsqfit.empbayes_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Call <tt class="docutils literal"><span class="pre">lsqfit.nonlinear_fit(**fitargs(z))</span></tt> varying <tt class="docutils literal"><span class="pre">z</span></tt>,
starting at <tt class="docutils literal"><span class="pre">z0</span></tt>, to maximize <tt class="docutils literal"><span class="pre">logGBF</span></tt> (empirical Bayes procedure).</p>
<p>The fit is redone for each value of <tt class="docutils literal"><span class="pre">z</span></tt> that is tried, in order
to determine <tt class="docutils literal"><span class="pre">logGBF</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z0</strong> (<em>array</em>) &#8211; Starting point for search.</li>
<li><strong>fitargs</strong> (<em>function</em>) &#8211; Function of array <tt class="docutils literal"><span class="pre">z</span></tt> that determines which fit 
parameters to use. The function returns these as an argument
dictionary for <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><tt class="xref py py-func docutils literal"><span class="pre">lsqfit.nonlinear_fit()</span></tt></a>.</li>
<li><strong>minargs</strong> (<em>dictionary</em>) &#8211; Optional argument dictionary, passed on to 
<a class="reference internal" href="#lsqfit.multiminex" title="lsqfit.multiminex"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.multiminex</span></tt></a>, which finds the minimum.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple containing the best fit (object of type 
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><tt class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></tt></a>) and the optimal value for parameter <tt class="docutils literal"><span class="pre">z</span></tt>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lsqfit.wavg">
<tt class="descclassname">lsqfit.</tt><tt class="descname">wavg</tt><big>(</big><em>dataseq</em>, <em>prior=None</em>, <em>fast=False</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#lsqfit.wavg" title="Permalink to this definition">¶</a></dt>
<dd><p>Weighted average of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s or arrays/dicts of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s.</p>
<p>The weighted average of several <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s is what one obtains from
a  least-squares fit of the collection of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s to the
one-parameter fit function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">p</span><span class="p">):</span> 
    <span class="k">return</span> <span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">N</span></tt> is the number of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s. The average is the best-fit 
value for <tt class="docutils literal"><span class="pre">p[0]</span></tt>.  <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s with smaller standard deviations carry 
more weight than those with larger standard deviations. The averages
computed by <tt class="docutils literal"><span class="pre">wavg</span></tt> take account of correlations between the <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s.</p>
<p>If <tt class="docutils literal"><span class="pre">prior</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt>, it is added to the list of data 
used in the average. Thus <tt class="docutils literal"><span class="pre">wavg([x2,</span> <span class="pre">x3],</span> <span class="pre">prior=x1)</span></tt> is the 
same as <tt class="docutils literal"><span class="pre">wavg([x1,</span> <span class="pre">x2,</span> <span class="pre">x3])</span></tt>.</p>
<p>Typical usage is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x1</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">x3</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">xavg</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">])</span>   <span class="c"># weighted average of x1, x2 and x3</span>
</pre></div>
</div>
<p>where the result <tt class="docutils literal"><span class="pre">xavg</span></tt> is a <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a> containing the weighted average.</p>
<p>The individual <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s in the last example can be  replaced by
multidimensional distributions, represented by arrays of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s
or dictionaries of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s (or arrays of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s). For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x1</span> <span class="o">=</span> <span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)]</span>
<span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)]</span>
<span class="n">x3</span> <span class="o">=</span> <span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)]</span>
<span class="n">xavg</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">])</span>   
    <span class="c"># xavg[i] is wgtd avg of x1[i], x2[i], x3[i]</span>
</pre></div>
</div>
<p>where each array <tt class="docutils literal"><span class="pre">x1</span></tt>, <tt class="docutils literal"><span class="pre">x2</span></tt> ... must have the same shape. 
The result <tt class="docutils literal"><span class="pre">xavg</span></tt> in this case is an array of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s, where 
the shape of the array is the same as that of <tt class="docutils literal"><span class="pre">x1</span></tt>, etc.</p>
<p>Another example is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)],</span> <span class="n">b</span><span class="o">=</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">x2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)],</span> <span class="n">b</span><span class="o">=</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">x3</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="o">...</span><span class="p">)])</span>
<span class="n">xavg</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">])</span>   
    <span class="c"># xavg[&#39;a&#39;][i] is wgtd avg of x1[&#39;a&#39;][i], x2[&#39;a&#39;][i], x3[&#39;a&#39;][i]</span>
    <span class="c"># xavg[&#39;b&#39;] is gtd avg of x1[&#39;b&#39;], x2[&#39;b&#39;]  </span>
</pre></div>
</div>
<p>where different dictionaries can have (some) different keys. Here the 
result <tt class="docutils literal"><span class="pre">xavg</span></tt> is a <tt class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict`</span></tt> having the same keys as
<tt class="docutils literal"><span class="pre">x1</span></tt>, etc.</p>
<p>Weighted averages can become costly when the number of random samples being 
averaged is large (100s or more). In such cases it might be useful to set
parameter <tt class="docutils literal"><span class="pre">fast=True</span></tt>. This causes <tt class="docutils literal"><span class="pre">wavg</span></tt> to estimate the weighted 
average by incorporating the random samples one at a time into a 
running average:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="n">prior</span>
<span class="k">for</span> <span class="n">dataseq_i</span> <span class="ow">in</span> <span class="n">dataseq</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">result</span><span class="p">,</span> <span class="n">dataseq_i</span><span class="p">],</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>This method is much faster when <tt class="docutils literal"><span class="pre">len(dataseq)</span></tt> is large, and gives the
exact result when there are no correlations between different elements
of list <tt class="docutils literal"><span class="pre">dataseq</span></tt>. The results are approximately correct when 
<tt class="docutils literal"><span class="pre">dataseq[i]</span></tt> and <tt class="docutils literal"><span class="pre">dataseq[j]</span></tt> are correlated for <tt class="docutils literal"><span class="pre">i!=j</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dataseq</strong> &#8211; The <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s to be averaged. <tt class="docutils literal"><span class="pre">dataseq</span></tt> is a one-dimensional
sequence of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s, or of arrays of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s, or of dictionaries 
containing <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s or arrays of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s. All <tt class="docutils literal"><span class="pre">dataseq[i]</span></tt> must
have the same shape.</li>
<li><strong>prior</strong> (<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a> or array/dictionary of <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s) &#8211; Prior values for the averages, to be included in the weighted
average. Default value is <tt class="docutils literal"><span class="pre">None</span></tt>, in which case <tt class="docutils literal"><span class="pre">prior</span></tt> is ignored.</li>
<li><strong>fast</strong> (<em>bool</em>) &#8211; Setting <tt class="docutils literal"><span class="pre">fast=True</span></tt> causes <tt class="docutils literal"><span class="pre">wavg</span></tt> to compute an 
approximation to the weighted average that is much faster to calculate 
when averaging a large number of samples (100s or more). The default is 
<tt class="docutils literal"><span class="pre">fast=False</span></tt>.</li>
<li><strong>kargs</strong> (<em>dict</em>) &#8211; Additional arguments (e.g., <tt class="docutils literal"><span class="pre">svdcut</span></tt>) to the fitter 
used to do the averaging.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following function attributes are also set:</p>
<dl class="attribute">
<dt id="lsqfit.wavg.chi2">
<tt class="descclassname">wavg.</tt><tt class="descname">chi2</tt><a class="headerlink" href="#lsqfit.wavg.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">chi**2</span></tt> for weighted average.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.wavg.dof">
<tt class="descclassname">wavg.</tt><tt class="descname">dof</tt><a class="headerlink" href="#lsqfit.wavg.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Effective number of degrees of freedom.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.wavg.Q">
<tt class="descclassname">wavg.</tt><tt class="descname">Q</tt><a class="headerlink" href="#lsqfit.wavg.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>The probability that the <tt class="docutils literal"><span class="pre">chi**2</span></tt> could have been larger, 
by chance, assuming that the data are all Gaussain and consistent
with each other. Values smaller than 0.1 or suggest that the 
data are not Gaussian or are inconsistent with each other. Also 
called the <em>p-value</em>.</p>
<p>Quality factor <cite>Q</cite> (or <em>p-value</em>) for fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.wavg.time">
<tt class="descclassname">wavg.</tt><tt class="descname">time</tt><a class="headerlink" href="#lsqfit.wavg.time" title="Permalink to this definition">¶</a></dt>
<dd><p>Time required to do average.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.wavg.svdcorrection">
<tt class="descclassname">wavg.</tt><tt class="descname">svdcorrection</tt><a class="headerlink" href="#lsqfit.wavg.svdcorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>The <em>svd</em> corrections made to the data when <tt class="docutils literal"><span class="pre">svdcut</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.wavg.fit">
<tt class="descclassname">wavg.</tt><tt class="descname">fit</tt><a class="headerlink" href="#lsqfit.wavg.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit output from average.</p>
</dd></dl>

<p>These same attributes are also attached to the output <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>, 
array or dictionary from <tt class="xref py py-func docutils literal"><span class="pre">gvar.wavg()</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="lsqfit.gammaQ">
<tt class="descclassname">lsqfit.</tt><tt class="descname">gammaQ</tt><big>(</big><big>)</big><a class="headerlink" href="#lsqfit.gammaQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized incomplete gamma function <tt class="docutils literal"><span class="pre">Q(a,x)</span> <span class="pre">=</span> <span class="pre">1-P(a,x)</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Q(a,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">1/Gamma(a)</span> <span class="pre">*</span> <span class="pre">\int_x^\infty</span> <span class="pre">dt</span> <span class="pre">exp(-t)</span> <span class="pre">t</span> <span class="pre">**</span> <span class="pre">(a-1)</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">P(a,</span> <span class="pre">x)</span></tt></p>
<p>Note that <tt class="docutils literal"><span class="pre">gammaQ(ndof/2.,</span> <span class="pre">chi2/2.)</span></tt> is the probabilty that one could
get a <tt class="docutils literal"><span class="pre">chi**2</span></tt> larger than <tt class="docutils literal"><span class="pre">chi2</span></tt> with <tt class="docutils literal"><span class="pre">ndof</span></tt> degrees 
of freedom even if the model used to construct <tt class="docutils literal"><span class="pre">chi2</span></tt> is correct.</p>
</dd></dl>

</div>
<div class="section" id="utility-classes">
<h2>Utility Classes<a class="headerlink" href="#utility-classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lsqfit.transform_p">
<em class="property">class </em><tt class="descclassname">lsqfit.</tt><tt class="descname">transform_p</tt><big>(</big><em>priorkeys</em>, <em>has_x=False</em><big>)</big><a class="headerlink" href="#lsqfit.transform_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorate fit function to allow log/sqrt-normal priors.</p>
<p>This decorator can be applied to fit functions whose parameters 
are stored in a dictionary-like object. It searches 
the parameter keys for string-valued keys of the 
form <tt class="docutils literal"><span class="pre">&quot;log(XX)&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;logXX&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;sqrt(XX)&quot;</span></tt>, or 
<tt class="docutils literal"><span class="pre">&quot;sqrtXX&quot;</span></tt> where <tt class="docutils literal"><span class="pre">&quot;XX&quot;</span></tt> is an arbitrary string. For each
such key it adds a new entry to the parameter dictionary
with key <tt class="docutils literal"><span class="pre">&quot;XX&quot;</span></tt> where:</p>
<div class="highlight-python"><div class="highlight"><pre>p[&quot;XX&quot;] = exp(p[k])    for k = &quot;log(XX)&quot; or &quot;logXX&quot;
</pre></div>
</div>
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre>p[&quot;XX&quot;] = p[k] ** 2    for k = &quot;sqrt(XX)&quot; or &quot;sqrtXX&quot;
</pre></div>
</div>
<p>This means that the fit function can be expressed entirely in 
terms of <tt class="docutils literal"><span class="pre">p[&quot;XX&quot;]</span></tt> even if the actual fit parameter is 
the logarithm or square root of that quantity. Since fit 
parameters have gaussian/normal priors, <tt class="docutils literal"><span class="pre">p[&quot;XX&quot;]</span></tt> has 
a log-normal or &#8220;sqrt-normal&#8221; distribution in the first
or second cases above, respectively. In either case
<tt class="docutils literal"><span class="pre">p[&quot;XX&quot;]</span></tt> is guaranteed to be postiive.</p>
<p>This is a convenience function. It allows for the 
rapid replacement of a fit parameter by its 
logarithm or square root without having to rewrite the
fit function &#8212; only the prior need be changed. The decorator
needs to be told if the fit function has an <tt class="docutils literal"><span class="pre">x</span></tt> as its 
first argument, followed by the parameters <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@lsqfit.transform_p</span><span class="p">(</span><span class="n">prior</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">has_x</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fitfcn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>versus</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@lsqfit.transform_p</span><span class="p">(</span><span class="n">prior</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">fitfcn</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>A list of the specific keys that need transforming can be used instead
of the list of all keys (<tt class="docutils literal"><span class="pre">prior.keys()</span></tt>). The decorator assigns a copy 
of itself to the function as an attribute: <tt class="docutils literal"><span class="pre">fitfcn.transform_p</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>priorkeys</strong> (<em>sequence</em>) &#8211; The keys in the prior that are to be tranformed. 
Other keys can be in <tt class="docutils literal"><span class="pre">priorkeys</span></tt> provided they do not begin
with <tt class="docutils literal"><span class="pre">'log'</span></tt> or <tt class="docutils literal"><span class="pre">'sqrt'</span></tt> &#8212; they are ignored.</li>
<li><strong>has_x</strong> &#8211; Set equal to <tt class="docutils literal"><span class="pre">True</span></tt> if the fit function is a function
of <tt class="docutils literal"><span class="pre">x</span></tt> and parameters <tt class="docutils literal"><span class="pre">p</span></tt> (<em>i.e.</em>, <tt class="docutils literal"><span class="pre">f(x,p)</span></tt>). Set equal to 
<tt class="docutils literal"><span class="pre">False</span></tt> if the fit function is a function only of the parameters
(<em>i.e.</em>, <tt class="docutils literal"><span class="pre">f(p)</span></tt>). Default is <tt class="docutils literal"><span class="pre">False</span></tt>.</li>
<li><strong>pkey</strong> (<em>string or None</em>) &#8211; Name of the parameters-variable in the argument keyword
dictionary of the fit function. Default value is <tt class="docutils literal"><span class="pre">None</span></tt>; one of 
<tt class="docutils literal"><span class="pre">pkey</span></tt> or <tt class="docutils literal"><span class="pre">pindex</span></tt> must be specified (i.e., <tt class="docutils literal"><span class="pre">not</span> <span class="pre">None</span></tt>),
unless the fit function has only a single argument.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lsqfit.transform_p.transform">
<tt class="descname">transform</tt><big>(</big><em>p</em><big>)</big><a class="headerlink" href="#lsqfit.transform_p.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Create transformed copy of dictionary <tt class="docutils literal"><span class="pre">p</span></tt>.</p>
<p>Create a copy of parameter-dictionary <tt class="docutils literal"><span class="pre">p</span></tt> 
that includes new entries for 
each <tt class="docutils literal"><span class="pre">&quot;logXX&quot;</span></tt>, etc entry corresponding to
<tt class="docutils literal"><span class="pre">&quot;XX&quot;</span></tt>. The values in <tt class="docutils literal"><span class="pre">p</span></tt> can be any type that 
supports logarithms, exponentials, and arithmetic.</p>
</dd></dl>

<dl class="method">
<dt id="lsqfit.transform_p.untransform">
<tt class="descname">untransform</tt><big>(</big><em>p</em><big>)</big><a class="headerlink" href="#lsqfit.transform_p.untransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo <tt class="docutils literal"><span class="pre">self.transform(p)</span></tt>.</p>
<p>Reconstruct <tt class="docutils literal"><span class="pre">p0</span></tt> where <tt class="docutils literal"><span class="pre">p</span> <span class="pre">==</span> <span class="pre">self.transform(p0)</span></tt>; that
is remove entries for keys <tt class="docutils literal"><span class="pre">&quot;XX&quot;</span></tt> that were added by
by <a class="reference internal" href="#lsqfit.transform_p.transform" title="lsqfit.transform_p.transform"><tt class="xref py py-func docutils literal"><span class="pre">transform_p.transform()</span></tt></a> (because <tt class="docutils literal"><span class="pre">&quot;logXX&quot;</span></tt> or 
<tt class="docutils literal"><span class="pre">&quot;sqrtXX&quot;</span></tt> or ... appeared in <tt class="docutils literal"><span class="pre">p0</span></tt>).</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lsqfit.transform_p.paramkey">
<em class="property">static </em><tt class="descname">paramkey</tt><big>(</big><em>k</em><big>)</big><a class="headerlink" href="#lsqfit.transform_p.paramkey" title="Permalink to this definition">¶</a></dt>
<dd><p>Return parameter key corresponding to prior-key <tt class="docutils literal"><span class="pre">k</span></tt>.</p>
<p>Strip off any <tt class="docutils literal"><span class="pre">&quot;log&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;sqrt&quot;</span></tt> prefix.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lsqfit.transform_p.priorkey">
<em class="property">static </em><tt class="descname">priorkey</tt><big>(</big><em>prior</em>, <em>k</em><big>)</big><a class="headerlink" href="#lsqfit.transform_p.priorkey" title="Permalink to this definition">¶</a></dt>
<dd><p>Return key in <tt class="docutils literal"><span class="pre">prior</span></tt> corresponding to <tt class="docutils literal"><span class="pre">k</span></tt>.</p>
<p>Add in <tt class="docutils literal"><span class="pre">&quot;log&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;sqrt&quot;</span></tt> as needed to find a key
in <tt class="docutils literal"><span class="pre">prior</span></tt>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lsqfit.multifit">
<em class="property">class </em><tt class="descclassname">lsqfit.</tt><tt class="descname">multifit</tt><big>(</big><em>x0</em>, <em>n</em>, <em>f</em>, <em>reltol=1e-4</em>, <em>abstol=0</em>, <em>maxit=1000</em>, <em>alg='lmsder'</em>, <em>analyzer=None</em><big>)</big><a class="headerlink" href="#lsqfit.multifit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fitter for nonlinear least-squares multidimensional fits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x0</strong> (<tt class="xref py py-class docutils literal"><span class="pre">numpy</span></tt> array of floats) &#8211; Starting point for minimization.</li>
<li><strong>n</strong> (<em>positive integer</em>) &#8211; Length of vector returned by the fit function <tt class="docutils literal"><span class="pre">f(x)</span></tt>.</li>
<li><strong>f</strong> (<em>function</em>) &#8211; Fit function: <a class="reference internal" href="#lsqfit.multifit" title="lsqfit.multifit"><tt class="xref py py-class docutils literal"><span class="pre">multifit</span></tt></a> minimizes <tt class="docutils literal"><span class="pre">sum_i</span> <span class="pre">f_i(x)**2</span></tt>
by varying parameters <tt class="docutils literal"><span class="pre">x</span></tt>. The parameters are a 1-d 
<tt class="xref py py-class docutils literal"><span class="pre">numpy</span></tt> array of either numbers or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt></a>s.</li>
<li><strong>reltol</strong> (<em>float</em>) &#8211; The fit stops when <tt class="docutils literal"><span class="pre">|dx_i|</span> <span class="pre">&lt;</span> <span class="pre">abstol</span> <span class="pre">+</span> <span class="pre">reltol</span> <span class="pre">*</span> <span class="pre">|x_i|</span></tt>; 
default value is <tt class="docutils literal"><span class="pre">1e-4</span></tt>.</li>
<li><strong>abstol</strong> (<em>float</em>) &#8211; The fit stops when <tt class="docutils literal"><span class="pre">|dx_i|</span> <span class="pre">&lt;</span> <span class="pre">abstol</span> <span class="pre">+</span> <span class="pre">reltol</span> <span class="pre">*</span> <span class="pre">|x_i|</span></tt>; 
default value is <tt class="docutils literal"><span class="pre">0.0</span></tt>.</li>
<li><strong>maxit</strong> (<em>integer</em>) &#8211; Maximum number of iterations in search for minimum; 
default is 1000.</li>
<li><strong>alg</strong> (<em>string</em>) &#8211; <em>GSL</em> algorithm to use for minimization. Two options are 
currently available: <tt class="docutils literal"><span class="pre">&quot;lmsder&quot;</span></tt>, the scaled <em>LMDER</em> algorithm
(default); and <tt class="docutils literal"><span class="pre">&quot;lmder&quot;</span></tt>, the unscaled <em>LMDER</em> algorithm.</li>
<li><strong>analyzer</strong> (<em>function</em>) &#8211; Optional function of <tt class="docutils literal"><span class="pre">x,</span> <span class="pre">[...f_i(x)...],</span> <span class="pre">[[..df_ij(x)..]]</span></tt> 
which is called after each iteration. This can be used to inspect
intermediate steps in the minimization, if needed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#lsqfit.multifit" title="lsqfit.multifit"><tt class="xref py py-class docutils literal"><span class="pre">multifit</span></tt></a> is a function-class whose constructor does a least
squares fit by minimizing <tt class="docutils literal"><span class="pre">sum_i</span> <span class="pre">f_i(x)**2</span></tt> as a function of 
vector <tt class="docutils literal"><span class="pre">x</span></tt>. The following attributes are available:</p>
<dl class="attribute">
<dt id="lsqfit.multifit.x">
<tt class="descname">x</tt><a class="headerlink" href="#lsqfit.multifit.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Location of the most recently computed (best) fit point.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multifit.cov">
<tt class="descname">cov</tt><a class="headerlink" href="#lsqfit.multifit.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Covariance matrix at the minimum point.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multifit.f">
<tt class="descname">f</tt><a class="headerlink" href="#lsqfit.multifit.f" title="Permalink to this definition">¶</a></dt>
<dd><p>The fit function <tt class="docutils literal"><span class="pre">f(x)</span></tt> at the minimum in the most recent fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multifit.J">
<tt class="descname">J</tt><a class="headerlink" href="#lsqfit.multifit.J" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient <tt class="docutils literal"><span class="pre">J_ij</span> <span class="pre">=</span> <span class="pre">df_i/dx[j]</span></tt> for most recent fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multifit.nit">
<tt class="descname">nit</tt><a class="headerlink" href="#lsqfit.multifit.nit" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterations used in last fit to find the minimum.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multifit.error">
<tt class="descname">error</tt><a class="headerlink" href="#lsqfit.multifit.error" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">None</span></tt> if fit successful; an error message otherwise.</p>
</dd></dl>

<p><a class="reference internal" href="#lsqfit.multifit" title="lsqfit.multifit"><tt class="xref py py-class docutils literal"><span class="pre">multifit</span></tt></a> is a wrapper for the <tt class="docutils literal"><span class="pre">multifit</span></tt> <em>GSL</em> routine.</p>
</dd></dl>

<dl class="class">
<dt id="lsqfit.multiminex">
<em class="property">class </em><tt class="descclassname">lsqfit.</tt><tt class="descname">multiminex</tt><big>(</big><em>x0</em>, <em>f</em>, <em>tol=1e-4</em>, <em>maxit=1000</em>, <em>step=1</em>, <em>alg='nmsimplex2'</em>, <em>analyzer=None</em><big>)</big><a class="headerlink" href="#lsqfit.multiminex" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimizer for multidimensional functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x0</strong> (<tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> array of floats) &#8211; Starting point for minimization search.</li>
<li><strong>f</strong> (<em>function</em>) &#8211; Function <tt class="docutils literal"><span class="pre">f(x)</span></tt> to be minimized by varying vector <tt class="docutils literal"><span class="pre">x</span></tt>.</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; Minimization stops when <tt class="docutils literal"><span class="pre">x</span></tt> has converged to with 
tolerance <tt class="docutils literal"><span class="pre">tol</span></tt>; default is <tt class="docutils literal"><span class="pre">1e-4</span></tt>.</li>
<li><strong>maxit</strong> (<em>integer</em>) &#8211; Maximum number of iterations in search for minimum; 
default is 1000.</li>
<li><strong>step</strong> (<em>number</em>) &#8211; Initial step size to use in varying components of <tt class="docutils literal"><span class="pre">x</span></tt>;
default is 1.</li>
<li><strong>alg</strong> (<em>string</em>) &#8211; <em>GSL</em> algorithm to use for minimization. Three options are 
currently available: <tt class="docutils literal"><span class="pre">&quot;nmsimplex&quot;</span></tt>, Nelder Mead Simplex
algorithm; <tt class="docutils literal"><span class="pre">&quot;nmsimplex2&quot;</span></tt>, an improved version of
<tt class="docutils literal"><span class="pre">&quot;nmsimplex&quot;</span></tt> (default); and <tt class="docutils literal"><span class="pre">&quot;nmsimplex2rand&quot;</span></tt>, a version
of <tt class="docutils literal"><span class="pre">&quot;nmsimplex2&quot;</span></tt> with random shifts in the start position.</li>
<li><strong>analyzer</strong> (<em>function</em>) &#8211; Optional function of <tt class="docutils literal"><span class="pre">x,</span> <span class="pre">f(x),</span> <span class="pre">it</span></tt>, where <tt class="docutils literal"><span class="pre">it</span></tt> is
the iteration number, which is called after each iteration.
This can be used to inspect intermediate steps in the
minimization, if needed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#lsqfit.multiminex" title="lsqfit.multiminex"><tt class="xref py py-class docutils literal"><span class="pre">multiminex</span></tt></a> is a function-class whose constructor minimizes a
multidimensional function <tt class="docutils literal"><span class="pre">f(x)</span></tt> by varying vector <tt class="docutils literal"><span class="pre">x</span></tt>. This routine
does <em>not</em> use user-supplied information about the gradient of <tt class="docutils literal"><span class="pre">f(x)</span></tt>.
The following attributes are available:</p>
<dl class="attribute">
<dt id="lsqfit.multiminex.x">
<tt class="descname">x</tt><a class="headerlink" href="#lsqfit.multiminex.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Location of the most recently computed minimum (1-d array).</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multiminex.f">
<tt class="descname">f</tt><a class="headerlink" href="#lsqfit.multiminex.f" title="Permalink to this definition">¶</a></dt>
<dd><p>Value of function <tt class="docutils literal"><span class="pre">f(x)</span></tt> at the most recently computed minimum.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multiminex.nit">
<tt class="descname">nit</tt><a class="headerlink" href="#lsqfit.multiminex.nit" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterations required to find most recent minimum.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.multiminex.error">
<tt class="descname">error</tt><a class="headerlink" href="#lsqfit.multiminex.error" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">None</span></tt> if fit successful; an error message otherwise.</p>
</dd></dl>

<p><a class="reference internal" href="#lsqfit.multiminex" title="lsqfit.multiminex"><tt class="xref py py-class docutils literal"><span class="pre">multiminex</span></tt></a> is a wrapper for the <tt class="docutils literal"><span class="pre">multimin</span></tt> <em>GSL</em> routine.</p>
</dd></dl>

</div>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><tt class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></tt></a> relies heavily on the <a class="reference internal" href="gvar.html#module-gvar" title="gvar: Correlated Gaussian random variables."><tt class="xref py py-mod docutils literal"><span class="pre">gvar</span></tt></a>, and <tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> modules.
Several utility functions are in <tt class="xref py py-mod docutils literal"><span class="pre">lsqfit_util</span></tt>. Also the minimization
routines are from the Gnu Scientific Library (<em>GSL</em>).</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">lsqfit</span></tt> - Nonlinear Least Squares Fitting</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#formal-background">Formal Background</a></li>
<li><a class="reference internal" href="#nonlinear-fit-objects">nonlinear_fit Objects</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#utility-classes">Utility Classes</a></li>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="gvar_other.html"
                        title="previous chapter">Numerical Analysis Modules in <tt class="docutils literal"><span class="pre">gvar</span></tt></a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gvar_other.html" title="Numerical Analysis Modules in gvar"
             >previous</a> |</li>
        <li><a href="index.html">lsqfit 4.8.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009-2013, G. P. Lepage.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>