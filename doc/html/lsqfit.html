
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>lsqfit - Nonlinear Least Squares Fitting &#8212; lsqfit 13 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pyramid.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="GSL Routines" href="gsl.html" />
    <link rel="prev" title="Case Study: Outliers and Bayesian Integrals" href="case-outliers.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gsl.html" title="GSL Routines"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="case-outliers.html" title="Case Study: Outliers and Bayesian Integrals"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">lsqfit 13 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code> - Nonlinear Least Squares Fitting</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="lsqfit-nonlinear-least-squares-fitting">
<h1><a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> - Nonlinear Least Squares Fitting<a class="headerlink" href="#lsqfit-nonlinear-least-squares-fitting" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-lsqfit"></span><section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This package contains tools for nonlinear least-squares curve fitting of
data. In general a fit has four inputs:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The dependent data <code class="docutils literal notranslate"><span class="pre">y</span></code> that is to be fit — typically <code class="docutils literal notranslate"><span class="pre">y</span></code>
is a Python dictionary in an <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> analysis. Its values
<code class="docutils literal notranslate"><span class="pre">y[k]</span></code> are either <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or arrays (any shape or dimension) of
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s that specify the values of the dependent variables
and their errors.</p></li>
<li><p>A collection <code class="docutils literal notranslate"><span class="pre">x</span></code> of independent data — <code class="docutils literal notranslate"><span class="pre">x</span></code> can have any
structure and contain any data, or it can be omitted.</p></li>
<li><p>A fit function <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">p)</span></code> whose parameters <code class="docutils literal notranslate"><span class="pre">p</span></code> are adjusted by
the fit until <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">p)</span></code> equals <code class="docutils literal notranslate"><span class="pre">y</span></code> to within <code class="docutils literal notranslate"><span class="pre">y</span></code>s errors
— parameters <cite>p`</cite> are usually specified by a dictionary whose
values <code class="docutils literal notranslate"><span class="pre">p[k]</span></code> are individual parameters or (<code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code>)
arrays of parameters. The fit function is assumed independent
of <code class="docutils literal notranslate"><span class="pre">x</span></code> (that is, <code class="docutils literal notranslate"><span class="pre">f(p)</span></code>) if <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">False</span></code> (or if <code class="docutils literal notranslate"><span class="pre">x</span></code> is
omitted from the input data).</p></li>
<li><p>Initial estimates or <em>priors</em> for each parameter in <code class="docutils literal notranslate"><span class="pre">p</span></code>
— priors are usually specified using a dictionary <code class="docutils literal notranslate"><span class="pre">prior</span></code>
whose values <code class="docutils literal notranslate"><span class="pre">prior[k]</span></code> are <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s that
give initial estimates (values and errors) for parameters <code class="docutils literal notranslate"><span class="pre">p[k]</span></code>.</p></li>
</ol>
</div></blockquote>
<p>A typical code sequence has the structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="n">collect</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">prior</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">compute</span> <span class="n">fit</span> <span class="n">to</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">y</span><span class="p">,</span> <span class="n">using</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">...</span>
    <span class="o">...</span> <span class="k">return</span> <span class="n">dictionary</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">fit</span> <span class="n">values</span> <span class="k">for</span> <span class="n">the</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="n">s</span> <span class="o">...</span>

<span class="n">fit</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">fcn</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>      <span class="c1"># variable fit is of type nonlinear_fit</span>
</pre></div>
</div>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">p[k]</span></code> are varied until the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> for the fit is
minimized.</p>
<p>The best-fit values for the parameters are recovered after fitting
using, for example, <code class="docutils literal notranslate"><span class="pre">p=fit.p</span></code>. Then the <code class="docutils literal notranslate"><span class="pre">p[k]</span></code> are <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or
arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s that give best-fit estimates and fit uncertainties
in those estimates (as well as the correlations between them).
The <code class="docutils literal notranslate"><span class="pre">print(fit)</span></code> statement prints a summary of the fit results.</p>
<p>The dependent variable <code class="docutils literal notranslate"><span class="pre">y</span></code> above could be an array instead of a
dictionary, which is less flexible in general but possibly more
convenient in simpler fits. Then the approximate <code class="docutils literal notranslate"><span class="pre">y</span></code> returned by fit
function <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">p)</span></code> must be an array with the same shape as the dependent
variable. The prior <code class="docutils literal notranslate"><span class="pre">prior</span></code> could also be represented by an array
instead of a dictionary.</p>
<p>By default priors are Gaussian/normal distributions, represented by
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s. <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> also
allows for log-normal and other distributions as well. The
latter are indicated by replacing the prior (in a dictionary prior)
with key <code class="docutils literal notranslate"><span class="pre">c</span></code>,  for example, by a prior for the parameter’s logarithm,
with key <code class="docutils literal notranslate"><span class="pre">log(c)</span></code>.
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">nonlinear_fit</span></code></a> in effect adds parameter <code class="docutils literal notranslate"><span class="pre">c</span></code> to the parameter
dictionary, deriving its value from parameter <code class="docutils literal notranslate"><span class="pre">log(c)</span></code>.
The fit function can be expressed directly in terms of
parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>  and so is the same no matter which distribution is
used for <code class="docutils literal notranslate"><span class="pre">c</span></code>. Additional distributions
can be added using <code class="xref py py-meth docutils literal notranslate"><span class="pre">gvar.BufferDict.add_distribution()</span></code>.</p>
<p>The <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> tutorial contains extended explanations and examples.
The first appendix in the paper at <a class="reference external" href="http://arxiv.org/abs/arXiv:1406.2279">http://arxiv.org/abs/arXiv:1406.2279</a>
provides conceptual background on the techniques used in this
module for fits and, especially, error budgets.</p>
</section>
<section id="nonlinear-fit-objects">
<h2>nonlinear_fit Objects<a class="headerlink" href="#nonlinear-fit-objects" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lsqfit.</span></span><span class="sig-name descname"><span class="pre">nonlinear_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fcn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prior</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">svdcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gsl_multifit'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">fitterargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Nonlinear least-squares fit.</p>
<p><a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> fits a (nonlinear) function <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">p)</span></code>
to data <code class="docutils literal notranslate"><span class="pre">y</span></code> by varying parameters <code class="docutils literal notranslate"><span class="pre">p</span></code>, and stores the results: for
example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">fcn</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>   <span class="c1"># do fit</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>                               <span class="c1"># print fit results</span>
</pre></div>
</div>
<p>The best-fit values for the parameters are in <code class="docutils literal notranslate"><span class="pre">fit.p</span></code>, while the
<code class="docutils literal notranslate"><span class="pre">chi**2</span></code>, the number of degrees of freedom, the logarithm of Gaussian
Bayes Factor, the number of iterations (or function evaluations),  and the
cpu time needed for the fit are in <code class="docutils literal notranslate"><span class="pre">fit.chi2</span></code>, <code class="docutils literal notranslate"><span class="pre">fit.dof</span></code>,
<code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code>, <code class="docutils literal notranslate"><span class="pre">fit.nit</span></code>, and <code class="docutils literal notranslate"><span class="pre">fit.time</span></code>, respectively. Results for
individual parameters in <code class="docutils literal notranslate"><span class="pre">fit.p</span></code> are of type <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>, and therefore carry
information about errors and correlations with other parameters. The fit
data and prior can be recovered using <code class="docutils literal notranslate"><span class="pre">fit.x</span></code> (equals <code class="docutils literal notranslate"><span class="pre">False</span></code> if there
is no <code class="docutils literal notranslate"><span class="pre">x</span></code>), <code class="docutils literal notranslate"><span class="pre">fit.y</span></code>, and <code class="docutils literal notranslate"><span class="pre">fit.prior</span></code>; the data and prior are
corrected for the SVD cut, if there is one (that is, their covariance
matrices have been modified in accordance with the SVD cut).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>dict</em><em>, </em><em>array</em><em> or </em><em>tuple</em>) – <p>Data to be fit by <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>
can have any of the following forms:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">x</span></code> is the independent data that is passed to the fit
function with the fit parameters: <code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. <code class="docutils literal notranslate"><span class="pre">y</span></code> is a
dictionary (or array) of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s that encode the means and
covariance matrix for the data that is to be fit being fit.
The fit function must return a result having the same
layout as <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">y</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">y</span></code> is a dictionary (or array) of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s that encode
the means and covariance matrix for the data being fit.
There is no independent data so the fit function depends
only upon the fit parameters: <code class="docutils literal notranslate"><span class="pre">fit(p)</span></code>. The fit function
must return a result having the same layout as <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">ymean,</span> <span class="pre">ycov</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">x</span></code> is the independent data that is passed to the fit
function with the fit parameters: <code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. <code class="docutils literal notranslate"><span class="pre">ymean</span></code>
is an array containing the mean values of the fit data.
<code class="docutils literal notranslate"><span class="pre">ycov</span></code> is an array containing the covariance matrix of
the fit data; <code class="docutils literal notranslate"><span class="pre">ycov.shape</span></code> equals <code class="docutils literal notranslate"><span class="pre">2*ymean.shape</span></code>.
The fit function must return an array having the same
shape as <code class="docutils literal notranslate"><span class="pre">ymean</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">ymean,</span> <span class="pre">ysdev</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">x</span></code> is the independent data that is passed to the fit
function with the fit parameters: <code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. <code class="docutils literal notranslate"><span class="pre">ymean</span></code>
is an array containing the mean values of the fit data.
<code class="docutils literal notranslate"><span class="pre">ysdev</span></code> is an array containing the standard deviations of
the fit data; <code class="docutils literal notranslate"><span class="pre">ysdev.shape</span></code> equals <code class="docutils literal notranslate"><span class="pre">ymean.shape</span></code>. The
data are assumed to be uncorrelated. The fit function must
return an array having the same shape as <code class="docutils literal notranslate"><span class="pre">ymean</span></code>.</p>
</dd>
</dl>
</div></blockquote>
<p>Setting <code class="docutils literal notranslate"><span class="pre">x=False</span></code> in the first, third or fourth of these formats
implies that the fit function depends only on the fit parameters:
that is, <code class="docutils literal notranslate"><span class="pre">fcn(p)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. (This is not assumed
if <code class="docutils literal notranslate"><span class="pre">x=None</span></code>.)</p>
</p></li>
<li><p><strong>fcn</strong> (<em>callable</em>) – The function to be fit to <code class="docutils literal notranslate"><span class="pre">data</span></code>. It is either a
function of the independent data <code class="docutils literal notranslate"><span class="pre">x</span></code> and the fit parameters <code class="docutils literal notranslate"><span class="pre">p</span></code>
(<code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>), or a function of just the fit parameters
(<code class="docutils literal notranslate"><span class="pre">fcn(p)</span></code>) when there is no <code class="docutils literal notranslate"><span class="pre">x</span></code> data or <code class="docutils literal notranslate"><span class="pre">x=False</span></code>. The
parameters are tuned in the fit until the function returns values
that agree with the <code class="docutils literal notranslate"><span class="pre">y</span></code> data to within the <code class="docutils literal notranslate"><span class="pre">y</span></code>s’ errors. The
function’s return value must have the same layout as the <code class="docutils literal notranslate"><span class="pre">y</span></code> data
(a dictionary or an array). The fit parameters <code class="docutils literal notranslate"><span class="pre">p</span></code> are either: 1)
a dictionary where each <code class="docutils literal notranslate"><span class="pre">p[k]</span></code> is a single parameter or an array
of parameters (any shape); or, 2) a single array of parameters. The
layout of the parameters is the same as that of prior <code class="docutils literal notranslate"><span class="pre">prior</span></code> if
it is specified; otherwise, it is inferred from of the starting
value <code class="docutils literal notranslate"><span class="pre">p0</span></code> for the fit.</p></li>
<li><p><strong>prior</strong> (<em>dict</em><em>, </em><em>array</em><em>, </em><em>str</em><em>, </em><em>gvar.GVar</em><em> or </em><em>None</em>) – A dictionary (or array)
containing <em>a priori</em> estimates for all parameters <code class="docutils literal notranslate"><span class="pre">p</span></code> used by
fit function <code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code> (or <code class="docutils literal notranslate"><span class="pre">fcn(p)</span></code>). Fit parameters <code class="docutils literal notranslate"><span class="pre">p</span></code>
are stored in a dictionary (or array) with the same keys and
structure (or shape) as <code class="docutils literal notranslate"><span class="pre">prior</span></code>. The default value is <code class="docutils literal notranslate"><span class="pre">None</span></code>;
<code class="docutils literal notranslate"><span class="pre">prior</span></code> must be defined if <code class="docutils literal notranslate"><span class="pre">p0</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><strong>p0</strong> (<em>dict</em><em>, </em><em>array</em><em>, </em><em>float</em><em>, </em><em>None</em><em>, or </em><em>True</em>) – Starting values for fit
parameters in fit. <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> adjusts <code class="docutils literal notranslate"><span class="pre">p0</span></code> to
make it consistent in shape and structure with <code class="docutils literal notranslate"><span class="pre">prior</span></code> when the
latter is specified: elements missing from <code class="docutils literal notranslate"><span class="pre">p0</span></code> are filled in
using <code class="docutils literal notranslate"><span class="pre">prior</span></code>, and elements in <code class="docutils literal notranslate"><span class="pre">p0</span></code> that are not in <code class="docutils literal notranslate"><span class="pre">prior</span></code>
are discarded. If <code class="docutils literal notranslate"><span class="pre">p0</span></code> is a string, it is taken as a file name
and <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> attempts to read starting values
from that file; best-fit parameter values are written out to the
same file after the fit (for priming future fits). If <code class="docutils literal notranslate"><span class="pre">p0</span></code> is
<code class="docutils literal notranslate"><span class="pre">None</span></code> or the attempt to read the file fails, starting values
are extracted from <code class="docutils literal notranslate"><span class="pre">prior</span></code>. If <code class="docutils literal notranslate"><span class="pre">p0</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, it
is replaced by a starting point drawn at random from the
<code class="docutils literal notranslate"><span class="pre">prior</span></code> distribution. The default value is <code class="docutils literal notranslate"><span class="pre">None</span></code>;
<code class="docutils literal notranslate"><span class="pre">p0</span></code> must be explicitly specified if <code class="docutils literal notranslate"><span class="pre">prior</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><strong>linear</strong> (<em>list</em><em> or </em><em>None</em>) – Optional list of fit parameters that appear
linearly in the fit function. The fit function can be reexpressed
(using <em>variable projection</em>) as a function that is independent of
its linear parameters. The resulting fit has fewer fit parameters
and typically will converge in fewer iterations, but each
iteration will take longer. Whether or not the fit is faster or
more robust in any particular application is a matter for
experiment, but answers should be the same either way. The linear
parameters are reconstructed from the nonlinear parameters (and
the data) after the fit. Parameter <code class="docutils literal notranslate"><span class="pre">linear</span></code> is either: a list of
dictionary keys corresponding to linear parameters when the
parameters are stored in a dictionary (see <code class="docutils literal notranslate"><span class="pre">prior</span></code>); or, a list
of indices corresponding to these parameters when they are stored
in an array. Note that this feature is experimental; the
interface may change in the future.</p></li>
<li><p><strong>eps</strong> (<em>float</em>) – If positive, singularities in the correlation matrix
for <code class="docutils literal notranslate"><span class="pre">g</span></code> are regulated using <code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.regulate()</span></code>
with cutoff <code class="docutils literal notranslate"><span class="pre">eps</span></code>. This makes the correlation matrices
less singular, which can improve the  stability and accuracy
of a fit. Ignored if <code class="docutils literal notranslate"><span class="pre">svdcut</span></code> is specified (and
not <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li>
<li><p><strong>svdcut</strong> (<em>float</em>) – If nonzero, singularities in the correlation
matrix are regulated using <code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.regulate()</span></code>
with an SVD cutoff <code class="docutils literal notranslate"><span class="pre">svdcut</span></code>. This makes the correlation
matrices less singular, which can improve the  stability and
accuracy of a fit. Default is <code class="docutils literal notranslate"><span class="pre">svdcut=1e-12</span></code>.</p></li>
<li><p><strong>noise</strong> (<em>tuple</em><em> or </em><em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">noise[0]=True</span></code>, noise is
added to the data and prior means corresponding to any
additional uncertainties introduced by using <code class="docutils literal notranslate"><span class="pre">eps&gt;0</span></code>
or <code class="docutils literal notranslate"><span class="pre">svdcut&gt;0</span></code>. If <code class="docutils literal notranslate"><span class="pre">noise[1]=True</span></code>, noise is added
to the prior means corresponding to the uncertainties
in the prior. Noise is useful for testing the
quality of a fit (<code class="docutils literal notranslate"><span class="pre">chi2</span></code>). Setting <code class="docutils literal notranslate"><span class="pre">noise=True</span></code>
is shorthand for <code class="docutils literal notranslate"><span class="pre">noise=(True,</span> <span class="pre">True)</span></code>, and
<code class="docutils literal notranslate"><span class="pre">noise=False</span></code> means <code class="docutils literal notranslate"><span class="pre">noise=(False,</span> <span class="pre">False)</span></code> (the default).</p></li>
<li><p><strong>udata</strong> (<em>dict</em><em>, </em><em>array</em><em> or </em><em>tuple</em>) – Same as <code class="docutils literal notranslate"><span class="pre">data</span></code> but instructs the fitter to ignore  correlations
between different pieces of data.  This speeds up the  fit,
particularly for large amounts of data, but ignores potentially
valuable information if the data actually are correlated. Only
one of <code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">udata</span></code> should be specified. (Default is
<code class="docutils literal notranslate"><span class="pre">None</span></code>.)</p></li>
<li><p><strong>fitter</strong> (<em>str</em><em> or </em><em>None</em>) – Fitter code. Options if GSL is installed
include: <code class="docutils literal notranslate"><span class="pre">'gsl_multifit'</span></code> (default) and <code class="docutils literal notranslate"><span class="pre">'gsl_v1_multifit'</span></code>
(original fitter). Options if <code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy</span></code> is installed include:
<code class="docutils literal notranslate"><span class="pre">'scipy_least_squares'</span></code> (default if GSL not installed).
<code class="docutils literal notranslate"><span class="pre">gsl_multifit</span></code> has many options, providing extensive user
control. <code class="docutils literal notranslate"><span class="pre">scipy_least_squares</span></code> can be used for fits where the
parameters are bounded. (Bounded parameters can also be
implemented, for any of the fitters, using non-Gaussian priors —
see the tutorial.)</p></li>
<li><p><strong>tol</strong> (<em>float</em><em> or </em><em>tuple</em>) – <p>Assigning <code class="docutils literal notranslate"><span class="pre">tol=(xtol,</span> <span class="pre">gtol,</span> <span class="pre">ftol)</span></code> causes the
fit to stop searching for a minimum when any of</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xtol</span> <span class="pre">&gt;=</span></code> relative change in parameters between iterations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gtol</span> <span class="pre">&gt;=</span></code> relative size of gradient of <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> function</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ftol</span> <span class="pre">&gt;=</span></code> relative change in <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> between iterations</p></li>
</ol>
</div></blockquote>
<p>is satisfied. See the fitter documentation for detailed
definitions of these stopping conditions. Typically one sets
<code class="docutils literal notranslate"><span class="pre">xtol=1/10**d</span></code> where <code class="docutils literal notranslate"><span class="pre">d</span></code> is the number of digits of precision
desired in the result, while <code class="docutils literal notranslate"><span class="pre">gtol&lt;&lt;1</span></code> and <code class="docutils literal notranslate"><span class="pre">ftol&lt;&lt;1</span></code>. Setting
<code class="docutils literal notranslate"><span class="pre">tol=delta</span></code> where <code class="docutils literal notranslate"><span class="pre">delta</span></code> is a number is equivalent to setting
<code class="docutils literal notranslate"><span class="pre">tol=(delta,1e-10,1e-10)</span></code>. Setting <code class="docutils literal notranslate"><span class="pre">tol=(delta1,delta2)</span></code> is
equivalent to setting <code class="docutils literal notranslate"><span class="pre">tol=(delta1,delta2,1e-10)</span></code>. Default is
<code class="docutils literal notranslate"><span class="pre">tol=1e-8</span></code>. (Note: the <code class="docutils literal notranslate"><span class="pre">ftol</span></code> option is disabled in some
versions of the GSL library.)</p>
</p></li>
<li><p><strong>maxit</strong> (<em>int</em>) – Maximum number of algorithm iterations (or function
evaluations for some fitters) in search for minimum;
default is 1000.</p></li>
<li><p><strong>debug</strong> (<em>bool</em>) – Set to <code class="docutils literal notranslate"><span class="pre">True</span></code> for extra debugging of the fit function
and a check for roundoff errors. (Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.)</p></li>
<li><p><strong>fitterargs</strong> (<em>dict</em>) – Dictionary of additional arguments passed through
to the underlying fitter. Different fitters offer different
parameters; see the documentation for each.</p></li>
</ul>
</dd>
</dl>
<p>Objects of type <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> have the following
attributes:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.chi2">
<span class="sig-name descname"><span class="pre">chi2</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> for the fit.
<code class="docutils literal notranslate"><span class="pre">fit.chi2</span> <span class="pre">/</span> <span class="pre">fit.dof</span></code> is usually of order one in good fits.
Values much less than one suggest that actual fluctuations in
the input data and/or priors might be smaller than suggested
by the standard deviations (or covariances) used in the fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.cov">
<span class="sig-name descname"><span class="pre">cov</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Covariance matrix of the best-fit parameters from
the fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.dof">
<span class="sig-name descname"><span class="pre">dof</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of degrees of freedom in the fit, which equals
the number of pieces of data being fit when priors are specified
for the fit parameters. Without priors, it is the number of pieces
of data minus the number of fit parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.error">
<span class="sig-name descname"><span class="pre">error</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Error message generated by the underlying fitter when
an error occurs. <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.fitter_results">
<span class="sig-name descname"><span class="pre">fitter_results</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.fitter_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Results returned by the underlying fitter. Refer to
the appropriate fitter’s documentation for details.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.logGBF">
<span class="sig-name descname"><span class="pre">logGBF</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.logGBF" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm of the probability (density)
of obtaining the fit data by randomly sampling the parameter model
(priors plus fit function) used in the fit — that is, it is
<code class="docutils literal notranslate"><span class="pre">P(data|model)</span></code>. This quantity is useful for comparing fits of
the same data to different models, with different priors and/or
fit functions. The model with the largest value of <code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code>
is the one preferred by the data. The exponential of the difference
in <code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code> between two models is the ratio of probabilities
(Bayes factor) for those models. Differences in <code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code>
smaller than 1 are not very significant. Gaussian statistics are
assumed when computing <code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.p">
<span class="sig-name descname"><span class="pre">p</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.p" title="Permalink to this definition">¶</a></dt>
<dd><p>Best-fit parameters from fit. Depending
upon what was used for the prior (or <code class="docutils literal notranslate"><span class="pre">p0</span></code>), it is either: a
dictionary (<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.BufferDict</span></code>) of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s and/or arrays of
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s; or an array (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.
<code class="docutils literal notranslate"><span class="pre">fit.p</span></code> represents a multi-dimensional Gaussian distribution
which, in Bayesian terminology, is the <em>posterior</em> probability
distribution of the fit parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict, array or gvar.GVar</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.pmean">
<span class="sig-name descname"><span class="pre">pmean</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.pmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Means of the best-fit parameters
from fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict, array or float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.psdev">
<span class="sig-name descname"><span class="pre">psdev</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.psdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard deviations of the best-fit
parameters from fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict, array or float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.palt">
<span class="sig-name descname"><span class="pre">palt</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.palt" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <code class="docutils literal notranslate"><span class="pre">fit.p</span></code> except that the errors
are computed directly from <code class="docutils literal notranslate"><span class="pre">fit.cov</span></code>. This is faster but means
that no information about correlations with the input data is
retained (unlike in <code class="docutils literal notranslate"><span class="pre">fit.p</span></code>); and, therefore, <code class="docutils literal notranslate"><span class="pre">fit.palt</span></code>
cannot be used to generate error budgets. <code class="docutils literal notranslate"><span class="pre">fit.p</span></code> and
<code class="docutils literal notranslate"><span class="pre">fit.palt</span></code> give the same means and normally give the same errors
for each parameter. They differ only when the input data’s
covariance matrix is too singular to invert accurately (because of
roundoff error), in which case refitting with a nonzero value
for <code class="docutils literal notranslate"><span class="pre">eps</span></code> or <code class="docutils literal notranslate"><span class="pre">svdcut</span></code> is advisable.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict, array or gvar.GVar</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.p0">
<span class="sig-name descname"><span class="pre">p0</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.p0" title="Permalink to this definition">¶</a></dt>
<dd><p>The parameter values used to start the fit.
This will differ from the input <code class="docutils literal notranslate"><span class="pre">p0</span></code> if the latter was
incomplete.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict, array or float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.prior">
<span class="sig-name descname"><span class="pre">prior</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.prior" title="Permalink to this definition">¶</a></dt>
<dd><p>Prior used in the fit. This may
differ  from the input prior if an SVD cut is used. It is either
a  dictionary (<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.BufferDict</span></code>) or an array
(<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>), depending upon the input. Equals
<code class="docutils literal notranslate"><span class="pre">None</span></code> if no prior was specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict, array, gvar.GVar or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.Q">
<span class="sig-name descname"><span class="pre">Q</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>The probability that the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> from the fit
could have been larger, by chance, assuming the best-fit model
is correct. Good fits have <code class="docutils literal notranslate"><span class="pre">Q</span></code> values larger than 0.1 or so.
Also called the <em>p-value</em> of the fit. The probabilistic
intrepretation becomes unreliable if the actual fluctuations
in the input data and/or priors are much smaller than suggested
by the standard deviations (or covariances) used in the fit
(leading to an unusually small <code class="docutils literal notranslate"><span class="pre">chi**2</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>An array containing the fit residuals normalized by the
corresponding standard deviations. The residuals are projected
onto the eigenvectors of the correlation matrix and so should
be uncorrelated from each other. The residuals include contributions
from both the fit data and the prior. They are related to the
the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> of the fit by:
<code class="docutils literal notranslate"><span class="pre">chi2</span> <span class="pre">=</span> <span class="pre">sum(fit.residuals**2)</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.stopping_criterion">
<span class="sig-name descname"><span class="pre">stopping_criterion</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.stopping_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Criterion used to
stop fit:</p>
<blockquote>
<div><p>0: didn’t converge</p>
<p>1: <code class="docutils literal notranslate"><span class="pre">xtol</span> <span class="pre">&gt;=</span></code> relative change in parameters between iterations</p>
<p>2: <code class="docutils literal notranslate"><span class="pre">gtol</span> <span class="pre">&gt;=</span></code> relative size of gradient of <code class="docutils literal notranslate"><span class="pre">chi**2</span></code></p>
<p>3: <code class="docutils literal notranslate"><span class="pre">ftol</span> <span class="pre">&gt;=</span></code> relative change in <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> between iterations</p>
<p>4: unable to improve fit further (e.g., already converged)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.correction">
<span class="sig-name descname"><span class="pre">correction</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of all corrections, if any, added
to the fit data and prior when <code class="docutils literal notranslate"><span class="pre">eps&gt;0</span></code> or <code class="docutils literal notranslate"><span class="pre">svdcut&gt;0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>gvar.GVar</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.svdn">
<span class="sig-name descname"><span class="pre">svdn</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.svdn" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of eigenmodes of the correlation matrix
modified (and/or deleted) when <code class="docutils literal notranslate"><span class="pre">svdcut&gt;0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.time">
<span class="sig-name descname"><span class="pre">time</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.time" title="Permalink to this definition">¶</a></dt>
<dd><p><em>CPU</em> time (in secs) taken by fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.tol">
<span class="sig-name descname"><span class="pre">tol</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.tol" title="Permalink to this definition">¶</a></dt>
<dd><p>Tolerance used in fit. This differs from the input
tolerance if the latter was incompletely specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.x">
<span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.x" title="Permalink to this definition">¶</a></dt>
<dd><p>The first field in the input <code class="docutils literal notranslate"><span class="pre">data</span></code>. This is sometimes the
independent variable (as in ‘y vs x’ plot), but may be anything.
It is set equal to <code class="docutils literal notranslate"><span class="pre">False</span></code> if the <code class="docutils literal notranslate"><span class="pre">x</span></code> field is omitted from
the input <code class="docutils literal notranslate"><span class="pre">data</span></code>. (This also means that the fit function has no
<code class="docutils literal notranslate"><span class="pre">x</span></code> argument: so <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> rather than <code class="docutils literal notranslate"><span class="pre">f(x,p)</span></code>.)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>obj</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.y">
<span class="sig-name descname"><span class="pre">y</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit data used in the fit. This may differ
from the input data if an SVD cut is used. It is either a
dictionary (<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.BufferDict</span></code>) or an array
(<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>), depending upon the input.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict, array or gvar.GVar</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.nblocks">
<span class="sig-name descname"><span class="pre">nblocks</span></span><a class="headerlink" href="#lsqfit.nonlinear_fit.nblocks" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">nblocks[s]</span></code> equals the number of block-diagonal
sub-matrices of the <code class="docutils literal notranslate"><span class="pre">y</span></code>–<code class="docutils literal notranslate"><span class="pre">prior</span></code> covariance matrix that are
size <code class="docutils literal notranslate"><span class="pre">s</span></code>-by-<code class="docutils literal notranslate"><span class="pre">s</span></code>. This is sometimes useful for debugging.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<p>The global defaults used by <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> can be changed by
changing entries in dictionary <code class="docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit.DEFAULTS</span></code>
for keys <code class="docutils literal notranslate"><span class="pre">'eps'</span></code>, <code class="docutils literal notranslate"><span class="pre">'svdcut'</span></code>, <code class="docutils literal notranslate"><span class="pre">'debug'</span></code>, <code class="docutils literal notranslate"><span class="pre">'tol'</span></code>, <code class="docutils literal notranslate"><span class="pre">'noise'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'maxit'</span></code>,  and <code class="docutils literal notranslate"><span class="pre">'fitter'</span></code>. Additional defaults can be
added to that dictionary to be are passed through <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>
to the underlying fitter (via dictionary <code class="docutils literal notranslate"><span class="pre">fitterargs</span></code>).</p>
<p>Additional methods are provided for printing out detailed information
about the fit, evaluating <code class="docutils literal notranslate"><span class="pre">chi**2</span></code>, testing fits with simulated data,
doing bootstrap analyses of the fit errors,
dumping (for later use) and loading parameter values, and checking for roundoff
errors in the final error  estimates:</p>
<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">maxline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pstyle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'v'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Formats fit output details into a string for printing.</p>
<p>The output tabulates the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> per degree of freedom of the fit
(<code class="docutils literal notranslate"><span class="pre">chi2/dof</span></code>), the number of degrees of freedom, the <code class="docutils literal notranslate"><span class="pre">Q</span></code>  value of
the fit (ie, p-value), and the logarithm of the Gaussian Bayes Factor
for the fit (<code class="docutils literal notranslate"><span class="pre">logGBF</span></code>). At the end it lists the SVD cut, the number
of eigenmodes modified by the SVD cut, the tolerances used in the fit,
and the time in seconds needed to do the fit. The tolerance used to
terminate the fit is marked with an asterisk. It also lists
information about the fitter used if it is other than the standard
choice.</p>
<p>Optionally, <code class="docutils literal notranslate"><span class="pre">format</span></code> will also list the best-fit values
for the fit parameters together with the prior for each (in <code class="docutils literal notranslate"><span class="pre">[]</span></code> on
each line). Lines for parameters that deviate from their prior by more
than one (prior) standard deviation are marked with asterisks, with
the number of asterisks equal to the number of standard deviations (up
to five). Lines for parameters designated as linear (see <code class="docutils literal notranslate"><span class="pre">linear</span></code>
keyword) are marked with a minus sign after their prior.</p>
<p><code class="docutils literal notranslate"><span class="pre">format</span></code> can also list all of the data and the corresponding values
from the fit, again with asterisks on lines  where there is a
significant discrepancy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxline</strong> (<em>int</em><em> or </em><em>bool</em>) – Maximum number of data points for which
fit results and input data are tabulated. <code class="docutils literal notranslate"><span class="pre">maxline&lt;0</span></code>
implies that only <code class="docutils literal notranslate"><span class="pre">chi2</span></code>, <code class="docutils literal notranslate"><span class="pre">Q</span></code>, <code class="docutils literal notranslate"><span class="pre">logGBF</span></code>, and <code class="docutils literal notranslate"><span class="pre">itns</span></code>
are tabulated; no parameter values are included. Setting
<code class="docutils literal notranslate"><span class="pre">maxline=True</span></code> prints all data points; setting it
equal <code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> is the same as setting
it equal to <code class="docutils literal notranslate"><span class="pre">-1</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">maxline=0</span></code>.</p></li>
<li><p><strong>pstyle</strong> (<em>str</em><em> or </em><em>None</em>) – Style used for parameter list. Supported
values are ‘vv’ for very verbose, ‘v’ for verbose, and ‘m’ for
minimal. When ‘m’ is set, only parameters whose values differ
from their prior values are listed. Setting <code class="docutils literal notranslate"><span class="pre">pstyle=None</span></code>
implies no parameters are listed.</p></li>
<li><p><strong>extend</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, extend the parameter list to
include values derived from log-normal or other
non-Gaussian parameters. So values for fit parameter
<code class="docutils literal notranslate"><span class="pre">p['log(a)']</span></code>, for example, are listed together with
values <code class="docutils literal notranslate"><span class="pre">p['a']</span></code> for the exponential of the fit parameter.
Setting <code class="docutils literal notranslate"><span class="pre">extend=False</span></code> means that only the value
for <code class="docutils literal notranslate"><span class="pre">p['log(a)']</span></code> is listed. Default is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>String containing detailed information about fit.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.dchi2">
<span class="sig-name descname"><span class="pre">dchi2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.dchi2" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">chi**2(p)</span> <span class="pre">-</span> <span class="pre">fit.chi2</span></code> for fit parameters <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<dl class="simple">
<dt><strong>Paramters:</strong></dt><dd><dl class="simple">
<dt><strong>p:</strong> Array or dictionary containing values for fit parameters, using</dt><dd><p>the same layout as in the fit function.</p>
</dd>
</dl>
</dd>
<dt><strong>Returns:</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">chi**2(p)</span> <span class="pre">-</span> <span class="pre">fit.chi2</span></code> where <code class="docutils literal notranslate"><span class="pre">chi**2(p)</span></code> is the fit’s
<code class="docutils literal notranslate"><span class="pre">chi**2</span></code> for fit parameters <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">fit.chi2</span></code> is the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code>
value for the best fit.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.pdf">
<span class="sig-name descname"><span class="pre">pdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.pdf" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">exp(-(chi**2(p)</span> <span class="pre">-</span> <span class="pre">fit.chi2)/2)</span></code> for fit parameters <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">fit.pdf(p)</span></code> is proportional to the probability density
function (PDF) used in the fit: <code class="docutils literal notranslate"><span class="pre">fit.pdf(p)/exp(fit.pdf.lognorm)</span></code>
is the product of the Gaussian PDF for the data <code class="docutils literal notranslate"><span class="pre">P(data|p,M)</span></code>
times the Gaussian PDF for the prior <code class="docutils literal notranslate"><span class="pre">P(p|M)</span></code> where <code class="docutils literal notranslate"><span class="pre">M</span></code> is the model
used in the fit (i.e., the fit function and prior). The product of PDFs
is <code class="docutils literal notranslate"><span class="pre">P(data,p|M)</span></code> by Bayes’ Theorem; integrating over fit parameters
p gives the Bayes Factor or Evidence <code class="docutils literal notranslate"><span class="pre">P(data|M)</span></code>, which is proportional
to the probability that the fit data come from fit model <code class="docutils literal notranslate"><span class="pre">M</span></code>. The logarithm
of the Bayes Factor should agree with <code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code> when the Gaussian
approximation assumed in the fit is accurate.</p>
<p><code class="docutils literal notranslate"><span class="pre">fit.pdf(p)</span></code> is useful for checking a least-squares fit
against the corresponding Bayesian integrals. In the following
example, <code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.PDFIntegrator</span></code> from the <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> module
is used to evaluate Bayesian expectation values of <code class="docutils literal notranslate"><span class="pre">s*g</span></code>
and its standard deviation where <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> are fit
parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">lsqfit</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vegas</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># least-squares fit</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="s1">&#39;1.2(1.0)&#39;</span><span class="p">,</span> <span class="s1">&#39;2.4(1)&#39;</span><span class="p">,</span> <span class="s1">&#39;2.0(1.2)&#39;</span><span class="p">,</span> <span class="s1">&#39;5.2(3.2)&#39;</span><span class="p">])</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">&#39;0(5)&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;0(2)&#39;</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="s1">&#39;2(2)&#39;</span><span class="p">))</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">fcn</span><span class="o">=</span><span class="n">fitfcn</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>

    <span class="c1"># create integrator and adapt it to PDF (warmup)</span>
    <span class="n">neval</span> <span class="o">=</span> <span class="mi">10_000</span>
    <span class="n">nitn</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">expval</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">PDFIntegrator</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">pdf</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">pdf</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">warmup</span> <span class="o">=</span> <span class="n">expval</span><span class="p">(</span><span class="n">neval</span><span class="o">=</span><span class="n">neval</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="n">nitn</span><span class="p">)</span>

    <span class="c1"># calculate expectation value of g(p)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">expval</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="n">neval</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="n">nitn</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;results =&#39;</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">sg</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sg&#39;</span><span class="p">]</span>
    <span class="n">sg2</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sg2&#39;</span><span class="p">]</span>
    <span class="n">sg_sdev</span> <span class="o">=</span> <span class="p">(</span><span class="n">sg2</span> <span class="o">-</span> <span class="n">sg</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;s*g from Bayes integral:  mean =&#39;</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="s1">&#39;  sdev =&#39;</span><span class="p">,</span> <span class="n">sg_sdev</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;s*g from fit:&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;logBF =&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">pdfnorm</span><span class="p">)</span> <span class="o">-</span> <span class="n">fit</span><span class="o">.</span><span class="n">pdf</span><span class="o">.</span><span class="n">lognorm</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fitfcn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">sg</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sg</span><span class="o">=</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg2</span><span class="o">=</span><span class="n">sg</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Here the probability density function used for the expectation values
is <code class="docutils literal notranslate"><span class="pre">fit.pdf(p)</span></code>, and the expectation values are returned
in dictionary <code class="docutils literal notranslate"><span class="pre">results</span></code>. <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> uses adaptive Monte
Carlo integration. The  <code class="docutils literal notranslate"><span class="pre">warmup</span></code> calls to the integrator are
used to adapt it to the probability density function, and
then the adapted integrator is  called again to evaluate the
expectation value. Parameter <code class="docutils literal notranslate"><span class="pre">neval</span></code> is the (approximate)
number of function calls per iteration of the <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> algorithm
and <code class="docutils literal notranslate"><span class="pre">nitn</span></code> is the number of iterations. We use the integrator to
calculated the expectation value of <code class="docutils literal notranslate"><span class="pre">s*g</span></code> and <code class="docutils literal notranslate"><span class="pre">(s*g)**2</span></code> so we can
compute a mean and standard deviation.</p>
<p>The output from this code shows that the Gaussian approximation
for <code class="docutils literal notranslate"><span class="pre">s*g</span></code> (0.78(66)) is somewhat different from the result
obtained from a Bayesian integral (0.49(53)):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
<span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.32</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.87</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="o">-</span><span class="mf">9.2027</span>

<span class="n">Parameters</span><span class="p">:</span>
            <span class="n">a</span>    <span class="mf">1.61</span> <span class="p">(</span><span class="mi">90</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">5.0</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">s</span>    <span class="mf">0.62</span> <span class="p">(</span><span class="mi">81</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">g</span>    <span class="mf">1.2</span> <span class="p">(</span><span class="mf">1.1</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">2.0</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
<span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">18</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">itn</span>   <span class="n">integral</span>        <span class="n">average</span>         <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
 <span class="mi">1</span>   <span class="mf">0.954</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>       <span class="mf">0.954</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">1.00</span>
 <span class="mi">2</span>   <span class="mf">0.9708</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>      <span class="mf">0.9622</span><span class="p">(</span><span class="mi">74</span><span class="p">)</span>          <span class="mf">0.74</span>     <span class="mf">0.53</span>
 <span class="mi">3</span>   <span class="mf">0.964</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>       <span class="mf">0.9627</span><span class="p">(</span><span class="mi">63</span><span class="p">)</span>          <span class="mf">0.93</span>     <span class="mf">0.47</span>
 <span class="mi">4</span>   <span class="mf">0.9620</span><span class="p">(</span><span class="mi">93</span><span class="p">)</span>      <span class="mf">0.9626</span><span class="p">(</span><span class="mi">52</span><span class="p">)</span>          <span class="mf">0.86</span>     <span class="mf">0.56</span>
 <span class="mi">5</span>   <span class="mf">0.964</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>       <span class="mf">0.9629</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>          <span class="mf">0.71</span>     <span class="mf">0.74</span>
 <span class="mi">6</span>   <span class="mf">0.957</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>       <span class="mf">0.9619</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>          <span class="mf">0.65</span>     <span class="mf">0.84</span>
 <span class="mi">7</span>   <span class="mf">0.964</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>       <span class="mf">0.9622</span><span class="p">(</span><span class="mi">46</span><span class="p">)</span>          <span class="mf">0.61</span>     <span class="mf">0.90</span>
 <span class="mi">8</span>   <span class="mf">0.9367</span><span class="p">(</span><span class="mi">86</span><span class="p">)</span>      <span class="mf">0.9590</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>          <span class="mf">0.80</span>     <span class="mf">0.73</span>
 <span class="mi">9</span>   <span class="mf">0.9592</span><span class="p">(</span><span class="mi">94</span><span class="p">)</span>      <span class="mf">0.9591</span><span class="p">(</span><span class="mi">39</span><span class="p">)</span>          <span class="mf">0.75</span>     <span class="mf">0.80</span>
<span class="mi">10</span>   <span class="mf">0.952</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>       <span class="mf">0.9584</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span>          <span class="mf">0.72</span>     <span class="mf">0.85</span>

            <span class="n">key</span><span class="o">/</span><span class="n">index</span>          <span class="n">value</span>
<span class="o">------------------------------------</span>
                <span class="n">pdf</span>    <span class="mf">0.9584</span> <span class="p">(</span><span class="mi">37</span><span class="p">)</span>
 <span class="p">(</span><span class="s1">&#39;f(p)*pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;sg&#39;</span><span class="p">)</span>    <span class="mf">0.4652</span> <span class="p">(</span><span class="mi">23</span><span class="p">)</span>
<span class="p">(</span><span class="s1">&#39;f(p)*pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;sg2&#39;</span><span class="p">)</span>    <span class="mf">0.5073</span> <span class="p">(</span><span class="mi">33</span><span class="p">)</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sg&#39;</span><span class="p">:</span> <span class="mf">0.4854</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span> <span class="s1">&#39;sg2&#39;</span><span class="p">:</span> <span class="mf">0.5293</span><span class="p">(</span><span class="mi">33</span><span class="p">)}</span>

<span class="n">s</span><span class="o">*</span><span class="n">g</span> <span class="kn">from</span> <span class="nn">Bayes</span> <span class="n">integral</span><span class="p">:</span>  <span class="n">mean</span> <span class="o">=</span> <span class="mf">0.4854</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>   <span class="n">sdev</span> <span class="o">=</span> <span class="mf">0.5420</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>
<span class="n">s</span><span class="o">*</span><span class="n">g</span> <span class="kn">from</span> <span class="nn">fit</span><span class="p">:</span> <span class="mf">0.78</span><span class="p">(</span><span class="mi">66</span><span class="p">)</span>

<span class="n">logBF</span> <span class="o">=</span> <span class="o">-</span><span class="mf">9.1505</span><span class="p">(</span><span class="mi">39</span><span class="p">)</span>
</pre></div>
</div>
<p>The result <code class="docutils literal notranslate"><span class="pre">logBF</span></code> for the logarithm of the Bayes Factor from the
integral agrees well with <code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code>, the log Bayes Factor
in the Gaussian approximation. This is evidence that the Gaussian
approximation implicit in the least squares fit is reliable; the product
of <code class="docutils literal notranslate"><span class="pre">s*g</span></code>, however, is not so Gaussian because of the large uncertainties
(compared to the means) in <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> separately.</p>
<dl class="simple">
<dt><strong>Paramters:</strong></dt><dd><dl class="simple">
<dt><strong>p</strong>: Array or dictionary containing values for fit parameters, using</dt><dd><p>the same layout as in the fit function.</p>
</dd>
</dl>
</dd>
<dt><strong>Returns:</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">exp(-(chi**2(p)</span> <span class="pre">-</span> <span class="pre">fit.chi2)/2)</span></code> where <code class="docutils literal notranslate"><span class="pre">chi**2(p)</span></code> is the fit’s
<code class="docutils literal notranslate"><span class="pre">chi**2</span></code> for fit parameters <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">fit.chi2</span></code> is the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code>
value for the best fit.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.simulated_fit_iter">
<span class="sig-name descname"><span class="pre">simulated_fit_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pexact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_priornoise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.simulated_fit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that returns simulation copies of a fit.</p>
<p>Fit reliability is tested using simulated data which
replaces the mean values in <code class="docutils literal notranslate"><span class="pre">self.y</span></code> with random numbers
drawn from a distribution whose mean equals <code class="docutils literal notranslate"><span class="pre">self.fcn(pexact)</span></code>
and whose covariance matrix is the same as <code class="docutils literal notranslate"><span class="pre">self.y</span></code>’s. Simulated
data is very similar to the original fit data, <code class="docutils literal notranslate"><span class="pre">self.y</span></code>,
but corresponds to a world where the correct values for
the parameters (<em>i.e.</em>, averaged over many simulated data
sets) are given by <code class="docutils literal notranslate"><span class="pre">pexact</span></code>. <code class="docutils literal notranslate"><span class="pre">pexact</span></code> is usually taken
equal to <code class="docutils literal notranslate"><span class="pre">fit.pmean</span></code>.</p>
<p>Each iteration of the iterator creates new simulated data,
with different random numbers, and fits it, returning the
the <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> that results. The simulated
data has the same covariance matrix as <code class="docutils literal notranslate"><span class="pre">fit.y</span></code>.
Typical usage is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">sfit</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">simulated_fit_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">verify</span> <span class="n">that</span> <span class="n">sfit</span> <span class="n">has</span> <span class="n">a</span> <span class="n">good</span> <span class="n">chi</span><span class="o">**</span><span class="mi">2</span> <span class="o">...</span>
    <span class="o">...</span> <span class="n">verify</span> <span class="n">that</span> <span class="n">sfit</span><span class="o">.</span><span class="n">p</span> <span class="n">agrees</span> <span class="k">with</span> <span class="n">pexact</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">pmean</span> <span class="n">within</span> <span class="n">errors</span> <span class="o">...</span>
</pre></div>
</div>
<p>Only a few iterations are needed to get a sense of the fit’s
reliability since we know the correct answer in each case. The
simulated fit’s output results should agree with <code class="docutils literal notranslate"><span class="pre">pexact</span></code>
(<code class="docutils literal notranslate"><span class="pre">=fit.pmean</span></code> here) within the simulated fit’s errors.</p>
<p>Setting parameter <code class="docutils literal notranslate"><span class="pre">add_priornoise=True</span></code> varies the means of the
priors as well as the means of the data. This option is useful
for testing goodness of fit because with it <code class="docutils literal notranslate"><span class="pre">chi**2/N</span></code> should
be <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">±</span> <span class="pre">sqrt(2/N)</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the
number of degrees of freedom. (<code class="docutils literal notranslate"><span class="pre">chi**2/N</span></code> can be significantly
smaller than one without added noise in prior means.)</p>
<p>Simulated fits can also be used to estimate biases in the fit’s
output parameters or functions of them, should non-Gaussian behavior
arise. This is possible, again, because we know the correct value for
every parameter before we do the fit. Again only a few iterations
may be needed for reliable estimates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (int or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – Maximum number of iterations (equals
infinity if <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li>
<li><p><strong>pexact</strong> (<code class="docutils literal notranslate"><span class="pre">None</span></code> or array/dict of numbers) – Fit-parameter values
for the underlying distribution used to generate simulated
data; replaced by <code class="docutils literal notranslate"><span class="pre">self.pmean</span></code> if is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default).</p></li>
<li><p><strong>add_priornoise</strong> (<em>bool</em>) – Vary prior means if <code class="docutils literal notranslate"><span class="pre">True</span></code>;
otherwise vary only the means in <code class="docutils literal notranslate"><span class="pre">self.y</span></code> (default).</p></li>
<li><p><strong>kargs</strong> – Dictionary containing override values for fit parameters.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An iterator that returns <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>s
for different simulated data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.simulated_data_iter">
<span class="sig-name descname"><span class="pre">simulated_data_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pexact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_priornoise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.simulated_data_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that returns simulated data based upon a fit’s data.</p>
<p>Simulated data is generated from a fit’s data <code class="docutils literal notranslate"><span class="pre">fit.y</span></code> by
replacing the mean values in that data with random numbers
drawn from a distribution whose mean is <code class="docutils literal notranslate"><span class="pre">self.fcn(pexact)</span></code>
and whose covariance matrix is the same as that of <code class="docutils literal notranslate"><span class="pre">self.y</span></code>.
Each iteration of the iterator returns new simulated data,
with different random numbers for the means and a covariance
matrix equal to that of <code class="docutils literal notranslate"><span class="pre">self.y</span></code>. This iterator is used by
<code class="docutils literal notranslate"><span class="pre">self.simulated_fit_iter</span></code>.</p>
<p>Typical usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">fcn</span><span class="o">=</span><span class="n">fcn</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">ysim</span><span class="p">,</span> <span class="n">priorsim</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">simulate_data_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">fitsim</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ysim</span><span class="p">),</span> <span class="n">prior</span><span class="o">=</span><span class="n">priorsim</span><span class="p">,</span> <span class="n">fcn</span><span class="o">=</span><span class="n">fcn</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fitsim</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;chi2 =&#39;</span><span class="p">,</span> <span class="n">gv</span><span class="o">.</span><span class="n">chi2</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">fitsim</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
</pre></div>
</div>
<p>This code tests the fitting protocol on simulated data, comparing the
best fit parameters in each case with the correct values (<code class="docutils literal notranslate"><span class="pre">fit.p</span></code>).
The loop in this code is functionally the same as (but probably not
as fast as):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">fitsim</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">simulated_fit_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fitsim</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;chi2 =&#39;</span><span class="p">,</span> <span class="n">gv</span><span class="o">.</span><span class="n">chi2</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">fitsim</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em><em> or </em><em>None</em>) – Maximum number of iterations (equals
infinity if <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li>
<li><p><strong>pexact</strong> (<em>None</em><em> or </em><em>dict/array of numbers</em>) – Fit-parameter values for
the underlying distribution used to generate simulated data;
replaced by <code class="docutils literal notranslate"><span class="pre">self.pmean</span></code> if is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default).</p></li>
<li><p><strong>add_priornoise</strong> (<em>bool</em>) – Vary prior means if <code class="docutils literal notranslate"><span class="pre">True</span></code>; otherwise
vary only the means in <code class="docutils literal notranslate"><span class="pre">self.y</span></code> (default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An iterator that returns a 2-tuple containing simulated
versions of self.y and self.prior: <code class="docutils literal notranslate"><span class="pre">(ysim,</span> <span class="pre">priorsim)</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.bootstrapped_fit_iter">
<span class="sig-name descname"><span class="pre">bootstrapped_fit_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">datalist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.bootstrapped_fit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that returns bootstrap copies of a fit.</p>
<p>A bootstrap analysis involves three steps: 1) make a large number
of “bootstrap copies” of the original input data and prior that differ
from each other by random amounts characteristic of the underlying
randomness in the original data; 2) repeat the entire fit analysis
for each bootstrap copy of the data, extracting fit results from
each; and 3) use the variation of the fit results from bootstrap
copy to bootstrap copy to determine an approximate probability
distribution (possibly non-gaussian) for the fit parameters and/or
functions of them: the results from each bootstrap fit are samples
from that distribution.</p>
<p>Bootstrap copies of the data for step 2 are provided in
<code class="docutils literal notranslate"><span class="pre">datalist</span></code>. If <code class="docutils literal notranslate"><span class="pre">datalist</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, they are generated
instead from the means and covariance matrix of the fit data
(assuming gaussian statistics). The maximum number of bootstrap
copies considered is specified by <code class="docutils literal notranslate"><span class="pre">n</span></code> (<code class="docutils literal notranslate"><span class="pre">None</span></code> implies no
limit).</p>
<p>Variations in the best-fit parameters (or functions of them)
from bootstrap fit to bootstrap fit define the probability
distributions for those quantities. For example, one could use the
following code to analyze the distribution of function <code class="docutils literal notranslate"><span class="pre">g(p)</span></code>
of the fit parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="o">...</span>

<span class="n">glist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">bsfit</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">bootstrapped_fit_iter</span><span class="p">(</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">datalist</span><span class="o">=</span><span class="n">datalist</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="n">glist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">bsfit</span><span class="o">.</span><span class="n">pmean</span><span class="p">))</span>

<span class="o">...</span> <span class="n">analyze</span> <span class="n">samples</span> <span class="n">glist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="kn">from</span> <span class="nn">g</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">distribution</span> <span class="o">...</span>
</pre></div>
</div>
<p>This code generates <code class="docutils literal notranslate"><span class="pre">n=100</span></code> samples <code class="docutils literal notranslate"><span class="pre">glist[i]</span></code> from the
probability distribution of <code class="docutils literal notranslate"><span class="pre">g(p)</span></code>. If everything is Gaussian,
the mean and standard deviation of <code class="docutils literal notranslate"><span class="pre">glist[i]</span></code> should agree
with <code class="docutils literal notranslate"><span class="pre">g(fit.p).mean</span></code> and <code class="docutils literal notranslate"><span class="pre">g(fit.p).sdev</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – Maximum number of iterations if <code class="docutils literal notranslate"><span class="pre">n</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>;
otherwise there is no maximum.</p></li>
<li><p><strong>datalist</strong> (<em>iter</em>) – Collection of bootstrap <code class="docutils literal notranslate"><span class="pre">data</span></code> sets for fitter.</p></li>
<li><p><strong>kargs</strong> (<em>dict</em>) – Overrides arguments in original fit.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Iterator that returns an <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> object
containing results from the fit to the next data set in
<code class="docutils literal notranslate"><span class="pre">datalist</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.check_roundoff">
<span class="sig-name descname"><span class="pre">check_roundoff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.check_roundoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for roundoff errors in fit.p.</p>
<p>Compares standard deviations from fit.p and fit.palt to see if they
agree to within relative tolerance <code class="docutils literal notranslate"><span class="pre">rtol</span></code> and absolute tolerance
<code class="docutils literal notranslate"><span class="pre">atol</span></code>. Generates a warning if they do not (in which
case an SVD cut might be advisable).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.qqplot_residuals">
<span class="sig-name descname"><span class="pre">qqplot_residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.qqplot_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>QQ plot normalized fit residuals.</p>
<p>The sum of the squares of the residuals equals <code class="docutils literal notranslate"><span class="pre">self.chi2</span></code>.
Individual residuals should be distributed in a Gaussian
distribution centered about zero. A Q-Q plot orders the
residuals and plots them against the value they would have if
they were distributed according to a Gaussian distribution.
The resulting plot will approximate a straight line along
the diagonal of the plot (dashed black line) if
the residuals have a Gaussian distribution with zero mean
and unit standard deviation.</p>
<p>The residuals are fit to a straight line and the fit
is displayed in the plot (solid red line). Residuals that
fall on a straight line have a distribution that is
Gaussian. A nonzero intercept indicates a bias in the mean, away from zero.
A slope smaller than 1.0 indicates the actual standard deviation
is smaller than suggested by the fit errors, as would be expected if
the <code class="docutils literal notranslate"><span class="pre">chi2/dof</span></code> is significantly below 1.0 (since <code class="docutils literal notranslate"><span class="pre">chi2</span></code> equals
the sum of the squared residuals).</p>
<p>One way to display the plot is with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fit</span><span class="o">.</span><span class="n">qqplot_residuals</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>plot</strong> – a <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code> plotter. If <code class="docutils literal notranslate"><span class="pre">None</span></code>,
uses <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Plotter <code class="docutils literal notranslate"><span class="pre">plot</span></code>.</p>
</dd>
</dl>
<p>This method requires the <code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy</span></code> and <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code> modules.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.plot_residuals">
<span class="sig-name descname"><span class="pre">plot_residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.plot_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot normalized fit residuals.</p>
<p>The sum of the squares of the residuals equals <code class="docutils literal notranslate"><span class="pre">self.chi2</span></code>.
Individual residuals should be distributed about one, in
a Gaussian distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>plot</strong> – <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code> plotter. If <code class="docutils literal notranslate"><span class="pre">None</span></code>,
uses <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Plotter <code class="docutils literal notranslate"><span class="pre">plot</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.nonlinear_fit.set">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">defaults</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set default parameters for <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>.</p>
<p>Use to set default values for parameters: <code class="docutils literal notranslate"><span class="pre">eps</span></code>, <code class="docutils literal notranslate"><span class="pre">svdcut</span></code>,
<code class="docutils literal notranslate"><span class="pre">debug</span></code>, <code class="docutils literal notranslate"><span class="pre">tol</span></code>, <code class="docutils literal notranslate"><span class="pre">maxit</span></code>, and <code class="docutils literal notranslate"><span class="pre">fitter</span></code>. Can also set
parameters specific to the fitter specified by the <code class="docutils literal notranslate"><span class="pre">fitter</span></code>
argument.</p>
<p>Sample usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">lsqfit</span>

<span class="n">old_defaults</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">nonlinear_fit</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
    <span class="n">fitter</span><span class="o">=</span><span class="s1">&#39;gsl_multifit&#39;</span><span class="p">,</span> <span class="n">alg</span><span class="o">=</span><span class="s1">&#39;subspace2D&#39;</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;cholesky&#39;</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">nonlinear_fit.set()</span></code> without arguments returns a
dictionary containing the current defaults.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clear</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> remove earlier settings,
restoring the original defaults, before adding new
defaults. The default value is <code class="docutils literal notranslate"><span class="pre">clear=False</span></code>.
<code class="docutils literal notranslate"><span class="pre">nonlinear_fit.set(clear=True)</span></code> restores the
original defaults.</p></li>
<li><p><strong>defaults</strong> (<em>dict</em>) – Dictionary containing new defaults.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary containing the old defaults,
before they were updated. These can be restored using
<code class="docutils literal notranslate"><span class="pre">nonlinear_fit.set(old_defaults)</span></code> where <code class="docutils literal notranslate"><span class="pre">old_defaults</span></code>
is the dictionary containint the old defaults.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="lsqfit.empbayes_fit">
<span class="sig-prename descclassname"><span class="pre">lsqfit.</span></span><span class="sig-name descname"><span class="pre">empbayes_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitargs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">minargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.empbayes_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fit and <code class="docutils literal notranslate"><span class="pre">z</span></code> corresponding to the fit
<code class="docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit(**fitargs(z))</span></code> that maximizes <code class="docutils literal notranslate"><span class="pre">logGBF</span></code>.</p>
<p>This function maximizes the logarithm of the Bayes Factor from
fit  <code class="docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit(**fitargs(z))</span></code> by varying <code class="docutils literal notranslate"><span class="pre">z</span></code>,
starting at <code class="docutils literal notranslate"><span class="pre">z0</span></code>. The fit is redone for each value of <code class="docutils literal notranslate"><span class="pre">z</span></code>
that is tried, in order to determine <code class="docutils literal notranslate"><span class="pre">logGBF</span></code>.</p>
<p>The Bayes Factor is proportional to the probability that the data
came from the model (fit function and priors) used in the fit.
<a class="reference internal" href="#lsqfit.empbayes_fit" title="lsqfit.empbayes_fit"><code class="xref py py-func docutils literal notranslate"><span class="pre">empbayes_fit()</span></code></a> finds the model or data that maximizes this
probability.</p>
<p>One application is illustrated by the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">lsqfit</span>

<span class="c1"># fit data</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">3.4422</span><span class="p">,</span> <span class="mf">1.2929</span><span class="p">,</span> <span class="mf">0.4798</span><span class="p">,</span> <span class="mf">0.1725</span><span class="p">])</span>

<span class="c1"># prior</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="s1">&#39;10(1)&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0(1)&#39;</span><span class="p">])</span>

<span class="c1"># fit function</span>
<span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">gv</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

<span class="c1"># find optimal dy</span>
<span class="k">def</span> <span class="nf">fitargs</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>
    <span class="n">newy</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">newy</span><span class="p">),</span> <span class="n">fcn</span><span class="o">=</span><span class="n">fcn</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>

<span class="n">fit</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">empbayes_fit</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">fitargs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p>Here we want to fit data <code class="docutils literal notranslate"><span class="pre">y</span></code> with fit function <code class="docutils literal notranslate"><span class="pre">fcn</span></code> but we don’t know
the uncertainties in our <code class="docutils literal notranslate"><span class="pre">y</span></code> values. We assume that the relative errors
are <code class="docutils literal notranslate"><span class="pre">x</span></code>-independent and uncorrelated. We add the error <code class="docutils literal notranslate"><span class="pre">dy</span></code> that
maximizes the Bayes Factor, as this is the most likely choice. This fit
gives the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.58</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.67</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">7.4834</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="mi">0</span>     <span class="mf">9.44</span> <span class="p">(</span><span class="mi">18</span><span class="p">)</span>     <span class="p">[</span> <span class="mf">10.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
              <span class="mi">1</span>   <span class="mf">0.9979</span> <span class="p">(</span><span class="mi">69</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">1.00</span> <span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Fit</span><span class="p">:</span>
     <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>           <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>      <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">p</span><span class="p">)</span>
<span class="o">---------------------------------------</span>
        <span class="mi">1</span>     <span class="mf">3.442</span> <span class="p">(</span><span class="mi">54</span><span class="p">)</span>     <span class="mf">3.481</span> <span class="p">(</span><span class="mi">45</span><span class="p">)</span>
        <span class="mi">2</span>     <span class="mf">1.293</span> <span class="p">(</span><span class="mi">20</span><span class="p">)</span>     <span class="mf">1.283</span> <span class="p">(</span><span class="mi">11</span><span class="p">)</span>
        <span class="mi">3</span>    <span class="mf">0.4798</span> <span class="p">(</span><span class="mi">75</span><span class="p">)</span>    <span class="mf">0.4731</span> <span class="p">(</span><span class="mi">41</span><span class="p">)</span>
        <span class="mi">4</span>    <span class="mf">0.1725</span> <span class="p">(</span><span class="mi">27</span><span class="p">)</span>    <span class="mf">0.1744</span> <span class="p">(</span><span class="mi">23</span><span class="p">)</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>We have, in effect, used the variation in the data relative to the best
fit curve to estimate that the uncertainty in each data point is
of order 1.6%.</p>
<p>See also <a class="reference internal" href="#lsqfit.MultiFitter.empbayes_fit" title="lsqfit.MultiFitter.empbayes_fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.empbayes_fit()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>z0</strong> (<em>number</em><em>, </em><em>array</em><em> or </em><em>dict</em>) – Starting point for search.</p></li>
<li><p><strong>fitargs</strong> (<em>callable</em>) – Function of <code class="docutils literal notranslate"><span class="pre">z</span></code> that returns a
dictionary <code class="docutils literal notranslate"><span class="pre">args</span></code> containing the <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>
arguments corresponding to <code class="docutils literal notranslate"><span class="pre">z</span></code>. <code class="docutils literal notranslate"><span class="pre">z</span></code> should have
the same layout (number, array or dictionary) as <code class="docutils literal notranslate"><span class="pre">z0</span></code>.
<code class="docutils literal notranslate"><span class="pre">fitargs(z)</span></code> can instead return a tuple <code class="docutils literal notranslate"><span class="pre">(args,</span> <span class="pre">plausibility)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">args</span></code> is again the dictionary for
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>. <code class="docutils literal notranslate"><span class="pre">plausibility</span></code> is the logarithm
of the <em>a priori</em> probabilitiy that <code class="docutils literal notranslate"><span class="pre">z</span></code> is sensible. When
<code class="docutils literal notranslate"><span class="pre">plausibility</span></code> is provided, <a class="reference internal" href="#lsqfit.empbayes_fit" title="lsqfit.empbayes_fit"><code class="xref py py-func docutils literal notranslate"><span class="pre">lsqfit.empbayes_fit()</span></code></a>
maximizes the sum <code class="docutils literal notranslate"><span class="pre">logGBF</span> <span class="pre">+</span> <span class="pre">plausibility</span></code>. Specifying
<code class="docutils literal notranslate"><span class="pre">plausibility</span></code> is a way of steering selections away from
completely implausible values for <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p></li>
<li><p><strong>minargs</strong> (<em>dict</em>) – Optional argument dictionary, passed on to
<a class="reference internal" href="gsl.html#lsqfit.gsl_multiminex" title="lsqfit.gsl_multiminex"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.gsl_multiminex</span></code></a> (or
<a class="reference internal" href="scipy.html#lsqfit.scipy_multiminex" title="lsqfit.scipy_multiminex"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.scipy_multiminex</span></code></a>), which finds the minimum.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple containing the best fit (object of type
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>) and the
optimal value for parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfit.wavg">
<span class="sig-prename descclassname"><span class="pre">lsqfit.</span></span><span class="sig-name descname"><span class="pre">wavg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datalist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prior</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">fitterargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.wavg" title="Permalink to this definition">¶</a></dt>
<dd><p>Weighted average of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or arrays/dicts of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.</p>
<p>The weighted average of <code class="docutils literal notranslate"><span class="pre">N</span></code> <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xavg</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">...</span> <span class="n">gN</span><span class="p">])</span>
</pre></div>
</div>
<p>is what one obtains from a weighted least-squares fit of the
collection of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s to the one-parameter fit function</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
</pre></div>
</div>
<p>The average is the best-fit value for fit parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>.  <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s
with smaller standard deviations carry more weight than those with
larger standard deviations; and the averages take account of
correlations between the <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.</p>
<p><code class="docutils literal notranslate"><span class="pre">wavg</span></code> also works when each <code class="docutils literal notranslate"><span class="pre">gi</span></code> is an array of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or a
dictionary whose values are <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.
Corresponding arrays in different <code class="docutils literal notranslate"><span class="pre">gi</span></code>s must have the same dimension,
but can have different shapes (the overlapping components are
averaged).  When the <code class="docutils literal notranslate"><span class="pre">gi</span></code> are dictionaries, they need not all have
the same keys.</p>
<p>Weighted averages can become costly when the number of random samples
being averaged is large (100s or more). In such cases it might be useful
to set parameter <code class="docutils literal notranslate"><span class="pre">fast=True</span></code>. This causes <code class="docutils literal notranslate"><span class="pre">wavg</span></code> to estimate the
weighted average by incorporating the random samples one at a time into a
running average:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">datalist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">datalist</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">result</span><span class="p">,</span> <span class="n">di</span><span class="p">],</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>This method can be much faster when <code class="docutils literal notranslate"><span class="pre">len(datalist)</span></code> is large, and gives
the exact result when there are no correlations between different elements
of list <code class="docutils literal notranslate"><span class="pre">datalist</span></code>. The results are approximately correct when
<code class="docutils literal notranslate"><span class="pre">datalist[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">datalist[j]</span></code> are correlated for <code class="docutils literal notranslate"><span class="pre">i!=j</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>datalist</strong> (<em>list</em>) – The <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s to be averaged. <code class="docutils literal notranslate"><span class="pre">datalist</span></code> is
a one-dimensional sequence of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s, or of arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s,
or of dictionaries containing <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s  and/or arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.
Corresponding arrays in different <code class="docutils literal notranslate"><span class="pre">datalist[i]</span></code>s must have the
same dimension.</p></li>
<li><p><strong>fast</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">fast=True</span></code>, <code class="docutils literal notranslate"><span class="pre">wavg</span></code> averages the <code class="docutils literal notranslate"><span class="pre">datalist[i]</span></code>
sequentially. This can be much faster when averaging a large
number of sampes but is only approximate if the different
elements of <code class="docutils literal notranslate"><span class="pre">datalist</span></code> are correlated. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>fitterargs</strong> (<em>dict</em>) – Additional arguments (e.g., <code class="docutils literal notranslate"><span class="pre">svdcut</span></code> or <code class="docutils literal notranslate"><span class="pre">eps</span></code>)
for the <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> fitter used to do the
averaging.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>The weighted average is returned as a <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code> or an array of
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or a dictionary of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s and arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.
Results have the following extra attributes:</p>
<p><strong>chi2</strong> - <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> for weighted average.</p>
<p><strong>dof</strong> - Effective number of degrees of freedom.</p>
<dl class="simple">
<dt><strong>Q</strong> - Quality factor <cite>Q</cite> (or <em>p-value</em>) for fit:</dt><dd><p>the probability that the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> could have been larger,
by chance, assuming that the data are all Gaussian and consistent
with each other. Values smaller than 0.1 or so suggest that the
data are not Gaussian or are inconsistent with each other. Also
called the <em>p-value</em>.</p>
</dd>
</dl>
<p><strong>time</strong> - Time required to do average.</p>
<dl class="simple">
<dt><strong>correction</strong> - The corrections made to the data</dt><dd><p>when <code class="docutils literal notranslate"><span class="pre">svdcut&gt;0</span></code> or <code class="docutils literal notranslate"><span class="pre">eps&gt;0</span></code>.</p>
</dd>
</dl>
<p><strong>fit</strong> - Fit returned by <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>.</p>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfit.lsqfit.gammaQ">
<span class="sig-prename descclassname"><span class="pre">lsqfit.</span></span><span class="sig-name descname"><span class="pre">gammaQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.lsqfit.gammaQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized incomplete gamma function <code class="docutils literal notranslate"><span class="pre">Q(a,x)</span> <span class="pre">=</span> <span class="pre">1-P(a,x)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Q(a,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">1/Gamma(a)</span> <span class="pre">*</span> <span class="pre">\int_x^\infty</span> <span class="pre">dt</span> <span class="pre">exp(-t)</span> <span class="pre">t</span> <span class="pre">**</span> <span class="pre">(a-1)</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">P(a,</span> <span class="pre">x)</span></code></p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">gammaQ(ndof/2.,</span> <span class="pre">chi2/2.)</span></code> is the probabilty that one could
get a <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> larger than <code class="docutils literal notranslate"><span class="pre">chi2</span></code> with <code class="docutils literal notranslate"><span class="pre">ndof</span></code> degrees
of freedom even if the model used to construct <code class="docutils literal notranslate"><span class="pre">chi2</span></code> is correct.</p>
</dd></dl>

</section>
<section id="lsqfit-multifitter-classes">
<h2><a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> Classes<a class="headerlink" href="#lsqfit-multifitter-classes" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> provides a framework for building component
systems to fit multiple pieces of data using a set of custom-designed models,
derived  from <a class="reference internal" href="#lsqfit.MultiFitterModel" title="lsqfit.MultiFitterModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitterModel</span></code></a>. Each model  encapsulates:
a) a particular fit function; b) a recipe for assembling the corresponding fit
data from a dictionary that contains all of the data; and c) a recipe for
assembling a fit prior drawn from a dictionary containing all the priors.
This allows fit problems to be broken down down into more manageable pieces,
which are then aggregated by <a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> into a single fit.</p>
<p>This framework was developed to support the <code class="xref py py-mod docutils literal notranslate"><span class="pre">corrfitter</span></code> module which is
used to analyze 2-point and 3-point correlators generated in Monte Carlo
simulations of quantum field theories (like QCD). The <code class="xref py py-mod docutils literal notranslate"><span class="pre">corrfitter</span></code>
module provides two models to describe correlators: <code class="xref py py-class docutils literal notranslate"><span class="pre">corrfitter.Corr2</span></code>
to describe one  2-point correlator, and <code class="xref py py-class docutils literal notranslate"><span class="pre">corrfitter.Corr3</span></code> to describe
one 3-point  correlator. A typical analysis involves fitting data for a mixture of
2-point and 3-point correlators, with sometimes hundreds of correlators in all.
Each correlator is described by either  a <code class="docutils literal notranslate"><span class="pre">Corr2</span></code> model or a <code class="docutils literal notranslate"><span class="pre">Corr3</span></code>
model. A list of models, one for each  correlator, is handed
<code class="xref py py-class docutils literal notranslate"><span class="pre">corrfitter.CorrFitter</span></code> (derived from  <a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a>) to
fit the models to the correlator data. The models for different
correlators typically share many fit parameters.</p>
<p>A simpler example of a model is one that encapsulates
a linear fit function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">lsqfit</span>

<span class="k">class</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">lsqfit</span><span class="o">.</span><span class="n">MultiFitterModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datatag</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Linear</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">datatag</span><span class="p">)</span>
        <span class="c1"># the independent variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># keys used to find the intercept and slope in a parameter dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span> <span class="o">=</span> <span class="n">intercept</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">=</span> <span class="n">slope</span>

    <span class="k">def</span> <span class="nf">fitfcn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># slope parameter marginalized/omitted</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">buildprior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">mopt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="s2">&quot; Extract the model&#39;s parameters from prior. &quot;</span>
        <span class="n">newprior</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">newprior</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mopt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># slope parameter marginalized/omitted if mopt is not None</span>
            <span class="n">newprior</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">newprior</span>

    <span class="k">def</span> <span class="nf">builddata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="s2">&quot; Extract the model&#39;s fit data from data. &quot;</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">datatag</span><span class="p">]</span>
</pre></div>
</div>
<p>Imagine four sets of data, each corresponding to <code class="docutils literal notranslate"><span class="pre">x=1,2,3,4</span></code>, all of which
have the same intercept but different slopes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
    <span class="n">d1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1.154(10)&#39;</span><span class="p">,</span> <span class="s1">&#39;2.107(16)&#39;</span><span class="p">,</span> <span class="s1">&#39;3.042(22)&#39;</span><span class="p">,</span> <span class="s1">&#39;3.978(29)&#39;</span><span class="p">],</span>
    <span class="n">d2</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;0.692(10)&#39;</span><span class="p">,</span> <span class="s1">&#39;1.196(16)&#39;</span><span class="p">,</span> <span class="s1">&#39;1.657(22)&#39;</span><span class="p">,</span> <span class="s1">&#39;2.189(29)&#39;</span><span class="p">],</span>
    <span class="n">d3</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;0.107(10)&#39;</span><span class="p">,</span> <span class="s1">&#39;0.030(16)&#39;</span><span class="p">,</span> <span class="s1">&#39;-0.027(22)&#39;</span><span class="p">,</span> <span class="s1">&#39;-0.149(29)&#39;</span><span class="p">],</span>
    <span class="n">d4</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;0.002(10)&#39;</span><span class="p">,</span> <span class="s1">&#39;-0.197(16)&#39;</span><span class="p">,</span> <span class="s1">&#39;-0.382(22)&#39;</span><span class="p">,</span> <span class="s1">&#39;-0.627(29)&#39;</span><span class="p">],</span>
    <span class="p">))</span>
</pre></div>
</div>
<p>To find the common intercept, we define a model for each set of
data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">models</span> <span class="o">=</span> <span class="p">[</span>
   <span class="n">Linear</span><span class="p">(</span><span class="s1">&#39;d1&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="s1">&#39;s1&#39;</span><span class="p">),</span>
   <span class="n">Linear</span><span class="p">(</span><span class="s1">&#39;d2&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="s1">&#39;s2&#39;</span><span class="p">),</span>
   <span class="n">Linear</span><span class="p">(</span><span class="s1">&#39;d3&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="s1">&#39;s3&#39;</span><span class="p">),</span>
   <span class="n">Linear</span><span class="p">(</span><span class="s1">&#39;d4&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="s1">&#39;s4&#39;</span><span class="p">),</span>
   <span class="p">]</span>
</pre></div>
</div>
<p>This says that <code class="docutils literal notranslate"><span class="pre">data['d3']</span></code>, for example, should be fit with  function
<code class="docutils literal notranslate"><span class="pre">p['a']</span> <span class="pre">+</span> <span class="pre">p['s3']</span> <span class="pre">*</span> <span class="pre">np.array([1,2,3,4])</span></code> where <code class="docutils literal notranslate"><span class="pre">p</span></code> is  a dictionary of fit
parameters.  Assume that we know <em>a priori</em> that the intercept and slopes are all
order one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">s1</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">s2</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">s3</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">s4</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Then we can fit all the data to determine the intercept:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fitter</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">MultiFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">models</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;intercept =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The output from this code is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.49</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.95</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">18.793</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>    <span class="mf">0.2012</span> <span class="p">(</span><span class="mi">78</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s1</span>    <span class="mf">0.9485</span> <span class="p">(</span><span class="mi">53</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s2</span>    <span class="mf">0.4927</span> <span class="p">(</span><span class="mi">53</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s3</span>   <span class="o">-</span><span class="mf">0.0847</span> <span class="p">(</span><span class="mi">53</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s4</span>   <span class="o">-</span><span class="mf">0.2001</span> <span class="p">(</span><span class="mi">53</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">intercept</span> <span class="o">=</span> <span class="mf">0.2012</span><span class="p">(</span><span class="mi">78</span><span class="p">)</span>
</pre></div>
</div>
<p>Model class <code class="docutils literal notranslate"><span class="pre">Linear</span></code> is configured to allow
marginalization of the slope parameter, if desired. Calling
<code class="docutils literal notranslate"><span class="pre">fitter.lsqfit(data=data,</span> <span class="pre">prior=prior,</span> <span class="pre">mopt=True)</span></code> moves the slope
parameters into the data (by subtracting <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">*</span> <span class="pre">prior[m.slope]</span></code>
from the data for each model <code class="docutils literal notranslate"><span class="pre">m</span></code>), and does a single-parameter fit for the
intercept:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.49</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.95</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">18.793</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>   <span class="mf">0.2012</span> <span class="p">(</span><span class="mi">78</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">intercept</span> <span class="o">=</span> <span class="mf">0.2012</span><span class="p">(</span><span class="mi">78</span><span class="p">)</span>
</pre></div>
</div>
<p>Marginalization can be useful when fitting large data sets since it
reduces the number of fit parameters and simplifies the fit.</p>
<p>Empirical Bayes tuning can be used with a <code class="xref py py-mod docutils literal notranslate"><span class="pre">MultiFitter</span></code> (see <a class="reference internal" href="overview.html#empirical-bayes"><span class="std std-ref">Tuning Priors with the Empirical Bayes Criterion</span></a>).
Continuing from the example just above, we may be uncertain about the prior for the
intercept. The following code varies the width of that prior to maximize
the Bayes Factor (<code class="docutils literal notranslate"><span class="pre">logGBF</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fitargs</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">s1</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">s2</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">s3</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">s4</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">))</span>
    <span class="n">prior</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>       <span class="c1"># np.exp =&gt; positive std dev</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">mopt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
 <span class="n">fit</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">empbayes_fit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fitargs</span><span class="p">)</span>
 <span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
 <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;intercept =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The output shows that the data prefer a prior of <code class="docutils literal notranslate"><span class="pre">0.0(2)</span></code> for the
intercept (not surprisingly):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.55</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.92</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">19.917</span>

<span class="n">Parameters</span><span class="p">:</span>
            <span class="n">a</span>   <span class="mf">0.2009</span> <span class="p">(</span><span class="mi">78</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.00</span> <span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">intercept</span> <span class="o">=</span> <span class="mf">0.2009</span><span class="p">(</span><span class="mi">78</span><span class="p">)</span>
</pre></div>
</div>
<p>The increase in the Bayes Factor, however, is not significant, and the
result is almost unchanged. This confirms that the original choice was
reasonable.</p>
<p>Another variation is to replace the simultaneous fit of the four models
by a chained fit, where one model is fit at a time and its
results are fed into the next fit through that fit’s prior. Replacing the
fit code by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fitter</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">MultiFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">models</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">chained_lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>
<span class="c1"># same as fit = fitter.lsqfit(data=data, prior=prior, chained=True)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">formatall</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;intercept =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>gives the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========</span> <span class="n">d1</span>
<span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.32</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.86</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">2.0969</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>    <span class="mf">0.213</span> <span class="p">(</span><span class="mi">16</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s1</span>   <span class="mf">0.9432</span> <span class="p">(</span><span class="mi">82</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="o">==========</span> <span class="n">d2</span>
<span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.58</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.67</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">5.3792</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>    <span class="mf">0.206</span> <span class="p">(</span><span class="mi">11</span><span class="p">)</span>     <span class="p">[</span> <span class="mf">0.213</span> <span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s2</span>   <span class="mf">0.4904</span> <span class="p">(</span><span class="mi">64</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="o">==========</span> <span class="n">d3</span>
<span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.66</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.62</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">5.3767</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>    <span class="mf">0.1995</span> <span class="p">(</span><span class="mi">90</span><span class="p">)</span>      <span class="p">[</span> <span class="mf">0.206</span> <span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s3</span>   <span class="o">-</span><span class="mf">0.0840</span> <span class="p">(</span><span class="mi">57</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="o">==========</span> <span class="n">d4</span>
<span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.41</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.81</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">5.9402</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>    <span class="mf">0.2012</span> <span class="p">(</span><span class="mi">78</span><span class="p">)</span>      <span class="p">[</span> <span class="mf">0.1995</span> <span class="p">(</span><span class="mi">90</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s4</span>   <span class="o">-</span><span class="mf">0.2001</span> <span class="p">(</span><span class="mi">53</span><span class="p">)</span>      <span class="p">[</span>   <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">intercept</span> <span class="o">=</span> <span class="mf">0.2012</span><span class="p">(</span><span class="mi">78</span><span class="p">)</span>
</pre></div>
</div>
<p>Note how the value for <code class="docutils literal notranslate"><span class="pre">a</span></code> improves with each fit.</p>
<p>Chained fits are most useful
with very large data sets when it is possible to break the data into
smaller, more manageable chunks. There are a variety of options for
organizing the chain of fits; these are discussed in the
<a class="reference internal" href="#lsqfit.MultiFitter.chained_lsqfit" title="lsqfit.MultiFitter.chained_lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.chained_lsqfit()</span></code></a> documentation.</p>
<dl class="py class">
<dt class="sig sig-object py" id="lsqfit.MultiFitter">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lsqfit.</span></span><span class="sig-name descname"><span class="pre">MultiFitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">models</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mopt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">fitterargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Nonlinear least-squares fitter for a collection of models.</p>
<p>Fits collections of data that are modeled by collections of models.
Fits can be simultaneous (<a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.MultiFitter.lsqfit()</span></code></a>) or chained
(<a class="reference internal" href="#lsqfit.MultiFitter.chained_lsqfit" title="lsqfit.MultiFitter.chained_lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.MultiFitter.chained_lsqfit()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>models</strong> – List of models, derived from <a class="reference internal" href="#lsqfit.MultiFitterModel" title="lsqfit.MultiFitterModel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit.MultiFitterModel</span></code></a>,
to be fit to the data. Individual models in the list can
be replaced by lists of models or tuples of models; see below.</p></li>
<li><p><strong>mopt</strong> (<em>object</em>) – Marginalization options. If not <code class="docutils literal notranslate"><span class="pre">None</span></code>,
marginalization is used to reduce the number of fit parameters.
Object <code class="docutils literal notranslate"><span class="pre">mopt</span></code> is passed to the models when constructing the
prior for a fit; it typically indicates the degree of
marginalization (in a model-dependent fashion). Setting
<code class="docutils literal notranslate"><span class="pre">mopt=None</span></code> implies no marginalization.</p></li>
<li><p><strong>ratio</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, implement marginalization using
ratios: <code class="docutils literal notranslate"><span class="pre">data_marg</span> <span class="pre">=</span> <span class="pre">data</span> <span class="pre">*</span> <span class="pre">fitfcn(prior_marg)</span> <span class="pre">/</span> <span class="pre">fitfcn(prior)</span></code>.
If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), implement using differences:
<code class="docutils literal notranslate"><span class="pre">data_marg</span> <span class="pre">=</span> <span class="pre">data</span> <span class="pre">+</span> <span class="pre">(fitfcn(prior_marg)</span> <span class="pre">-</span> <span class="pre">fitfcn(prior))</span></code>.</p></li>
<li><p><strong>fast</strong> (<em>bool</em>) – Setting <code class="docutils literal notranslate"><span class="pre">fast=True</span></code> (default) strips any variable
not required by the fit from the prior. This speeds
fits but loses information about correlations between
variables in the fit and those that are not. Setting
<code class="docutils literal notranslate"><span class="pre">wavg_all=True</span></code> can restore some of the correlations, but
is somewhat slower.</p></li>
<li><p><strong>wavg_all</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">fast=True</span></code>, the final result of a
chained fit is the weighted average of all the fits in the chain.
This can restore correlations lost in the chain because
<code class="docutils literal notranslate"><span class="pre">fast=True</span></code>. This step is omitted if <code class="docutils literal notranslate"><span class="pre">wavg_all=False</span></code> or
<code class="docutils literal notranslate"><span class="pre">fast=False</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>fitname</strong> (callable or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – Individual fits in a chained fit are
assigned default names, constructed from the datatags of
the corresponding models, for access and reporting. These names
get unwieldy when lots of models are involved. When <code class="docutils literal notranslate"><span class="pre">fitname</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), each default name <code class="docutils literal notranslate"><span class="pre">dname</span></code> is
replaced by <code class="docutils literal notranslate"><span class="pre">fitname(dname)</span></code> which should return a string.</p></li>
<li><p><strong>wavg_kargs</strong> (<em>dict</em>) – Keyword arguments for <a class="reference internal" href="#lsqfit.wavg" title="lsqfit.wavg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.wavg()</span></code></a> when
used to combine results from parallel sub-fits in a chained fit.</p></li>
<li><p><strong>fitterargs</strong> (<em>dict</em>) – Additional arguments for the
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> object used to do the fits.
These can be collected in a dictionary (e.g.,
<code class="docutils literal notranslate"><span class="pre">fitterargs=dict(tol=1e-6,</span> <span class="pre">maxit=500))</span></code>) or listed as
separate arguments (e.g., <code class="docutils literal notranslate"><span class="pre">tol=1e-6,</span> <span class="pre">maxit=500</span></code>).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitter.lsqfit">
<span class="sig-name descname"><span class="pre">lsqfit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pdata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prior</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chained</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.lsqfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute least-squares fit of models to data.</p>
<p><a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.lsqfit()</span></code></a> fits all of the models together, in
a single fit. It returns the <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> object from the fit.</p>
<p>To see plots of the fit data divided by the fit function
with the best-fit parameters use</p>
<blockquote>
<div><p>fit.show_plots()</p>
</div></blockquote>
<p>This method has optional keyword arguments <code class="docutils literal notranslate"><span class="pre">save</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code>;
see documentation for <a class="reference internal" href="#lsqfit.MultiFitter.show_plots" title="lsqfit.MultiFitter.show_plots"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter.show_plots</span></code></a>
for more information. Plotting requires module <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<p>To bootstrap a fit, use <code class="docutils literal notranslate"><span class="pre">fit.bootstrapped_fit_iter(...)</span></code>;
see <a class="reference internal" href="#lsqfit.nonlinear_fit.bootstrapped_fit_iter" title="lsqfit.nonlinear_fit.bootstrapped_fit_iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit.bootstrapped_fit_iter()</span></code></a> for more
information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – Input data. One of <code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">pdata</span></code> must be
specified but not both. <code class="docutils literal notranslate"><span class="pre">pdata</span></code> is obtained from <code class="docutils literal notranslate"><span class="pre">data</span></code>
by collecting the output from <code class="docutils literal notranslate"><span class="pre">m.builddata(data)</span></code>
for each model <code class="docutils literal notranslate"><span class="pre">m</span></code> and storing it in a dictionary
with key <code class="docutils literal notranslate"><span class="pre">m.datatag</span></code>.</p></li>
<li><p><strong>pdata</strong> – Input data that has been processed by the
models using <a class="reference internal" href="#lsqfit.MultiFitter.process_data" title="lsqfit.MultiFitter.process_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.process_data()</span></code></a> or
<a class="reference internal" href="#lsqfit.MultiFitter.process_dataset" title="lsqfit.MultiFitter.process_dataset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.process_dataset()</span></code></a>. One of
<code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">pdata</span></code> must be  specified but not both.</p></li>
<li><p><strong>prior</strong> (<em>dict</em>) – Bayesian prior for fit parameters used by the models.</p></li>
<li><p><strong>p0</strong> – Dictionary , indexed by parameter labels, containing
initial values for the parameters in the fit. Setting
<code class="docutils literal notranslate"><span class="pre">p0=None</span></code> implies that initial values are extracted from the
prior. Setting <code class="docutils literal notranslate"><span class="pre">p0=&quot;filename&quot;</span></code> causes the fitter to look in
the file with name <code class="docutils literal notranslate"><span class="pre">&quot;filename&quot;</span></code> for initial values and to
write out best-fit parameter values after the fit (for the
next call to <code class="docutils literal notranslate"><span class="pre">self.lsqfit()</span></code>).</p></li>
<li><p><strong>chained</strong> (<em>bool</em>) – Use <a class="reference internal" href="#lsqfit.MultiFitter.chained_lsqfit" title="lsqfit.MultiFitter.chained_lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.chained_lsqfit()</span></code></a>
instead of <a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.lsqfit()</span></code></a> if <code class="docutils literal notranslate"><span class="pre">chained=True</span></code>.
Ignored otherwise. Default is <code class="docutils literal notranslate"><span class="pre">chained=False</span></code>.</p></li>
<li><p><strong>kargs</strong> – Arguments that (temporarily) override parameters specified
when the <a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiFitter</span></code></a> was created. Can also include
additional arguments to be passed through to the <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a>
fitter.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitter.chained_lsqfit">
<span class="sig-name descname"><span class="pre">chained_lsqfit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pdata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prior</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.chained_lsqfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute chained least-squares fit of models to data. Equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pdata</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">chained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>In a chained fit to models <code class="docutils literal notranslate"><span class="pre">[s1,</span> <span class="pre">s2,</span> <span class="pre">...]</span></code>, the models are fit one
at a time, with the fit output from one being fed into the prior for
the next. This can be much faster than  fitting the models together,
simultaneously. The final result comes from the last fit in the chain,
and includes parameters from all of the models.</p>
<p>The most general chain has the structure <code class="docutils literal notranslate"><span class="pre">[s1,</span> <span class="pre">s2,</span> <span class="pre">s3</span> <span class="pre">...]</span></code>
where each <code class="docutils literal notranslate"><span class="pre">sn</span></code> is one of:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>A model (derived from <code class="xref py py-class docutils literal notranslate"><span class="pre">multifitter.MultiFitterModel</span></code>).</p></li>
<li><dl class="simple">
<dt>A tuple <code class="docutils literal notranslate"><span class="pre">(m1,</span> <span class="pre">m2,</span> <span class="pre">m3)</span></code> of models, to be fit together in</dt><dd><p>a single fit (i.e., simultaneously). Simultaneous fits
are useful for closely related models.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A list <code class="docutils literal notranslate"><span class="pre">[p1,</span> <span class="pre">p2,</span> <span class="pre">p3</span> <span class="pre">...]</span></code> where each <code class="docutils literal notranslate"><span class="pre">pn</span></code> is either</dt><dd><p>a model, a tuple of models (see #2), or a dictionary (see #4).
The <code class="docutils literal notranslate"><span class="pre">pn</span></code> are fit separately: the fit output from one fit is
<em>not</em> fed into the prior of the next (i.e., the fits are
effectively in parallel). Results from the separate fits are
averaged at the end to provide a single composite result for
the collection of fits. Parallel fits are effective (and fast)
when the different fits have few or no fit parameters in
common.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A dictionary that (temporarily) resets default values for</dt><dd><p>fitter keywords. The new values, specified in the dictionary,
apply to subsequent fits in the chain. Any number of such
dictionaries can be included in the model chain.</p>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
<p>Fit results are returned in a
<code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter.chained_nonlinear_fit</span></code> object <code class="docutils literal notranslate"><span class="pre">fit</span></code>,
which is very similar to a <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">nonlinear_fit</span></code></a>
object (see documentation for more information). Object <code class="docutils literal notranslate"><span class="pre">fit</span></code> has an
extra attribute <code class="docutils literal notranslate"><span class="pre">fit.chained_fits</span></code> which is an ordered dictionary
containing fit results for each link in the chain of fits, indexed by
fit names built from the corresponding data tags.</p>
<p>To list results from all of the fits in the chain, use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">formatall</span><span class="p">())</span>
</pre></div>
</div>
<p>This method has optional keyword arguments <code class="docutils literal notranslate"><span class="pre">maxline</span></code>,
<code class="docutils literal notranslate"><span class="pre">pstyle</span></code>, and <code class="docutils literal notranslate"><span class="pre">nline</span></code>; see the documentation for
<a class="reference internal" href="#lsqfit.nonlinear_fit.format" title="lsqfit.nonlinear_fit.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit.format()</span></code></a> for more
information.</p>
<p>To view plots of each fit use</p>
<blockquote>
<div><p>fit.show_plots()</p>
</div></blockquote>
<p>This method has optional keyword arguments <code class="docutils literal notranslate"><span class="pre">save</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code>;
see documentation for <a class="reference internal" href="#lsqfit.MultiFitter.show_plots" title="lsqfit.MultiFitter.show_plots"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter.show_plots</span></code></a>
for more information. Plotting requires module <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<p>To bootstrap a fit, use <code class="docutils literal notranslate"><span class="pre">fit.bootstrapped_fit_iter(...)</span></code>;
see <a class="reference internal" href="#lsqfit.nonlinear_fit.bootstrapped_fit_iter" title="lsqfit.nonlinear_fit.bootstrapped_fit_iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit.bootstrapped_fit_iter()</span></code></a> for more
information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – Input data. One of <code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">pdata</span></code> must be
specified but not both. <code class="docutils literal notranslate"><span class="pre">pdata</span></code> is obtained from <code class="docutils literal notranslate"><span class="pre">data</span></code>
by collecting the output from <code class="docutils literal notranslate"><span class="pre">m.builddata(data)</span></code>
for each model <code class="docutils literal notranslate"><span class="pre">m</span></code> and storing it in a dictionary
with key <code class="docutils literal notranslate"><span class="pre">m.datatag</span></code>.</p></li>
<li><p><strong>pdata</strong> – Input data that has been processed by the
models using <a class="reference internal" href="#lsqfit.MultiFitter.process_data" title="lsqfit.MultiFitter.process_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.process_data()</span></code></a> or
<a class="reference internal" href="#lsqfit.MultiFitter.process_dataset" title="lsqfit.MultiFitter.process_dataset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.process_dataset()</span></code></a>. One of
<code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">pdata</span></code> must be  specified but not both.</p></li>
<li><p><strong>prior</strong> – Bayesian prior for fit parameters used by the models.</p></li>
<li><p><strong>p0</strong> – <p>Dictionary , indexed by parameter labels, containing
initial values for the parameters in the fit. Setting
<code class="docutils literal notranslate"><span class="pre">p0=None</span></code> implies that initial values are extracted from the
prior. Setting <code class="docutils literal notranslate"><span class="pre">p0=&quot;filename&quot;</span></code> causes the fitter to look in
the file with name <code class="docutils literal notranslate"><span class="pre">&quot;filename&quot;</span></code> for initial values and to
write out best-fit parameter values after the fit (for the
next call to <code class="docutils literal notranslate"><span class="pre">self.chained_lsqfit()</span></code>). Finally,
<code class="docutils literal notranslate"><span class="pre">p0</span></code> can be a list containing a different <code class="docutils literal notranslate"><span class="pre">p0</span></code> for each
fit in the chain: for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p0</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">pmean</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">chained_fits</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
</pre></div>
</div>
<p>might be a good starting point for the next fit.</p>
</p></li>
<li><p><strong>kargs</strong> – Arguments that override parameters specified when
the <a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiFitter</span></code></a> was created. Can also include
additional arguments to be passed through to
the <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> fitter.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitter.empbayes_fit">
<span class="sig-name descname"><span class="pre">empbayes_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitargs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">minargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.empbayes_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fit and <code class="docutils literal notranslate"><span class="pre">z</span></code> corresponding to the fit
<code class="docutils literal notranslate"><span class="pre">self.lsqfit(**fitargs(z))</span></code> that maximizes <code class="docutils literal notranslate"><span class="pre">logGBF</span></code>.</p>
<p>This function maximizes the logarithm of the Bayes Factor from
fit  <code class="docutils literal notranslate"><span class="pre">self.lsqfit(**fitargs(z))</span></code> by varying <code class="docutils literal notranslate"><span class="pre">z</span></code>,
starting at <code class="docutils literal notranslate"><span class="pre">z0</span></code>. The fit is redone for each value of <code class="docutils literal notranslate"><span class="pre">z</span></code>
that is tried, in order to determine <code class="docutils literal notranslate"><span class="pre">logGBF</span></code>.</p>
<p>The Bayes Factor is proportional to the probability that the data
came from the model (fit function and priors) used in the fit.
<a class="reference internal" href="#lsqfit.MultiFitter.empbayes_fit" title="lsqfit.MultiFitter.empbayes_fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.empbayes_fit()</span></code></a> finds the model or data that maximizes this
probability. See <a class="reference internal" href="#lsqfit.empbayes_fit" title="lsqfit.empbayes_fit"><code class="xref py py-func docutils literal notranslate"><span class="pre">lsqfit.empbayes_fit()</span></code></a> for more information.</p>
<p>Include <code class="docutils literal notranslate"><span class="pre">chained=True</span></code> in the dictionary returned by <code class="docutils literal notranslate"><span class="pre">fitargs(z)</span></code>
if chained fits are desired. See documentation
for <a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.lsqfit()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>z0</strong> (<em>number</em><em>, </em><em>array</em><em> or </em><em>dict</em>) – Starting point for search.</p></li>
<li><p><strong>fitargs</strong> (<em>callable</em>) – Function of <code class="docutils literal notranslate"><span class="pre">z</span></code> that returns a
dictionary <code class="docutils literal notranslate"><span class="pre">args</span></code> containing the <a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.lsqfit()</span></code></a>
arguments corresponding to <code class="docutils literal notranslate"><span class="pre">z</span></code>. <code class="docutils literal notranslate"><span class="pre">z</span></code> should have
the same layout (number, array or dictionary) as <code class="docutils literal notranslate"><span class="pre">z0</span></code>.
<code class="docutils literal notranslate"><span class="pre">fitargs(z)</span></code> can instead return a tuple <code class="docutils literal notranslate"><span class="pre">(args,</span> <span class="pre">plausibility)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">args</span></code> is again the dictionary for
<a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.lsqfit()</span></code></a>. <code class="docutils literal notranslate"><span class="pre">plausibility</span></code> is the logarithm
of the <em>a priori</em> probabilitiy that <code class="docutils literal notranslate"><span class="pre">z</span></code> is sensible. When
<code class="docutils literal notranslate"><span class="pre">plausibility</span></code> is provided, <a class="reference internal" href="#lsqfit.MultiFitter.empbayes_fit" title="lsqfit.MultiFitter.empbayes_fit"><code class="xref py py-func docutils literal notranslate"><span class="pre">MultiFitter.empbayes_fit()</span></code></a>
maximizes the sum <code class="docutils literal notranslate"><span class="pre">logGBF</span> <span class="pre">+</span> <span class="pre">plausibility</span></code>. Specifying
<code class="docutils literal notranslate"><span class="pre">plausibility</span></code> is a way of steering selections away from
completely implausible values for <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p></li>
<li><p><strong>minargs</strong> (<em>dict</em>) – Optional argument dictionary, passed on to
<a class="reference internal" href="gsl.html#lsqfit.gsl_multiminex" title="lsqfit.gsl_multiminex"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.gsl_multiminex</span></code></a> (or
<a class="reference internal" href="scipy.html#lsqfit.scipy_multiminex" title="lsqfit.scipy_multiminex"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.scipy_multiminex</span></code></a>), which finds the minimum.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple containing the best fit (a fit object) and the
optimal value for parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitter.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset default keyword parameters.</p>
<p>Assigns new default values from dictionary <code class="docutils literal notranslate"><span class="pre">kargs</span></code> to the fitter’s
keyword parameters. Keywords for the underlying <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> fitters
can also be  included (or grouped together in dictionary
<code class="docutils literal notranslate"><span class="pre">fitterargs</span></code>).</p>
<p>Returns tuple <code class="docutils literal notranslate"><span class="pre">(kargs,</span> <span class="pre">oldkargs)</span></code> where <code class="docutils literal notranslate"><span class="pre">kargs</span></code> is a dictionary
containing all <a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> keywords after they have
been updated, and <code class="docutils literal notranslate"><span class="pre">oldkargs</span></code> contains the  original values for these
keywords. Use <code class="docutils literal notranslate"><span class="pre">fitter.set(**oldkargs)</span></code> to restore the original
values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitter.process_data">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">process_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">models</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.process_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <code class="docutils literal notranslate"><span class="pre">data</span></code> to processed data using <code class="docutils literal notranslate"><span class="pre">models</span></code>.</p>
<p>Data from dictionary <code class="docutils literal notranslate"><span class="pre">data</span></code> is processed by each model
in list <code class="docutils literal notranslate"><span class="pre">models</span></code>, and the results collected into a new
dictionary <code class="docutils literal notranslate"><span class="pre">pdata</span></code> for use in <a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.lsqfit()</span></code></a>
and <code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.chained_lsqft()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitter.process_dataset">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">process_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">models</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.process_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <code class="docutils literal notranslate"><span class="pre">dataset</span></code> to processed data using <code class="docutils literal notranslate"><span class="pre">models</span></code>.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.dataset.Dataset</span></code> (or similar dictionary) object
<code class="docutils literal notranslate"><span class="pre">dataset</span></code> is processed by each model in list <code class="docutils literal notranslate"><span class="pre">models</span></code>,
and the results collected into a new dictionary <code class="docutils literal notranslate"><span class="pre">pdata</span></code> for use in
<a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.lsqfit()</span></code></a> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.chained_lsqft()</span></code>.
Assumes that the models have defined method
<a class="reference internal" href="#lsqfit.MultiFitterModel.builddataset" title="lsqfit.MultiFitterModel.builddataset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitterModel.builddataset()</span></code></a>. Keyword arguments
<code class="docutils literal notranslate"><span class="pre">kargs</span></code> are passed on to <code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.dataset.avg_data()</span></code> when
averaging the data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitter.show_plots">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">show_plots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fitdata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ratio'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.show_plots" title="Permalink to this definition">¶</a></dt>
<dd><p>Show plots comparing <code class="docutils literal notranslate"><span class="pre">fitdata[k],fitval[k]</span></code> for each key <code class="docutils literal notranslate"><span class="pre">k</span></code> in <code class="docutils literal notranslate"><span class="pre">fitval</span></code>.</p>
<p>Assumes <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code> is installed (to make the plots). Plots
are shown for one correlator at a time. Press key <code class="docutils literal notranslate"><span class="pre">n</span></code> to see the
next correlator; press key <code class="docutils literal notranslate"><span class="pre">p</span></code> to see the previous one; press key
<code class="docutils literal notranslate"><span class="pre">q</span></code> to quit the plot and return control to the calling program;
press a digit to go directly to one of the first ten plots. Zoom,
pan and save using the window controls.</p>
<p>There are several different views available for each plot,
specified by parameter <code class="docutils literal notranslate"><span class="pre">view</span></code>:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">view='ratio'</span></code>: Data divided by fit (default).</p>
<p><code class="docutils literal notranslate"><span class="pre">view='diff'</span></code>: Data minus fit, divided by data’s standard deviation.</p>
<p><code class="docutils literal notranslate"><span class="pre">view='std'</span></code>: Data and fit.</p>
<p><code class="docutils literal notranslate"><span class="pre">view='log'</span></code>: <code class="docutils literal notranslate"><span class="pre">'std'</span></code> with log scale on the vertical axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">view='loglog'</span></code>: <cite>‘std’`</cite> with log scale on both axes.</p>
</div></blockquote>
<p>Press key <code class="docutils literal notranslate"><span class="pre">v</span></code> to cycle through these  views; or press keys
<code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code>, or <code class="docutils literal notranslate"><span class="pre">l</span></code> for the <code class="docutils literal notranslate"><span class="pre">'ratio'</span></code>, <code class="docutils literal notranslate"><span class="pre">'diff'</span></code>,
or <code class="docutils literal notranslate"><span class="pre">'log'</span></code> views, respectively.</p>
<p>Copies of the plots that are viewed can be saved by setting parameter
<code class="docutils literal notranslate"><span class="pre">save=fmt</span></code> where <code class="docutils literal notranslate"><span class="pre">fmt</span></code> is a string used to create
file names: the file name for the plot corresponding to key
<code class="docutils literal notranslate"><span class="pre">k</span></code> is <code class="docutils literal notranslate"><span class="pre">fmt.format(k)</span></code>. It is important that the
filename end with a suffix indicating the type of plot file
desired: e.g., <code class="docutils literal notranslate"><span class="pre">fmt='plot-{}.pdf'</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitter.flatten_models">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">flatten_models</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">models</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.flatten_models" title="Permalink to this definition">¶</a></dt>
<dd><p>Create 1d-array containing all disctinct models from <code class="docutils literal notranslate"><span class="pre">models</span></code>.</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> models are derived from the following
class. Methods <code class="docutils literal notranslate"><span class="pre">buildprior</span></code>, <code class="docutils literal notranslate"><span class="pre">builddata</span></code>, <code class="docutils literal notranslate"><span class="pre">fitfcn</span></code>, and
<code class="docutils literal notranslate"><span class="pre">builddataset</span></code> are not implemented in this base
class. They need to be overwritten by the derived class (except
for <code class="docutils literal notranslate"><span class="pre">builddataset</span></code> which is optional).</p>
<dl class="py class">
<dt class="sig sig-object py" id="lsqfit.MultiFitterModel">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">lsqfit.</span></span><span class="sig-name descname"><span class="pre">MultiFitterModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datatag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitterModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for MultiFitter models.</p>
<p>Derived classes must define methods <code class="docutils literal notranslate"><span class="pre">fitfcn</span></code>, <code class="docutils literal notranslate"><span class="pre">buildprior</span></code>, and
<code class="docutils literal notranslate"><span class="pre">builddata</span></code>, all of which are described below. In addition they
have attributes:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.MultiFitterModel.datatag">
<span class="sig-name descname"><span class="pre">datatag</span></span><a class="headerlink" href="#lsqfit.MultiFitterModel.datatag" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> builds fit data for the correlator by
extracting the data labelled by <code class="docutils literal notranslate"><span class="pre">datatag</span></code> (eg, a string) from an
input data set (eg, a dictionary). This label is stored in the
<code class="docutils literal notranslate"><span class="pre">MultiFitterModel</span></code> and must be passed to its constructor. It must be
a hashable quantity, like a string or number or tuple of strings and
numbers.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lsqfit.MultiFitterModel.ncg">
<span class="sig-name descname"><span class="pre">ncg</span></span><a class="headerlink" href="#lsqfit.MultiFitterModel.ncg" title="Permalink to this definition">¶</a></dt>
<dd><p>When <code class="docutils literal notranslate"><span class="pre">ncg&gt;1</span></code>, fit data and functions are coarse-grained by
breaking them up into bins of of <code class="docutils literal notranslate"><span class="pre">ncg</span></code> values and replacing
each bin by its average. This can increase the fitting speed,
because there is less data, without much loss of precision
if the data elements within a bin are highly correlated.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>datatag</strong> – Label used to identify model’s data.</p></li>
<li><p><strong>ncg</strong> (<em>int</em>) – Size of bins for coarse graining (default is <code class="docutils literal notranslate"><span class="pre">ncg=1</span></code>).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitterModel.buildprior">
<span class="sig-name descname"><span class="pre">buildprior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mopt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitterModel.buildprior" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract fit prior from <code class="docutils literal notranslate"><span class="pre">prior</span></code>.</p>
<p>Returns a dictionary containing the  part of dictionary
<code class="docutils literal notranslate"><span class="pre">prior</span></code> that is relevant to this model’s fit. The code could
be as simple as collecting the appropriate pieces: e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">buildprior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">mopt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">mprior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>
    <span class="n">model_keys</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">model_keys</span><span class="p">:</span>
        <span class="n">mprior</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mprior</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">model_keys</span></code> is a list of keys corresponding to
the model’s parameters. Supporting non-Gaussian distributions
requires a slight modification: e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">buildprior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">mopt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">mprior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>
    <span class="n">model_keys</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">gv</span><span class="o">.</span><span class="n">get_dictkeys</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="n">model_keys</span><span class="p">):</span>
        <span class="n">mprior</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mprior</span>
</pre></div>
</div>
<p>Marginalization involves omitting some of the fit parameters from the
model’s prior. <code class="docutils literal notranslate"><span class="pre">mopt=None</span></code> implies no marginalization. Otherwise
<code class="docutils literal notranslate"><span class="pre">mopt</span></code> will typically contain information about what and how much
to marginalize.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prior</strong> – Dictionary containing <em>a priori</em> estimates of all
fit parameters.</p></li>
<li><p><strong>mopt</strong> (<em>object</em>) – Marginalization options. Ignore if <code class="docutils literal notranslate"><span class="pre">None</span></code>.
Otherwise marginalize fit parameters as specified by <code class="docutils literal notranslate"><span class="pre">mopt</span></code>.
<code class="docutils literal notranslate"><span class="pre">mopt</span></code> can be any type of Python object; it is used only
in <code class="docutils literal notranslate"><span class="pre">buildprior</span></code> and is passed through to it unchanged.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitterModel.builddata">
<span class="sig-name descname"><span class="pre">builddata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitterModel.builddata" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract fit data corresponding to this model from data set <code class="docutils literal notranslate"><span class="pre">data</span></code>.</p>
<p>The fit data is returned in a 1-dimensional array;
the fitfcn must return arrays of the same length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – Data set containing the fit data for all models. This
is typically a dictionary, whose keys are the <code class="docutils literal notranslate"><span class="pre">datatag</span></code>s
of the models.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitterModel.fitfcn">
<span class="sig-name descname"><span class="pre">fitfcn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitterModel.fitfcn" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute fit function fit for parameters <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>Results are returned in a 1-dimensional array the
same length as (and corresponding to) the fit data
returned by <code class="docutils literal notranslate"><span class="pre">self.builddata(data)</span></code>.</p>
<p>If marginalization is supported, <code class="docutils literal notranslate"><span class="pre">fitfcn</span></code> must work
with or without the marginalized parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p</strong> – Dictionary of parameter values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfit.MultiFitterModel.builddataset">
<span class="sig-name descname"><span class="pre">builddataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitterModel.builddataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract fit dataset from <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.dataset.Dataset</span></code> <code class="docutils literal notranslate"><span class="pre">dataset</span></code>.</p>
<p>The code</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">builddataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">))</span>
</pre></div>
</div>
<p>that builds data for model <code class="docutils literal notranslate"><span class="pre">m</span></code> should be functionally
equivalent to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">builddata</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">dataset</span><span class="p">))</span>
</pre></div>
</div>
<p>This method is optional. It is used only by
<a class="reference internal" href="#lsqfit.MultiFitter.process_dataset" title="lsqfit.MultiFitter.process_dataset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.process_dataset()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dataset</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.dataset.Dataset</span></code> (or similar dictionary)
dataset containing the fit data for all models. This is
typically a dictionary, whose keys are the <code class="docutils literal notranslate"><span class="pre">datatag</span></code>s of
the models.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> and <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code> modules were originally created to facilitate statistical analyses of data generated by lattice QCD simulations. Background information about the techniques used in these modules can be found in several articles (on lattice QCD applications):</p>
<blockquote>
<div><ul class="simple">
<li><p>For a general discussion of Bayesian fitting (and Empirical Bayes) see: G.P. Lepage et al, Nucl.Phys.Proc.Suppl. 106 (2002) 12-20 [<a class="reference external" href="https://arxiv.org/pdf/hep-lat/0110175.pdf">hep-lat/0110175</a>].</p></li>
<li><p>For a discussion of the underlying analysis in a fit and the meaning of the error budget see Appendix A in: C. Bouchard et al, Phys.Rev. D90 (2014) 054506 [<a class="reference external" href="https://arxiv.org/pdf/1406.2279.pdf">arXiv:1406.2279</a>].</p></li>
<li><p>For a discussion of marginalization see the appendix in: C. McNeile et al, Phys.Rev. D82, 034512 (2010) [<a class="reference external" href="https://arxiv.org/pdf/1004.4285.pdf">arXiv:1004.4285</a>]. For another sample application see: K. Hornbostel et al, Phys.Rev. D85 (2012) 031504 [<a class="reference external" href="https://arxiv.org/pdf/1111.1363.pdf">arXiv:1111.1363</a>].</p></li>
<li><p>For a discussion of SVD cuts (and goodness-of-fit) see Appendix D in: R.J. Dowdall et al, Phys.Rev. D100 (2019) 9, 094508 [<a class="reference external" href="https://arxiv.org/pdf/1907.01025.pdf">arXiv:1907.01025</a>].</p></li>
</ul>
</div></blockquote>
</section>
<section id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> relies heavily on the <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code>, and <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> modules.
Also the fitting and minimization routines are from
the Gnu Scientific Library (GSL) and/or the Python <code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy</span></code> module.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code> - Nonlinear Least Squares Fitting</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#nonlinear-fit-objects">nonlinear_fit Objects</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#lsqfit-multifitter-classes"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code> Classes</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="case-outliers.html"
                        title="previous chapter">Case Study: Outliers and Bayesian Integrals</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="gsl.html"
                        title="next chapter">GSL Routines</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/lsqfit.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gsl.html" title="GSL Routines"
             >next</a> |</li>
        <li class="right" >
          <a href="case-outliers.html" title="Case Study: Outliers and Bayesian Integrals"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">lsqfit 13 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code> - Nonlinear Least Squares Fitting</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2019, G. P. Lepage.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>